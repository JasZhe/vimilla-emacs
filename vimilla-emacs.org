#+title: Minimalistic Vim Flavoured Emacs Config
#+PROPERTY: header-args :tangle init.el :results silent

* CANCELLED separate document for keybindings?
I do enjoy having everything in the one file though and a lot of this stuff is not /just/ setting keybinds,
its also doing a lot of elisp stuff that work /with/ the keybinds

* WIP other git commands that VC doesn't handle like git rebase and stuff
something like this

mainly for these two:
git fetch
git rebase

and need to figure out keymappings

just a simple wrapper in the case where we can't install magit
#+begin_src elisp
  (defun my/vc-git-editor-command (command)
    "command is a git subcommand that requires an editor.
  example usage: (my/vc-git-editor-command \"rebase -i HEAD~3\")"
    (interactive "P")
    (unless server-mode (server-force-delete) (server-mode))
    (let ((command (if command command (read-string "command: git "))))
      (compile (concat "GIT_EDITOR=\"emacsclient\" bash -c \"git " command "\""))))

  (defun my/vc-git-rebase-i (&optional branch)
    "if branch isn't supplied from arg, prompt for it"
    (interactive)
    (let ((revision (if branch branch (read-string "revision: "))))
      (my/vc-git-editor-command (concat "rebase -i " revision))))

  (defun my/vc-git-rebase-abort ()
    (interactive)
    (compile "git rebase --abort"))

  (defun my/vc-git-rebase-continue ()                  
    (interactive)                                 
    (compile "git rebase --continue"))

  (defun my/vc-git-fetch ()                  
    (interactive)                                  
    (compile "git fetch -v"))
#+end_src

* convenient alias
org really hates the parens matching when < or > is involved
#+begin_src elisp
  (defalias 'gt #'>)
  (defalias 'gt= #'>=)
  (defalias 'lt #'<)
  (defalias 'lt= #'<=)
  (defun neq (obj1 obj2)
    "Convenience for not 'eq'"
    (not (eq obj1 obj2)))
#+end_src

* ediff-setup
#+begin_src elisp
  (use-package ediff :defer t
    :config
    (advice-remove 'ediff-quit #'disable-y-or-n-p)
    (defun disable-y-or-n-p (orig-fun &rest args)
      (cl-letf (((symbol-function 'y-or-n-p) (lambda (prompt) t)))
        (apply orig-fun args)))
    (advice-add 'ediff-quit :around #'disable-y-or-n-p)

    (setq ediff-keep-variants nil)
    (setq ediff-window-setup-function #'ediff-setup-windows-plain)
    (setq ediff-split-window-function #'split-window-horizontally))
#+end_src

* Mac settings
if machine isn't a mac then this won't do anything anyways so need to do some OS version check or whatever

Also keybinds for super key
see the emacs wiki page for how this works:
https://www.emacswiki.org/emacs/iTerm2

Basically go to iterm settings -> keys -> + button to add a keybind
make a keybind for cmd-/ and set it to send an escape sequence for [1;P9
then map that [1;P9 to whatever we want.

The P9 can go to like P56. [1;P9 maps to like CTRL CMD OPTION A, which we probably aren't gonna use lol so it's safe to map that to something more useful
#+begin_src elisp
  (setq mac-option-modifier 'meta)
  (setq mac-command-modifier 'super)
  (define-key global-map (kbd "s-/") #'comment-line)

  ;; terminal stuff, C-/ in case we don't have iterm config
  (define-key global-map (kbd "C-/") #'comment-line)
  (define-key global-map (kbd "C-_") #'comment-line)
  (define-key input-decode-map "\e[1;P9" (kbd "s-/"))
#+end_src

* terminal settings
#+begin_src elisp
  (defun macos-term-select-text-to-clipboard (text)
    (shell-command (concat "echo \"" text "\" | pbcopy" )))

  ;; ITERM2 MOUSE SUPPORT
  (unless window-system
    (require 'mouse)
    (xterm-mouse-mode t)
    (defun track-mouse (e)) 
    (setq mouse-sel-mode t)
    (setq interprogram-cut-function #'macos-term-select-text-to-clipboard)) ;; good enough
#+end_src

* Window commands
:PROPERTIES:
:VISIBILITY: folded
:END:
not necessary viper, but same idea
need to set the window map before viper loads cause we use it in the motion keymap
#+begin_src elisp
  (winner-mode)

  (defun my/set-transparency-in-terminal ()
    (interactive)
    (unless (display-graphic-p (selected-frame))
      (setq prev-default-face-bg (face-background 'default))
      (set-face-background 'default "unspecified-bg" (selected-frame))))

  (defun my/unset-transparency-in-terminal ()
    (interactive)
    (unless (display-graphic-p (selected-frame))
      (set-face-background 'default prev-default-face-bg (selected-frame))))

  (defun my/set-frame-alpha (&optional arg)
    (interactive "sFrame Alpha? ")
    (if
        (and arg (not (string-empty-p arg)))
        (set-frame-parameter nil 'alpha  (string-to-number arg))
      (set-frame-parameter nil 'alpha 90)))

  (defun my/set-frame-alpha-background (&optional arg)
    (interactive "sFrame Alpha Background? ")
    (if
        (and arg (not (string-empty-p arg)))
        (set-frame-parameter nil 'alpha-background  (string-to-number arg))
      (set-frame-parameter nil 'alpha-background 90)))

  (setq my-window-map (make-sparse-keymap))

  (define-key my-window-map "u" #'winner-undo)
  (define-key my-window-map "r" #'winner-redo)

  (define-key my-window-map "<"
              (lambda (arg) (interactive "P") (shrink-window-horizontally (if arg arg 1))))
  (define-key my-window-map ">"
              (lambda (arg) (interactive "P") (enlarge-window-horizontally (if arg arg 1))))

  (define-key my-window-map "-"
              (lambda (arg) (interactive "P") (shrink-window (if arg arg 1))))
  (define-key my-window-map "+"
              (lambda (arg) (interactive "P") (enlarge-window (if arg arg 1))))

  (define-key my-window-map "v" #'split-window-horizontally)
  (define-key my-window-map "s" #'split-window-vertically)

  (define-key my-window-map "q" #'delete-window)
  (define-key my-window-map "\C-w" #'other-window)

  (define-key my-window-map "l" #'windmove-right)
  (define-key my-window-map "\C-l" #'windmove-right)

  (define-key my-window-map "h" #'windmove-left)
  (define-key my-window-map "\C-h" #'windmove-left)

  (define-key my-window-map "k" #'windmove-up)
  (define-key my-window-map "\C-k" #'windmove-up)

  (define-key my-window-map "j" #'windmove-down)
  (define-key my-window-map "\C-j" #'windmove-down)

  (define-key my-window-map "=" #'balance-windows)

  (define-key my-window-map "o" #'maximize-window)
  (define-key my-window-map "\C-o" #'delete-other-windows)

  (define-key global-map (kbd "\C-w") nil)
  (define-key global-map (kbd "\C-w") my-window-map)
#+end_src

* misc startup tasks
viper mode, global hl and visual lines
stole the completing read stuff from:
#+begin_src elisp

  (setq gc-cons-threshold most-positive-fixnum)

  ;; Lower threshold back to 8 MiB (default is 800kB)
  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold (expt 2 23))))

  (setq inhibit-startup-screen t)  
  (tool-bar-mode 0)
  (setq viper-mode t)
  (require 'viper)
  (require 'rect)

  (viper-mode)
  (global-hl-line-mode)
  (global-auto-revert-mode)
  (setq auto-revert-verbose nil)
  (global-visual-line-mode)
  (add-hook 'prog-mode-hook (lambda () (modify-syntax-entry ?_ "-") (modify-syntax-entry ?_ "_")))

  (setq column-number-mode t)
  (setq scroll-margin 8)
  (setq visual-bell t)
  (setq ring-bell-function 'ignore)
  (setq scroll-preserve-screen-position t)
  (setq eval-expression-print-level nil)
  (setq eval-expression-print-length nil)
#+end_src

* minibuffer setup

Use partial-completion by default, most similar to orderless
useful keybinds C-j to exit minibuffer with first candidate
M-j to exit minibuffer with whatever is in the input
#+begin_src elisp
  (fido-vertical-mode)

  (keymap-set minibuffer-local-completion-map "TAB" #'icomplete-force-complete)
  (define-key minibuffer-local-completion-map (kbd "C-<return>") #'viper-exit-minibuffer)
  (keymap-set global-map "C-z" #'viper-mode) ;; C-z to suspend frame is annoying with viper

  (setq completion-styles '(partial-completion basic) completion-category-overrides nil completion-category-defaults nil)
  (defun my-icomplete-styles () (setq-local completion-styles '(partial-completion basic)))
  (add-hook 'icomplete-minibuffer-setup-hook 'my-icomplete-styles)

  ;; insert * at the beginning so we don't have to match exactly at the beginning
  ;; but only in the icomplete minibuffer so we don't clash with viper minibuffer and stuff
  (defun icomplete-partial-completion-setup ()
    (unless (or (eq (icomplete--category) 'file))
      (insert "*")))
  (add-hook 'icomplete-minibuffer-setup-hook #'icomplete-partial-completion-setup)

  ;; insert wild card to sorta emulate orderless
  (defun icomplete-partial-completion-insert-wildcard ()
    (interactive)
    (unless (eq last-command 'viper-ex)
      (insert "*")))

  (define-key icomplete-minibuffer-map " " #'icomplete-partial-completion-insert-wildcard)
  ;; this allows us to still insert spaces
  (define-key icomplete-minibuffer-map (kbd "M-SPC") (lambda () (interactive) (insert " ")))
#+end_src

* in-buffer searching
** advice to highlight matches with viper search
#+begin_src elisp
  (advice-add #'viper-search :after
              (lambda (string &rest args)
                (hi-lock-face-buffer string)))
#+end_src

** optional incremental occur, similar to swiper
[[*better escape handling][advice to turn off highlighting on escape]]
#+begin_src elisp
  ;; keep highlighting after isearch
  (setq lazy-highlight-cleanup nil)

  (defun my/ioccur-minibuf-after-edit (beg end len)
    (setq my/ioccur-string (buffer-substring-no-properties (1+ (length my/ioccur-prompt-string)) (point-max)))
    (when (gt (length (string-replace ".*" "" my/ioccur-string)) 2)
      (ignore-errors (occur-1 my/ioccur-string
                              my/ioccur-nlines-arg
                              (list my/occur-buffer)))))

  (setq my/ioccur-prompt-string "Find: ")
  (setq my/ioccur-string "")

  (defun my/ioccur (arg)
    "Run a pseudo interactive grep, which will incrementally update the xref buffer based on minibuffer input.
  With a prefix-arg run normally and specfiy a directory"
    (interactive "P")
    (setq my/ioccur-string "")
    (setq my/occur-buffer (current-buffer))
    (setq my/ioccur-nlines-arg (when arg (prefix-numeric-value arg)))
    (minibuffer-with-setup-hook
        (lambda ()
          (local-set-key (kbd "SPC") (lambda () (interactive) (insert ".*")))
          (add-hook 'after-change-functions #'my/ioccur-minibuf-after-edit nil 'local))
      (occur-1 (read-regexp my/ioccur-prompt-string)
               my/ioccur-nlines-arg
               (list my/occur-buffer))))
#+end_src

* incremental grep
Acts like occur, deferring a lot of the work to the existing xref buffer functionality
good enough without getting too complicated

don't actually run it until we have at least 5 chars to prevent initial lag

then with prefix arg we basically do the normal project-find-regexp but we can specify the directory
#+begin_src elisp
  (defun my/igrep-minibuf-after-edit (beg end len)
    (setq my/igrep-string (buffer-substring-no-properties (1+ (length my/igrep-prompt-string)) (point-max)))
    (when (gt (length (string-replace ".*" "" my/igrep-string)) 2)
      (cl-letf (((symbol-function 'pop-to-buffer) (lambda (buf &optional _ _) (display-buffer buf))))
        (ignore-errors (project-find-regexp my/igrep-string)))))

  (setq my/igrep-prompt-string "Find in proj: ")
  (setq my/igrep-string "")

  (defun my/igrep (arg)
    "Run a pseudo interactive grep, which will incrementally update the xref buffer based on minibuffer input.
  With a prefix-arg run normally and specfiy a directory"
    (interactive "P")
    (setq my/igrep-string "")
    (if arg
        (let ((current-prefix-arg '(4)))
          (call-interactively #'project-find-regexp))
      (let ((xref-show-xrefs-function #'xref--show-xref-buffer))
        (minibuffer-with-setup-hook
            (lambda ()
              (local-set-key (kbd "SPC") (lambda () (interactive) (insert ".*")))
              (add-hook 'after-change-functions #'my/igrep-minibuf-after-edit nil 'local))
          (project-find-regexp (read-regexp my/igrep-prompt-string))))))
#+end_src

** command to use ripgrep instead
#+begin_src elisp
  (defun ripgrep ()
    (interactive)
    (call-interactively 'grep))

  (defun rripgrep ()
    (interactive)
    (call-interactively 'rgrep))

  (advice-add
   #'grep-compute-defaults
   :before (lambda ()
             (if (or (eq this-command 'ripgrep) (eq this-command 'rripgrep))
                 (progn
                   (grep-apply-setting 'grep-command "rg -nS --no-heading ")
                   (grep-apply-setting 'grep-find-template "find <D> <X> -type f <F> -exec rg <C> --no-heading -H  <R> /dev/null {} +"))
               (progn
                 (grep-apply-setting 'grep-find-template "find -H <D> <X> -type f <F> -exec grep <C> -nH --null -e <R> \\{\\} +")
                 (grep-apply-setting 'grep-command "grep --color=auto -nH --null -e")))))

  #+end_src

* completion

** default to dabbrev-capf
#+begin_src elisp
  (require 'dabbrev)
  ;; #'dabbrev-completion resets the global variables first so we do the same
  (advice-add #'dabbrev-capf :before #'dabbrev--reset-global-variables)
  (add-hook 'completion-at-point-functions #'dabbrev-capf 100)
#+end_src

** xref completion settings
luckily this is built in lol
#+begin_src elisp
  (setq xref-search-program 'ripgrep)
  (setq xref-show-xrefs-function #'xref-show-definitions-completing-read)
  (setq xref-show-definitions-function #'xref-show-definitions-completing-read)

  (use-package xref :defer t
    :config
    (setq my/xref-vi-state-modify-map
          (make-composed-keymap
           nil
           (make-composed-keymap
            (list my/viper-vi-basic-motion-keymap
                  my/viper-vi-motion-g-keymap
                  my/viper-vi-motion-leader-keymap)
            xref--xref-buffer-mode-map)))
    (viper-modify-major-mode 'xref--xref-buffer-mode 'vi-state my/xref-vi-state-modify-map))
#+end_src

** in buffer completion
from:
https://www.reddit.com/r/emacs/comments/zl6amy/completionatpoint_using_completingread_icomplete/

Ctrl-J to force completion and exit

This is mostly just a simpler version of consult and only concerned with completion at point basically
https://www.gnu.org/software/emacs/manual/html_node/elisp/Programmed-Completion.html
https://www.gnu.org/software/emacs/manual/html_node/elisp/Programmed-Completion.html

bunch of stuff here to basically call the function version of /collection/ inside the current buffer
no idea how necessary that is
#+begin_src elisp
  (setq enable-recursive-minibuffers t)
  (defun completing-read-in-region (start end collection &optional predicate)
    "Prompt for completion of region in the minibuffer if non-unique.
        Use as a value for `completion-in-region-function'."
    (let* ((initial (buffer-substring-no-properties start end))
           (limit (car (completion-boundaries initial collection predicate "")))
           (all (completion-all-completions initial collection predicate (length initial)))
           ;; when the completion candidate list a single one, for some reason completing-read
           ;; will delete a bunch of lines.
           ;; to couteract this, we basically undo an atomic change and set the completion variable
           (completion (cond
                        ((atom all) nil)
                        ((and (consp all) (atom (cdr all)))
                         (concat (substring initial 0 limit) (car all)))
                        (t
                         (setq completion 
                               (catch 'done
                                 (atomic-change-group 
                                   (let ((completion
                                          (completing-read "Completion: " collection predicate nil initial)))
                                     (throw 'done completion)))))))))
    (cond (completion (completion--replace start end completion) t)
          (t (message "No completion") nil))))
  (setq completion-in-region-function #'completing-read-in-region)
#+end_src

** better tab completion
https://emacs.stackexchange.com/questions/8261/how-to-determine-if-the-current-character-is-a-letter
simple dwim heuristic to check if the char before the cursor is a char which means
we probably want to complete a symbol

Po is for "."
#+begin_src elisp
  (advice-add 'indent-for-tab-command
              :after (lambda (&optional arg)
                       (when (memq (get-char-code-property (char-before) 'general-category)
                                     '(Po Ll Lu Lo Lt Lm Mn Mc Me Nl))
                         (complete-symbol arg))))
#+end_src

* development
** set environment vars at path
this might be nice if we need to set env vars without direnv

idea is to maybe pass some shell command to cd into a folder
and source some.envrc, then using that same shell, just copy all the environment vars from there using =setenv=
#+begin_src elisp
  (defun copy-env-vars-from-shell ()
    (interactive)
    (mapc (lambda (env-var-string)
            (let* ((split (split-string env-var-string "="))
                   (name (cl-first split))
                   (val (cl-second split)))
              (setenv name val)
              (when (string-equal "PATH" name)
                (setq exec-path (append (parse-colon-path val) (list exec-directory)))
                ;; eshell path
                (setq-default eshell-path-env val)
                (when (fboundp 'eshell-set-path) (eshell-set-path val))
                )))
          (split-string (shell-command-to-string "bash --login -c printenv"))))
#+end_src

** tramp environment variables
#+begin_src elisp
  (defun get-docker-env-vars ()
    "Gets the environment variables set by ENV in dockerfile by looking at /proc/1/environ.
  Meant for eshell in mind."
    (interactive)
    (mapc (lambda (env-var-string)
            (let* ((split (split-string env-var-string "="))
                   (name (cl-first split))
                   (val (cl-second split)))
              (unless (string-equal "TERM" name)
                (if (string-equal "PATH" name)
                    (progn
                      ;; eshell path
                      (setq eshell-path-env val)
                      (when (fboundp 'eshell-set-path) (eshell-set-path val)))
                  (setenv name val)))))
          (split-string (shell-command-to-string "tr \'\\0\' \'\\n\' < /proc/1/environ") "\n")))

  (use-package tramp :defer t
    :config
    (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
#+end_src

** qol
#+begin_src elisp
  (add-hook 'prog-mode-hook #'flymake-mode)
  (setq treesit-font-lock-level 4)
  (setq-default indent-tabs-mode nil)
  (which-function-mode)
  (add-hook 'prog-mode-hook
            (lambda ()
              (unless (eq major-mode 'web-mode)
                (electric-pair-local-mode))))
#+end_src

** golang
#+begin_src elisp
  (add-to-list 'auto-mode-alist '("\\.go\\'" . go-ts-mode))
  (add-hook 'go-ts-mode-hook #'eglot-ensure)

  (defun copy-go-env-vars-from-shell ()
    (interactive)
    (copy-env-vars-from-shell)
    (mapc (lambda (env-var-string)
            (let* ((split (split-string env-var-string "="))
                   (name (cl-first split))
                   (val (cl-second split)))
              (when (and name val (not (string-empty-p name)) (not (string-empty-p val)))
                (setenv name (string-trim val "[ '\"]" "[ '\"]")))))
          (split-string (shell-command-to-string "bash --login -c \"go env\"") "\n"))
    (call-interactively 'eglot-reconnect))
#+end_src

** javascript/typescript

for typescript, when installing interactively, need to make sure that for the subdirectory where
parser.c lives, we input typescript/src

some weird issue with typescript treesitter v0.20.4, would avoid that branch until its fixed <2024-02-08 Thu>
#+begin_src elisp
  (use-package js :defer t
    :config
    (setq js-indent-level tab-width)
    (add-hook 'js-mode #'eglot-ensure))
  (use-package typescript-ts-mode :defer t
    :config
    (setq typescript-ts-mode-indent-offset tab-width))

  (add-to-list 'auto-mode-alist '("\\.ts\\'" . typescript-ts-mode))
#+end_src

** elisp highlighting
:PROPERTIES:
:VISIBILITY: folded
:END:

stole most of this from doom
https://github.com/doomemacs/doomemacs/blob/03d692f129633e3bf0bd100d91b3ebf3f77db6d1/modules/lang/emacs-lisp/autoload.el#L346-L381

#+begin_src elisp
  (use-package elisp-mode :defer t
    :config
    (require 'advice) ;; for ad-get-orig-definition

    (defun +emacs-lisp-highlight-vars-and-faces (end)
      "Match defined variables and functions.

    Functions are differentiated into special forms, built-in functions and
    library/userland functions"
      (catch 'matcher
        (while (re-search-forward "\\(?:\\sw\\|\\s_\\)+" end t)
          (let ((ppss (save-excursion (syntax-ppss))))
            (cond ((nth 3 ppss)  ; strings
                   (search-forward "\"" end t))
                  ((nth 4 ppss)  ; comments
                   (forward-line +1))
                  ((let ((symbol (intern-soft (match-string-no-properties 0))))
                     (and (cond ((null symbol) nil)
                                ((eq symbol t) nil)
                                ((keywordp symbol) nil)
                                ((special-variable-p symbol)
                                 (setq +emacs-lisp--face 'font-lock-variable-name-face))
                                ((and (fboundp symbol)
                                      (eq (char-before (match-beginning 0)) ?\()
                                      (not (memq (char-before (1- (match-beginning 0)))
                                                 (list ?\' ?\`))))
                                 (let ((unaliased (indirect-function symbol)))
                                   (unless (or (macrop unaliased)
                                               (special-form-p unaliased))
                                     (let (unadvised)
                                       (while (not (eq (setq unadvised (ad-get-orig-definition unaliased))
                                                       (setq unaliased (indirect-function unadvised)))))
                                       unaliased)
                                     (setq +emacs-lisp--face
                                           (if (subrp unaliased)
                                               'font-lock-constant-face
                                             'font-lock-function-name-face))))))
                          (throw 'matcher t)))))))
        nil))

    (font-lock-add-keywords 'emacs-lisp-mode `((+emacs-lisp-highlight-vars-and-faces . +emacs-lisp--face)) 'append))
#+end_src
           
** eshell
#+begin_src elisp
  (defun my/eshell-send-cmd-async ()
    (interactive)
    (let ((cmd (string-trim (buffer-substring-no-properties eshell-last-output-end (progn (end-of-line) (point))))))
      (unless (eshell-head-process)
        (delete-region eshell-last-output-end (point))
        (insert (format "async-shell-command \"%s\"" cmd)))
      )
    )

  (use-package eshell :defer t
    :config
    (add-to-list 'eshell-modules-list 'eshell-tramp)
    (setq my/eshell-vi-state-modify-map (make-sparse-keymap))
    (setq my/eshell-insert-state-modify-map (make-sparse-keymap))

    (define-key my/eshell-vi-state-modify-map (kbd "C-<return>") #'my/eshell-send-cmd-async)
    (define-key my/eshell-vi-state-modify-map " ma" #'my/eshell-send-cmd-async)
    (define-key my/eshell-insert-state-modify-map (kbd "C-<return>") #'my/eshell-send-cmd-async)

    (defun slurp (f)
      (with-temp-buffer
        (insert-file-contents f)
        (buffer-substring-no-properties (point-min) (point-max))))

    (define-key my/eshell-insert-state-modify-map (kbd "C-r")
                (lambda ()
                  (interactive)
                  (let ((selected (completing-read "History: "
                                                   (cl-remove-if-not
                                                    (lambda (elem)
                                                      (text-properties-at 0 elem))
                                                    (ring-elements eshell-history-ring)))))
                    (when selected 
                      (end-of-line)
                      (eshell-kill-input)
                      (insert selected)))))
    (viper-modify-major-mode 'eshell-mode 'vi-state my/eshell-vi-state-modify-map)
    (viper-modify-major-mode 'eshell-mode 'insert-state my/eshell-insert-state-modify-map)
    )
#+end_src

** shell mode
#+begin_src elisp
  (use-package shell :defer t
    :config
    (setq my/shell-insert-state-modify-map (make-sparse-keymap))

    (define-key my/shell-insert-state-modify-map (kbd "<up>") #'comint-previous-input)
    (define-key my/shell-insert-state-modify-map (kbd "<down>") #'comint-next-input)
    (define-key my/shell-insert-state-modify-map (kbd "C-r")
                (lambda ()
                  (interactive)
                  (let ((selected (completing-read "History: "
                                                   (cl-remove-if-not
                                                    (lambda (elem)
                                                      (text-properties-at 0 elem))
                                                    (ring-elements comint-input-ring)))))
                    (when selected
                      (end-of-line)
                      (comint-kill-input)
                      (insert selected)))))
    (viper-modify-major-mode 'shell-mode 'insert-state my/shell-insert-state-modify-map))
#+end_src

** eglot booster
:PROPERTIES:
:VISIBILITY: folded
:END:

https://gist.github.com/jdtsmith/d936801a4d7fd981bedf2e59dacd675e
#+begin_src elisp
  (use-package eglot :defer t
    :config
    (require 'eglot)
    (require 'jsonrpc)
    (eval-when-compile (require 'cl-lib))

    (defun eglot-booster-plain-command (com)
      "Test if command COM is a plain eglot server command."
      (and (consp com)
           (not (integerp (cadr com)))
           (not (seq-intersection '(:initializationOptions :autoport) com))))

    (defun eglot-booster ()
      "Boost plain eglot server programs with emacs-lsp-booster.
    The emacs-lsp-booster program must be compiled and available on
    variable `exec-path'.  Only local stdin/out based lsp servers can
    be boosted."
      (interactive)
      (unless (executable-find "emacs-lsp-booster")
        (user-error "The emacs-lsp-booster program is not installed"))
      (if (get 'eglot-server-programs 'lsp-booster-p)
          (message "eglot-server-programs already boosted.")
        (let ((cnt 0)
              (orig-read (symbol-function 'jsonrpc--json-read)))
          (dolist (entry eglot-server-programs)
            (cond
             ((functionp (cdr entry))
              (cl-incf cnt)
              (let ((fun (cdr entry)))
                (setcdr entry (lambda (&rest r) ; wrap function
                                (let ((res (apply fun r)))
                                  (if (eglot-booster-plain-command res)
                                      (cons "emacs-lsp-booster" res)
                                    res))))))
             ((eglot-booster-plain-command (cdr entry))
              (cl-incf cnt)
              (setcdr entry (cons "emacs-lsp-booster" (cdr entry))))))
          (defalias 'jsonrpc--json-read
            (lambda ()
              (or (and (= (following-char) ?#)
                       (let ((bytecode (read (current-buffer))))
                         (when (byte-code-function-p bytecode)
                           (funcall bytecode))))
                  (funcall orig-read))))
          (message "Boosted %d eglot-server-programs" cnt))
        (put 'eglot-server-programs 'lsp-booster-p t)))
    ;; need to run it on eglot load
    (eglot-booster))
#+end_src


* Font and theme
current system uses iosevka custom nerd font
#+begin_src elisp
  (when (member "IosevkaCustom Nerd Font Propo" (font-family-list))
    (set-face-attribute 'default nil :font "IosevkaCustom Nerd Font Propo" :height 130))
  (when (member "Iosevka Etoile" (font-family-list))
    (set-face-attribute 'variable-pitch nil :font "Iosevka Etoile" :height 130))
#+end_src

There is a weird thing where vc-diff won't highlight some stuff since the modus org src block fontification takes over
instead
** modus
#+begin_src elisp
  (setq modus-themes-headings
        '((1 . (rainbow overline background variable-pitch 1.25))
          (2 . (rainbow background variable-pitch 1.15))
          (3 . (rainbow bold variable-pitch 1.1))
          (t . (semilight variable-pitch 1.05))))


  (setq modus-themes-bold-constructs t)
  (setq modus-themes-italic-constructs t)
  (setq modus-themes-org-blocks 'gray-background)
  (load-theme 'modus-operandi)
  (use-package vc :defer t
    :config
    ;; for some reason modus gets rid of diff-header
    (set-face-attribute 'diff-header nil :background "gray80"))
#+end_src

* Tab bar
basically minimal projectile and persp
#+begin_src elisp
  (defun find-git-dir (dir)
   "Search up the directory tree looking for a .git folder."
   (cond
    ((eq major-mode 'dired-mode) "Dired")
    ((not dir) "process")
    ((string= dir "/") "no-git")
    (t (vc-root-dir))))

  (defun git-tabbar-buffer-groups ()
    "Groups tabs in tabbar-mode by the git repository they are in."
    (list (find-git-dir (buffer-file-name (current-buffer)))))
#+end_src


* eww
lookup with eww first, then use =eww-browse-with-external-browser= if we need to browse in a normal browser
#+begin_src elisp
  (setq browse-url-browser-function 'eww-browse-url)
  (add-hook 'eww-after-render-hook 'eww-readable)
#+end_src

* Viper
:PROPERTIES:
:header-args: :tangle viper :results silent
:END:
viper is the only built in thing that handles /some/ of the Doom/Vim stuff that I want (since it emulates Vi and not Vim)

** forward word separator
#+begin_src elisp :tangle no
  (defconst viper-SEP-char-class " -_"
    "String of syntax classes for Vi separators.
    Usually contains ` ', linefeed, TAB or formfeed.")

  (defun viper-forward-word-kernel (val)
    (while (> val 0)
      (cond ((viper-looking-at-alpha)
             (viper-skip-alpha-forward) ;; before had "_" as arg
             (viper-skip-separators t))
            ((viper-looking-at-separator)
             (viper-skip-separators t))
            ((not (viper-looking-at-alphasep))
             (viper-skip-nonalphasep-forward)
             (viper-skip-separators t)))
      (setq val (1- val))))
#+end_src

** vi state stuff
hacky global var to have a "global" viper state
is this better than the default behavior?
Maybe.. maybe not but now this should enable viper mode even on major modes not specified by viper itself
*** global viper state
TODO: add a hook on buffer creation to see if viper is enabled or not, and if not enable it, then switch to the global state?
#+begin_src elisp
  (setq my/global-viper-state 'vi)
  (defun set-global-viper-state (arg)
    (cond ((eq my/global-viper-state 'vi) (viper-change-state-to-vi))
          ((eq my/global-viper-state 'emacs) (viper-change-state-to-emacs))
          ((eq my/global-viper-state 'insert) (viper-change-state-to-insert))
          (t (viper-change-state-to-vi))
    ))

  (add-hook 'viper-vi-state-hook (lambda () (setq my/global-viper-state 'vi)))
  (add-hook 'viper-emacs-state-hook (lambda () (setq my/global-viper-state 'emacs)))
  (add-hook 'viper-insert-state-hook (lambda () (setq my/global-viper-state 'insert)))
  (add-to-list 'window-state-change-functions #'set-global-viper-state)
#+end_src

**** want better normal state bindings in the "emacs state" buffers
we just set all of these to nil since we have this pseudo global state
plus our workaround of just unbinding q for quit window commands

#+begin_src elisp
  (setq viper-emacs-state-mode-list nil)
  (setq viper-insert-state-mode-list nil)
#+end_src

*** hl line for diff modes, viper viper insert delets to prev line
:PROPERTIES:
:VISIBILITY: folded
:END:
stole the terminal code for cursor from here https://github.com/syl20bnr/spacemacs/issues/7112#issuecomment-389855491
works on iterm2 at least, 0 for box, 6 for bar cursor
#+begin_src elisp
  (setq viper-inhibit-startup-message 't)
  (setq viper-expert-level '5)

  (add-hook 'viper-insert-state-hook (lambda ()
                                       (global-hl-line-mode -1)
                                       (when (not (display-graphic-p)) (send-string-to-terminal "\033[6 q"))
                                       (setq viper-ex-style-editing nil)))

  (add-hook 'viper-minibuffer-exit-hook (lambda () (global-hl-line-mode) (when (not (display-graphic-p)) (send-string-to-terminal "\033[0 q"))))

  (add-hook 'viper-vi-state-hook (lambda ()
                                   (global-hl-line-mode)
                                   (set-face-attribute 'hl-line nil :underline nil)
                                   (set-face-attribute 'hl-line nil :box nil)
                                   (when (not (display-graphic-p)) (send-string-to-terminal "\033[0 q"))))
  (add-hook 'viper-emacs-state-hook (lambda ()
                                      (global-hl-line-mode)
                                      (if (display-graphic-p)
                                          (set-face-attribute 'hl-line nil :box t)
                                        (set-face-attribute 'hl-line nil :underline t))
                                      (when (not (display-graphic-p)) (send-string-to-terminal "\033[0 q"))))

  (add-hook 'minibuffer-mode-hook #'viper-change-state-to-emacs)
  (add-hook 'minibuffer-exit-hook #'viper-change-state-to-vi)
  (setq viper-insert-state-cursor-color nil)
#+end_src

** minibuffer mappings
#+begin_src elisp
  ;; This is so backspace/delete goes backward directories instead of just deleting characters
  (setq my/minibuffer-modify-map (make-sparse-keymap))
  (define-key my/minibuffer-modify-map (kbd "<backspace>") #'icomplete-fido-backward-updir)
  (define-key my/minibuffer-modify-map (kbd "<DEL>") #'icomplete-fido-backward-updir)
  (viper-modify-major-mode 'minibuffer-mode 'insert-state my/minibuffer-modify-map)
  (viper-modify-major-mode 'minibuffer-mode 'emacs-state my/minibuffer-modify-map)
#+end_src

** help commands
qol to use c-h for help commands, and something for us to type faster
#+begin_src elisp
  (setq viper-want-ctl-h-help 't)
  (setq viper-fast-keyseq-timeout 100)
#+end_src

** better escape handling
better ESC key handling to exit visual mode and close mini buffer
#+begin_src elisp
  ;; (advice-mapc `(lambda (fun props) (advice-remove 'viper-intercept-ESC-key fun)) 'viper-intercept-ESC-key)
  (advice-add 'viper-intercept-ESC-key :after #'deactivate-mark)
  (advice-add 'viper-intercept-ESC-key :after (lambda () (ignore-errors (abort-minibuffers))))
  (advice-add 'viper-intercept-ESC-key :after (lambda () (ignore-errors (cua-clear-rectangle-mark))))
  (advice-add 'viper-intercept-ESC-key :after (lambda () (lazy-highlight-cleanup t)))
  (advice-add 'viper-intercept-ESC-key :after (lambda ()
                                                (dolist (hist viper-search-history)
                                                  (hi-lock-unface-buffer hist))))
#+end_src

** pop mark navigation
#+begin_src elisp
  (setq my/mark-ring '())
  (setq my/mark-ring-max-size 16)
  (setq my/mark-ring-current-pos 0)
  (setq my/moving-in-progress nil)

  ;; only for file visiting marks
  (defun my/push-mark-advice (&optional _ _ _)
    (unless my/moving-in-progress
      (let* ((new-mark (copy-marker (mark-marker)))
             (buf (marker-buffer new-mark)))
        (when (buffer-file-name buf)
          ;; transpose on mark ring pos
          (setq my/mark-ring (append (cl-subseq my/mark-ring my/mark-ring-current-pos)
                                     (cl-subseq my/mark-ring 0 my/mark-ring-current-pos)))
          ;; existing mark will be added after
          (setq my/mark-ring
                (seq-filter (lambda (m)
                              (and m (marker-buffer m) (marker-position m)
                                   (not (and (= (marker-position m) (marker-position new-mark))
                                             (eq (marker-buffer m) buf)))))
                            my/mark-ring))

          (when (gt= (length my/mark-ring) my/mark-ring-max-size)
            (setq my/mark-ring (butlast my/mark-ring)))

          (cl-pushnew new-mark my/mark-ring)
          (setq my/mark-ring-current-pos 0)))))
  (advice-add 'push-mark :after #'my/push-mark-advice)

  (defun my/move-to-mark (m)
    (when m
      (let* ((buf (marker-buffer m))
             (position (marker-position m))
             (my/moving-in-progress t))
        (if buf
            (progn
              (set-buffer buf)
              ;; same as pop-global-mark
              (or (and (gt= position (point-min))
                       (lt= position (point-max)))
                  (if widen-automatically
                      (widen)
                    (error "mark position is outside accessible part of buffer %s"
                           (buffer-name buffer))))
              (goto-char position)
              (switch-to-buffer buf))
          (message "No buf for marker %s." m)))))

  (defun my/mark-ring-forward ()
    (interactive)
    ;; when we try to go "back" we want to basically drop a marker where we were
    ;; so we can go "forward" to it later
    (when (and (eql my/mark-ring-current-pos 0)
               (not (and
                     (eql (marker-buffer (elt my/mark-ring 0)) (current-buffer))
                     (eql (marker-position (elt my/mark-ring 0)) (point)))))
      (push-mark))

    (when (and (eql
                (marker-buffer (elt my/mark-ring my/mark-ring-current-pos))
                (current-buffer))
               (eql
                (marker-position (elt my/mark-ring my/mark-ring-current-pos))
                (point)))
      (unless (eql my/mark-ring-current-pos (length my/mark-ring))
        (cl-incf my/mark-ring-current-pos)))
    (my/move-to-mark (elt my/mark-ring my/mark-ring-current-pos)))

  (defun my/mark-ring-backward ()
    (interactive)
    (when (gt my/mark-ring-current-pos 0)
      (cl-decf my/mark-ring-current-pos)
      (my/move-to-mark (elt my/mark-ring my/mark-ring-current-pos))))

  ;; some weird hack to distinguish tab and C-i in gui, broken in terminal
  ;; we only want to do this in vi state so we get tab completion and stuff in insert/emacs state for tty
  (add-hook 'viper-vi-state-hook (lambda () (define-key input-decode-map "\C-i" [C-i])))
  (add-hook 'viper-emacs-state-hook (lambda () (define-key input-decode-map "\C-i" nil)))
  (add-hook 'viper-insert-state-hook (lambda () (define-key input-decode-map "\C-i" nil)))
  ;; this is basically visual state hook
  (add-hook 'activate-mark-hook (lambda () (define-key input-decode-map "\C-i" nil)))
  (add-hook 'deactivate-mark-hook (lambda () (define-key input-decode-map "\C-i" [C-i])))

  (define-key viper-vi-basic-map [C-i] #'my/mark-ring-backward)
  (define-key viper-vi-basic-map "\t" nil)
  (define-key viper-vi-basic-map "\C-o" #'my/mark-ring-forward)
#+end_src

** respect visual lines cursor movement
:PROPERTIES:
:VISIBILITY: folded
:END:

basically redefining the viper commands to respect visual line mode
#+begin_src elisp
  (defun viper-previous-line (arg)
    "Go to previous line."
    (interactive "P")
    (let ((val (viper-p-val arg))
          (com (viper-getCom arg)))
      (if com (viper-move-marker-locally 'viper-com-point (point)))
      ;; do not use forward-line! need to keep column
      ;; REDEFINE: remove setting line-move-visual to nil
      (with-no-warnings (previous-line val))
      ;; END OF REDEFINE
      (if viper-ex-style-motion
          (if (and (eolp) (not (bolp))) (backward-char 1)))
      (setq this-command 'previous-line)
      (if com (viper-execute-com 'viper-previous-line val com))))

  (defun viper-next-line (arg)
    "Go to next line."
    (interactive "P")
    (let ((val (viper-p-val arg))
          (com (viper-getCom arg)))
      (if com (viper-move-marker-locally 'viper-com-point (point)))
      ;; do not use forward-line! need to keep column
      ;; REDEFINE: remove setting line-move-visual to nil
      (with-no-warnings (next-line val))
      ;; END OF REDEFINE
      (if viper-ex-style-motion
          (if (and (eolp) (not (bolp))) (backward-char 1)))
      (setq this-command 'next-line)
      (if com (viper-execute-com 'viper-next-line val com))))


  (advice-mapc `(lambda (fun props) (advice-remove 'viper-goto-eol fun)) 'viper-goto-eol)
  (advice-add 'viper-goto-eol :around
              (lambda (orig-fun &rest args)
                (if visual-line-mode
                    (cl-letf (((symbol-function 'end-of-line) 'end-of-visual-line))
                      (apply orig-fun args))
                  (apply orig-fun args))))

  (defun check-if-on-visually-split-line ()
    (let ((first-logical-end
           (save-excursion (beginning-of-line) (end-of-visual-line) (point)))
          (current-end (save-excursion (end-of-visual-line) (point))))
      (> current-end first-logical-end)))

  (defun viper-bol-and-skip-white (arg)
    "Beginning of line at first non-white character."
    (interactive "P")
    (let ((val (viper-p-val arg))
          (com (viper-getcom arg)))
      (if com (viper-move-marker-locally 'viper-com-point (point)))
      (if visual-line-mode
          (progn 
            (if (and (check-if-on-visually-split-line))
                (if (= val 1)
                    (beginning-of-visual-line val)
                  (beginning-of-visual-line (1+ val)))
              (if (= val 1)
                  (backward-to-indentation (1- val))
                (beginning-of-visual-line (1+ val)))))
        (progn
          (forward-to-indentation (1- val))
          (if com (viper-execute-com 'viper-bol-and-skip-white val com))))))
#+end_src

** forward "enter" and "q" in vi state
good enough solution without getting too complicated
we never really type these in normal mode anyways
and these are pretty useful in some buffers

default behavior of the enter key is pretty meh anyways
q is just bound to viper-nil as well

actually could have enter browse url if point is on a url
otherwise do the normal enter action

for forwarding, layering, or context-aware keybindings see this
https://stackoverflow.com/questions/16090517/elisp-conditionally-change-keybinding/22863701#22863701
https://endlessparentheses.com/define-context-aware-keys-in-emacs.html

#+begin_src elisp
  (define-key viper-vi-basic-map (kbd "RET")
              `(menu-item "" browse-url-at-point
                          :filter ,(lambda (cmd) (if (thing-at-point-url-at-point) cmd))))
  (define-key viper-vi-basic-map "q" nil)
#+end_src

** pseudo visual mode
:PROPERTIES:
:VISIBILITY: folded
:END:

*** hacky advice for next/previous line to emulate visual mode
basically a bunch of mark manipualtion essentially.

a lot of the problem is just around making sure that starting line is always marked, similar to vim
#+begin_src elisp
  (setq selected-start-line -1)
  (add-hook 'activate-mark-hook (lambda () (setq selected-start-line (line-number-at-pos))))
  ;; (advice-mapc `(lambda (fun props) (advice-remove 'next-line fun)) 'next-line)
  (advice-add 'next-line :around
              (lambda (orig-fun &rest args)
                (interactive)
                ;; because now we're not getting the last newline
                (if (< (line-number-at-pos) selected-start-line)
                    (setq extra-line-after-yank t)
                  (setq extra-line-after-yank nil))

                (if my/line-selection-p
                    (cond
                     ((= (line-number-at-pos) selected-start-line)
                      (progn
                        (beginning-of-line)
                        (set-mark-command nil)
                        (end-of-line)
                        (apply orig-fun args)
                        (end-of-line)
                        ))
                     ((= (+ (line-number-at-pos) 1) selected-start-line)
                      (progn
                        (apply orig-fun args)
                        (beginning-of-line)
                        (set-mark-command nil)
                        (end-of-line)))
                     ((< (line-number-at-pos) selected-start-line)
                      (apply orig-fun args))
                     (t 
                      (progn
                        (apply orig-fun args)
                        (end-of-line)))
                     )
                  (apply orig-fun args))))

  (advice-add 'previous-line :around
              (lambda (orig-fun &rest args)
                (interactive)
                (if (< (line-number-at-pos) selected-start-line)
                    (setq extra-line-after-yank t)
                  (setq extra-line-after-yank nil))
                (if my/line-selection-p
                    (cond 
                     ((= (line-number-at-pos) selected-start-line)
                      (progn
                        (end-of-line)
                        (set-mark-command nil)
                        (beginning-of-line)
                        (apply orig-fun args)
                        (beginning-of-line)))
                     ((> (line-number-at-pos) selected-start-line)
                      (apply orig-fun args)
                      (end-of-line))		   
                     ((= (- (line-number-at-pos) 1) selected-start-line)
                      (progn 
                      (apply orig-fun args)
                      (end-of-line)
                      (set-mark-command nil)
                      (beginning-of-line)))
                     (t
                      (progn
                        (apply orig-fun args)
                        (beginning-of-line))))
                  (apply orig-fun args))))
  ;; (advice-mapc `(lambda (fun props) (advice-remove 'previous-line fun)) 'previous-line)
#+end_src

*** pseudo visual line
have a variable for us to know if we're in the a pseudo line selection or normal selection
#+begin_src elisp  
  (setq my/line-selection-p nil)
  (setq my/lines-selected 0)

  (add-hook 'deactivate-mark-hook (lambda () (setq my/line-selection-p nil)))

  (defun my/select-lines (arg)
    "go to beginning of line and select rectangle mark and also set line selection flag"
    (interactive "p")
    (setq my/line-selection-p t)
    (beginning-of-line)
    (set-mark-command nil)
    (end-of-line))

  (defun my/set-mark-command (arg)
    "set mark, and also unset line selection flag"
    (interactive "P")
    (setq my/line-selection-p nil)
    (set-mark-command arg))

  (defun my/visual-block (arg)
    "set rectangle mark, and also unset line selection flag"
    (interactive "P")
    (setq my/line-selection-p nil)
    (rectangle-mark-mode arg))
#+end_src

v or V will set that line selection var accordingly
deactivate mark on esc
#+begin_src elisp
  (define-key viper-vi-basic-map "v" nil)
  (define-key viper-vi-basic-map "v" #'my/set-mark-command)
  (define-key viper-vi-basic-map "V" nil)
  (define-key viper-vi-basic-map "V" #'my/select-lines)
  (define-key viper-vi-basic-map "\C-v" #'my/visual-block)
#+end_src

*** viper-ex to automatically use region if active
#+begin_src elisp
  ;;(advice-mapc `(lambda (fun props) (advice-remove 'viper-ex fun)) 'viper-ex)
  (advice-add 'viper-ex :around
              (lambda (orig-fun &rest args)
                (let ((current-prefix-arg t))
                  (if (use-region-p) (apply orig-fun current-prefix-arg args)
                    (apply orig-fun args)))))
#+end_src

*** join lines on selected region
if the region exists then we jump to the beginning of the region and merge the number of lines selected
#+begin_src elisp
  ;; (advice-mapc `(lambda (fun props) (advice-remove 'viper-join-lines fun)) 'viper-join-lines)
  (advice-add 'viper-join-lines :around
              (lambda (orig-fun arg &rest args)
                (interactive "P")
                (if (use-region-p)
                    (let* ((start (region-beginning))
                          (end (region-end))
                          (numlines (count-lines start end)))
                      (goto-char start)
                      (apply orig-fun `(,numlines)))
                  (apply orig-fun `(,arg)))))
#+end_src

*** hacky stuff to make yanking/killing work for our line visual selection
#+begin_src elisp
  (setq my/line-yank-p nil)
  (defun viper-delete-region-or-motion-command (arg)
    "convenience function for deleting a region, including rectangles"
    (interactive "P")
    (if (use-region-p)
        (let ((start (region-beginning)) (end (region-end)))
          (if rectangle-mark-mode
              (progn 
                (setq my/line-yank-p nil)
                ;; like vim, we want to include the current cursor char
                (kill-rectangle start (1+ end) arg))
            (progn
              ;; this hacky bit is because when we move backwards from point, we want to include the position we started the mark on like in vim
              ;; even though visually we won't see it, functionally it'll behave the same
              (if (> (point) (mark-marker))
                  (forward-char)
                (let ((m (mark-marker)))
                  (set-marker m (1+ m))))
              (if my/line-selection-p
                  (setq my/line-yank-p t)
                (setq my/line-yank-p nil))
              (kill-region start end t))))
      (viper-command-argument arg)))

  (defun viper-copy-region-or-motion-command (arg)
    "convenience function for yanking a region, including rectangles"
    (interactive "P")
    (if (use-region-p)
        (let ((start (region-beginning)) (end (region-end)))
          (if rectangle-mark-mode
              (progn 
                (setq my/line-yank-p nil)
                (copy-rectangle-as-kill start (1+ end)))
            (progn
              (if (> (point) (mark-marker))
                  (forward-char)
                (let ((m (mark-marker)))
                  (set-marker m (1+ m))))
              (if my/line-selection-p
                  (setq my/line-yank-p t)
                (setq my/line-yank-p nil))
              (copy-region-as-kill start end t)
              (when (> (point) (mark-marker)) (backward-char)))
            ))
      (viper-command-argument arg)))

  (defun viper-paste-into-region (arg)
    "if region is active, delete region before pasting
  respects rectangle mode in a similar way to vim/doom"
    (interactive "P")
    (cond (my/line-yank-p
           (progn
             (if (use-region-p)
                 (delete-active-region)
               (viper-open-line nil))
             (viper-change-state-to-vi) ; cause viper-open-line takes us to insert
             (yank)

             ;; we want the newline at the end when the yanked text is multiline
             ;; but we want to remove the additional newline if the yanked text is
             ;; just a single line
             (when (not (string-match ".*\n.+" (cl-first kill-ring)))
               (forward-line)
               (delete-char -1)
               (forward-line -1)
               (end-of-line))
             ))
          ((and (not killed-rectangle) (use-region-p))
           (progn
             (let ((start (region-beginning)))
               ;; vim pastes "after" the cursor, at least that's what I'm used to
               (forward-char)
               (delete-active-region)
               (yank))))
          (killed-rectangle
           (progn
             (forward-char)
             (yank-rectangle)
             (setq killed-rectangle nil)))
          ;; if we're on an empty line, we want to just yank without moving forward
          (t (unless (eq (point) (line-end-position)) (forward-char)) (yank arg))))

  (define-key viper-vi-basic-map "d" #'viper-delete-region-or-motion-command)
  (define-key viper-vi-basic-map "y" #'viper-copy-region-or-motion-command)
  (define-key viper-vi-basic-map "p" #'viper-paste-into-region)
  (define-key viper-vi-basic-map (kbd "s-v") #'viper-paste-into-region)
  (define-key viper-insert-basic-map (kbd "s-v") #'viper-paste-into-region)
  (define-key global-map (kbd "s-v") #'viper-paste-into-region)
#+end_src

** undo
thank god for undo-only but emacs > 28 only
need to remap isearch-backward since i wanna use C-r for redo
#+begin_src elisp
  (define-key viper-vi-basic-map "u" #'undo-only)
  (define-key viper-vi-basic-map (kbd "C-r") #'undo-redo)
  (define-key viper-vi-basic-map (kbd "C-M-r")  #'isearch-backward)
#+end_src

** "g" prefix commands
*** beginning of buffer
#+begin_src elisp
  (setq my/g-prefix-map (make-sparse-keymap))
  (define-key viper-vi-basic-map "g" my/g-prefix-map)
  (define-key my/g-prefix-map "g" (lambda () (interactive) (viper-goto-line 1)))
#+end_src

*** movement since we have visual lines
#+begin_src elisp
  (define-key my/g-prefix-map "k" #'viper-previous-line)
  (define-key my/g-prefix-map "j" #'viper-next-line)
#+end_src
*** tab bar movement
#+begin_src elisp
  (define-key my/g-prefix-map "t" #'tab-bar-switch-to-next-tab)
  (define-key my/g-prefix-map "T" #'tab-bar-switch-to-prev-tab)
#+end_src

*** cua mode for multiple cursors
#+begin_src elisp
  (define-key my/g-prefix-map "zz" #'cua-rectangle-mark-mode)
#+end_src

** pseudo "leader" prefix
:PROPERTIES:
:VISIBILITY: children
:END:

#+begin_src elisp
  (setq my/leader-prefix-map (make-sparse-keymap))
  (define-key viper-vi-basic-map " " my/leader-prefix-map)

  (define-key my/leader-prefix-map ","
              (lambda () (interactive) (project-switch-to-buffer (project--read-project-buffer))))
  (define-key my/leader-prefix-map "<" #'switch-to-buffer)

  (define-key my/leader-prefix-map "u" #'universal-argument)
  (define-key universal-argument-map " u" #'universal-argument-more)

  (define-key my/leader-prefix-map "F" #'project-find-file)
  (define-key my/leader-prefix-map "G" #'my/igrep)
  (define-key my/leader-prefix-map "X" #'org-capture)

  (define-key my/leader-prefix-map "x"
              (lambda () (interactive)
                (split-window-vertically)
                (windmove-down)
                (scratch-buffer)))
#+end_src

*** "open" prefix
#+begin_src elisp
  (define-key my/leader-prefix-map "oe" #'eshell)
  (define-key my/leader-prefix-map "os" #'shell)
#+end_src

*** "project" prefix
#+begin_src elisp
  (define-key my/leader-prefix-map "pp" #'project-switch-project)
  (define-key my/leader-prefix-map "pe" #'project-eshell)
  (define-key my/leader-prefix-map "ps" #'project-shell)
  (define-key my/leader-prefix-map "pd" #'project-forget-project)
  (define-key my/leader-prefix-map "px" #'flymake-show-project-diagnostics)
#+end_src

*** "code" prefix
#+begin_src elisp
  (defun my/flymake-diagnostics-at-point ()
    (interactive)
    (let ((diags (flymake-diagnostics (point))))
      (if (not (seq-empty-p diags))
          (message "%s"
                   (cl-reduce (lambda (acc d) (concat acc (flymake--diag-text d)))
                              (flymake-diagnostics (point))
                              :initial-value ""))
        (message "No diagnostics at point."))))

  (define-key my/leader-prefix-map "cx" #'my/flymake-diagnostics-at-point)
  (define-key my/leader-prefix-map "cX" #'flymake-show-buffer-diagnostics)
#+end_src

*** "help" prefix
#+begin_src elisp
  (define-key my/leader-prefix-map "hk" #'describe-key)
  (define-key my/leader-prefix-map "hf" #'describe-function)
  (define-key my/leader-prefix-map "hv" #'describe-variable)
  (define-key my/leader-prefix-map "hm" #'describe-mode)
  (define-key my/leader-prefix-map "ho" #'describe-symbol)
#+end_src

*** "buffer" prefix
#+begin_src elisp
  (define-key my/leader-prefix-map "br" #'revert-buffer)
  (define-key my/leader-prefix-map "bp" #'previous-buffer)
  (define-key my/leader-prefix-map "bn" #'next-buffer)
  (define-key my/leader-prefix-map "bi" #'ibuffer)
#+end_src

*** "tab" bar prefix
#+begin_src elisp
  (setq my/tab-prefix-map (make-sparse-keymap))
  (define-key my/leader-prefix-map "\t" my/tab-prefix-map)
  (define-key my/leader-prefix-map [C-i] my/tab-prefix-map) ;; so it works in terminal
  (define-key my/tab-prefix-map "n" #'tab-bar-new-tab)
  (define-key my/tab-prefix-map "d" #'tab-bar-close-tab)
  (define-key my/tab-prefix-map "r" #'tab-bar-rename-tab)
#+end_src 

*** "search" prefix
#+begin_src elisp
  (define-key my/leader-prefix-map "ss" #'my/ioccur)
  ;; not sure why but we need to rescan the imenu for our igrep xref buffer
  (define-key my/leader-prefix-map "si"
              (lambda () (interactive)
                (imenu--menubar-select imenu--rescan-item)
                (call-interactively 'imenu)))
#+end_src

*** "notes" prefix (bookmarks)
in lieu of org-roam, use bookmarks
pretty handy tbh
**** simple project bookmarks
#+begin_src elisp
(setq bookmark-use-annotations t)

; note the call-interactively does pass the prefix args
(defun my/set-project-bookmark ()
  (interactive)
  (minibuffer-with-setup-hook
      (lambda ()
        (let ((prefix (concat (project-name (project-current)) ": ")))
          (when (project-name (project-current))
            (insert prefix))))
        (call-interactively 'bookmark-set))
)

(defun my/jump-to-project-bookmark ()
  (interactive)
  (minibuffer-with-setup-hook
      (lambda ()
        (let ((prefix (concat (project-name (project-current)) ": ")))
          (when (project-name (project-current))
            (insert prefix))))
        (call-interactively 'bookmark-jump))
)
#+end_src

#+begin_src elisp
  (setq bookmark-save-flag 1)
  (setq bookmark-use-annotations t)
  (setq bookmark-automatically-show-annotations nil)

  (define-key my/leader-prefix-map "nrf" #'my/jump-to-project-bookmark)
  (define-key my/leader-prefix-map "nrl" #'list-bookmarks)
  (define-key my/leader-prefix-map "nri" #'bookmark-set)
  (define-key my/leader-prefix-map "nrn" #'bookmark-set)
  (define-key my/leader-prefix-map "nrd" #'bookmark-delete)
  (define-key my/leader-prefix-map "bmm" #'my/set-project-bookmark)
  (define-key my/leader-prefix-map "bmj" #'my/jump-to-project-bookmark)
#+end_src

*** pseudo "files" "f" prefix
#+begin_src elisp
    (define-key my/leader-prefix-map "ff" #'find-file)
#+end_src

** viper motion keymap
:PROPERTIES:
:VISIBILITY: folded
:END:

There's some weird thing with make-composed-keymap where for some reason the original keymaps might be modified if we use define-key.
Found a solution here: https://emacs.stackexchange.com/questions/3963/use-two-major-mode-maps-in-the-same-buffer
which says to just wrap make-composed-keymap around the original make-composed-keymap

TBD for use in specific major mode keymaps so we at least keep motions
in special modes
#+begin_src elisp
  (setq my/viper-vi-basic-motion-keymap (make-sparse-keymap))
  (define-key my/viper-vi-basic-motion-keymap "h" #'viper-backward-char)
  (define-key my/viper-vi-basic-motion-keymap "l" #'viper-forward-char)
  (define-key my/viper-vi-basic-motion-keymap "j" #'next-line)
  (define-key my/viper-vi-basic-motion-keymap "k" #'previous-line)
  (define-key my/viper-vi-basic-motion-keymap "w" #'viper-forward-word)
  (define-key my/viper-vi-basic-motion-keymap "b" #'viper-backward-word)
  (define-key my/viper-vi-basic-motion-keymap "e" #'viper-end-of-word)
  (define-key my/viper-vi-basic-motion-keymap "v" #'my/set-mark-command)
  (define-key my/viper-vi-basic-motion-keymap "V" #'my/select-lines)
  (define-key my/viper-vi-basic-motion-keymap (kbd "C-v") #'my/visual-block)
  (define-key my/viper-vi-basic-motion-keymap "y" #'viper-copy-region-or-motion-command)
  (define-key my/viper-vi-basic-motion-keymap "^" #'viper-bol-and-skip-white)
  (define-key my/viper-vi-basic-motion-keymap "$" #'viper-goto-eol)
  (define-key my/viper-vi-basic-motion-keymap (kbd "C-d") #'viper-scroll-up)
  (define-key my/viper-vi-basic-motion-keymap "\C-w" my-window-map)
#+end_src

I might be able to live without these ones so they can be overriden
#+begin_src elisp
  (setq my/viper-vi-extra-motion-keymap my/viper-vi-basic-motion-keymap)
  (define-key my/viper-vi-extra-motion-keymap "W" #'viper-forward-Word)
  (define-key my/viper-vi-extra-motion-keymap "B" #'viper-backward-Word)
  (define-key my/viper-vi-extra-motion-keymap "E" #'viper-end-of-Word)

  (define-key my/viper-vi-extra-motion-keymap "f" #'viper-find-char-forward)
  (define-key my/viper-vi-extra-motion-keymap "F" #'viper-find-char-backward)
  (define-key my/viper-vi-extra-motion-keymap "t" #'viper-goto-char-forward)
  (define-key my/viper-vi-extra-motion-keymap "T" #'viper-goto-char-backward)
 
#+end_src

"g" commands like beginning of buffer and change tab
#+begin_src elisp
  (setq my/viper-vi-motion-g-keymap (make-sparse-keymap))
  (define-key my/viper-vi-motion-g-keymap "g" my/g-prefix-map)
  (define-key my/viper-vi-motion-g-keymap "G" #'viper-goto-line)
#+end_src

leader commands
#+begin_src elisp
  (setq my/viper-vi-motion-leader-keymap (make-sparse-keymap))
  (define-key my/viper-vi-motion-leader-keymap " " my/leader-prefix-map)
#+end_src

** eglot/xref
#+begin_src elisp
  (define-key my/leader-prefix-map "cd" #'xref-find-definitions)
  (define-key viper-vi-basic-map "gd" #'xref-find-definitions)
  (define-key viper-vi-basic-map "gI" #'eglot-find-implementation)

  (define-key my/leader-prefix-map "cD" #'xref-find-references)
  (define-key viper-vi-basic-map "gD" #'xref-find-references)
#+end_src

#+begin_src elisp
  (define-key my/leader-prefix-map "cr" #'eglot-rename)
  (define-key my/leader-prefix-map "cf" #'eglot-format-buffer)
  (define-key my/leader-prefix-map "ca" #'eglot-code-actions)
#+end_src

** development
#+begin_src elisp
  (define-key viper-vi-basic-map "K" #'eldoc)
  (define-key prog-mode-map (kbd "C-<return>") #'default-indent-new-line)
#+end_src

** window positioning commands
*** respect scroll margin
#+begin_src elisp
  (define-key viper-vi-basic-map "H"
              (lambda (arg) (interactive "P")
                (if arg (viper-window-top arg)
                  (viper-window-top (+ scroll-margin 1)))))
  (define-key viper-vi-basic-map "L"
              (lambda (arg) (interactive "P")
                (if arg (viper-window-bottom arg)
                  (viper-window-bottom (+ scroll-margin 1)))))
  (define-key viper-vi-basic-map "zz" #'recenter-top-bottom)
#+end_src

*** goto line not deactivating mark
#+begin_src elisp
  (advice-mapc `(lambda (fun props) (advice-remove 'viper-goto-line fun)) 'viper-goto-line)

  ;; if the region is active already, we don't want to move mark or else it behaves strangely with out selection
  (defun my/advise-viper-goto-line (orig-fun &rest args)
    (if (region-active-p)
        (cl-letf (((symbol-function 'deactivate-mark)
                   (lambda (&optional _) nil))
                  ((symbol-function 'viper-move-marker-locally)
                   (lambda (_ _ &optional _) nil))
                  ((symbol-function 'push-mark)
                   (lambda (&optional _ _ _) nil)))
          (let ((prev-line-number (line-number-at-pos)))
            (apply orig-fun args)

            (when my/line-selection-p
              ;; this means we're moving up so need to go to beg of line at the end
              (if (and (car args) (< (car args) prev-line-number))
                  (beginning-of-line)
                (end-of-line)))))
      (apply orig-fun args)))

  (advice-add 'viper-goto-line :around #'my/advise-viper-goto-line)
#+end_src

** code folding
#+begin_src elisp
  (add-hook 'prog-mode-hook #'hs-minor-mode)
  (define-key viper-vi-basic-map "zC" #'hs-hide-all)
  (define-key viper-vi-basic-map "zO" #'hs-show-all)
  (define-key viper-vi-basic-map "zo" #'hs-show-block)
  (define-key viper-vi-basic-map "zc" #'hs-hide-block)
  (define-key viper-vi-basic-map "za" #'hs-toggle-hiding)
#+end_src

** advise viper-brac/ket-function
holy shit lol..
viper-cmd.el:viper-brac-function or viper-ket-function

basically dynamically binding the read-char to return the initial read-char in the viper call so that we don't double prompt user for read-char

TODO: maybe make an easier way to add new bindings
otherwise this works lol
#+begin_src elisp
  ;; [ - backwards
  (advice-mapc `(lambda (fun props) (advice-remove 'viper-brac-function fun)) 'viper-brac-function)
  (advice-add 'viper-brac-function :around
              (lambda (orig-fun &rest args)
                (let ((char (read-char)))
                  (cond ((viper= ?b char) (previous-buffer))
                        ((viper= ?t char) (tab-bar-switch-to-prev-tab))
                        ((viper= ?e char) (call-interactively 'flymake-goto-prev-error))
                        (t
                         ;; hack so that we can override read-char and only need input once
                         (cl-letf (((symbol-function 'read-char) (lambda (_ _ _) char)))
                           (apply orig-fun args)
                           )
                         )
                        ))))
  ;; ] - forwards
  (advice-mapc `(lambda (fun props) (advice-remove 'viper-key-function fun)) 'viper-key-function)
  (advice-add 'viper-ket-function :around
              (lambda (orig-fun &rest args)
                (let ((char (read-char)))
                  (cond ((viper= ?b char) (next-buffer))
                        ((viper= ?t char) (tab-bar-switch-to-next-tab))
                        ((viper= ?e char) (call-interactively 'flymake-goto-next-error))
                        (t
                         ;; hack so that we can override read-char and only need input once
                         (cl-letf (((symbol-function 'read-char) (lambda (_ _ _) char)))
                           (apply orig-fun args)
                           )
                         )
                        ))))
#+end_src

** extra VC keybindings
note after doing =vc-next-action=, running =vc-git-log-edit-toggle-amend= toggles the current commit to be an amend commit

#+begin_src elisp
  (define-key global-map "\C-xvf" #'vc-pull)
  (define-key global-map "\C-xvF" #'my/vc-git-fetch)

  (define-key global-map "\C-xve" #'my/vc-git-editor-command)
  (define-key global-map "\C-xvRi" #'my/vc-git-rebase-i)
  (define-key global-map "\C-xvRa" #'my/vc-git-rebase-abort)
  (define-key global-map "\C-xvRc" #'my/vc-git-rebase-continue)
  
  (define-key global-map "\C-xvSs" #'vc-git-stash)
  (define-key global-map "\C-xvSS" #'vc-git-stash-show)
  (define-key global-map "\C-xvSp" #'vc-git-stash-pop)
  (define-key global-map "\C-xvSa" #'vc-git-stash-apply)
  (define-key global-map "\C-xvSd" #'vc-git-stash-delete)
  (use-package vc-git :defer t
    :config
    (setq my/vc-log-vi-state-modify-map
          (make-composed-keymap
           nil
           (make-composed-keymap
            (list my/viper-vi-basic-motion-keymap
                  my/viper-vi-motion-g-keymap
                  my/viper-vi-motion-leader-keymap)
            vc-git-log-view-mode-map)))
    (define-key my/vc-log-vi-state-modify-map (kbd "C-j") #'log-view-msg-next)
    (define-key my/vc-log-vi-state-modify-map (kbd "C-k") #'log-view-msg-prev)
    (viper-modify-major-mode 'vc-git-log-view-mode 'vi-state my/vc-log-vi-state-modify-map))
#+end_src

*** VC Dir mode
#+begin_src elisp
  (use-package vc-dir :defer t
    :config
    (setq my/vc-dir-vi-state-modify-map
          (make-composed-keymap
           nil 
           (make-composed-keymap
            (list my/viper-vi-basic-motion-keymap
                  my/viper-vi-motion-g-keymap
                  my/viper-vi-motion-leader-keymap)
            vc-dir-mode-map)))
    (define-key my/vc-dir-vi-state-modify-map "x" #'vc-dir-hide-state)
    (viper-modify-major-mode 'vc-dir-mode 'vi-state my/vc-dir-vi-state-modify-map))
#+end_src

*** diff mode
#+begin_src elisp
  (use-package diff-mode :defer t
    :config
    (setq my/diff-mode-vi-state-map
          (make-composed-keymap
           nil 
           (make-composed-keymap
            (list my/viper-vi-basic-motion-keymap
                  my/viper-vi-motion-g-keymap
                  my/viper-vi-motion-leader-keymap)
            diff-mode-map)))
    (define-key my/diff-mode-vi-state-map [C-i] #'diff-hunk-next)
    (define-key my/diff-mode-vi-state-map (kbd "C-j") #'diff-hunk-next)
    (define-key my/diff-mode-vi-state-map (kbd "C-k") #'diff-hunk-prev)
    (viper-modify-major-mode 'diff-mode 'vi-state my/diff-mode-vi-state-map))
#+end_src

** dired
#+begin_src elisp
  (use-package dired :defer t
    :config
    (add-hook 'dired-mode-hook #'auto-revert-mode)
    (setq my/dired-vi-state-modify-map
          (make-composed-keymap
           nil
           (make-composed-keymap
            (list my/viper-vi-basic-motion-keymap
                  my/viper-vi-motion-g-keymap
                  my/viper-vi-motion-leader-keymap)
            dired-mode-map)))
    (define-key my/dired-vi-state-modify-map "-" #'dired-up-directory)
    (define-key my/dired-vi-state-modify-map "C" #'dired-do-copy)
    (viper-modify-major-mode 'dired-mode 'vi-state my/dired-vi-state-modify-map))
#+end_src

** ibuffer
#+begin_src elisp
  (use-package ibuffer :defer t
    :config
    (setq my/ibuffer-vi-state-modify-map
          (make-composed-keymap
           nil
           (make-composed-keymap
            (list my/viper-vi-basic-motion-keymap
                  my/viper-vi-motion-g-keymap
                  my/viper-vi-motion-leader-keymap)
            ibuffer-mode-map)))
    (viper-modify-major-mode 'ibuffer-mode 'vi-state my/ibuffer-vi-state-modify-map))
#+end_src

** elisp eval buffer
#+begin_src elisp
  (setq my/elisp-vi-state-modify-map (make-sparse-keymap))
  (define-key my/elisp-vi-state-modify-map " meb" #'eval-buffer)
  (viper-modify-major-mode 'emacs-lisp-mode 'vi-state my/elisp-vi-state-modify-map)
#+end_src

** comint mode
#+begin_src elisp
  (use-package comint :defer t
    :config
    (define-key viper-comint-mode-modifier-map (kbd "C-d") #'viper-scroll-up)
    )
#+end_src
* Org

grabbed the src block fontification from here
https://orgmode.org/worg/org-contrib/babel/examples/fontify-src-code-blocks.html

Just a bunch of convenience keymaps, some faces, and some basic settings
#+begin_src elisp
  (setq org-directory "~/orgmode/")
  (setq org-attach-id-dir (concat (file-name-as-directory org-directory) (file-name-as-directory ".attach")))
  (setq org-todo-keywords '((sequence "TODO(t)" "WIP(w)" "|" "DONE" "CANCELLED")))
  (setq org-attach-use-interitance t)

  (setq org-startup-indented t)
  (setq org-indent-indentation-per-level 4)
  (setq org-startup-folded nil) ;; to respect VISIBILITY property just can't be 'showeverything, see: org-cycle-set-startup-visibility 

  ;; allow dabbrev expand on tab when in insert mode
  (defun line-before-point-empty-p ()
    (string-blank-p (buffer-substring-no-properties (point-at-bol) (point))))

  (use-package org :defer t
    :config
    (progn
      (setq org-image-actual-width '(300))
      (setq org-goto-interface 'outline-path-completionp)
      (setq org-outline-path-complete-in-steps nil)
      (setq org-return-follows-link t)
      (setq my/org-vi-state-modify-map (make-sparse-keymap))

      (define-key my/org-vi-state-modify-map "zi" #'org-toggle-inline-images)
      (define-key my/org-vi-state-modify-map " si" #'org-goto)
      (define-key my/org-vi-state-modify-map " oaa" #'org-agenda)

      (define-key my/org-vi-state-modify-map " msl" #'org-demote-subtree)
      (define-key my/org-vi-state-modify-map " msh" #'org-promote-subtree)

      (define-key my/org-vi-state-modify-map " maa" #'org-attach)
      (define-key my/org-vi-state-modify-map " mA" #'org-archive-subtree)

      (define-key my/org-vi-state-modify-map " mds" #'org-schedule)
      (define-key my/org-vi-state-modify-map " mdd" #'org-deadline)

      (define-key my/org-vi-state-modify-map " msr" #'org-refile)

      (define-key my/org-vi-state-modify-map " mll" #'org-insert-link)
      (define-key my/org-vi-state-modify-map " nl" #'org-store-link)

      (define-key my/org-vi-state-modify-map " nl" #'org-store-link)

      (define-key org-mode-map "\t"
                  (lambda (arg)
                    (interactive "P")
                    (if (and (not (line-before-point-empty-p)) (string= viper-current-state "insert-state"))
                        (dabbrev-expand arg)
                      (org-cycle arg))))

      ;; for terminal issues with C-i
      (define-key my/org-vi-state-modify-map [C-i]
                  (lambda ()
                    (interactive)
                    ;; want org cycle if region active for indenting, or heading for collapsing
                    (if (or (org-at-heading-p) (region-active-p))
                        (call-interactively (lookup-key org-mode-map "\t"))
                      (call-interactively (lookup-key viper-vi-basic-map [C-i])))))

      (viper-modify-major-mode 'org-mode 'vi-state my/org-vi-state-modify-map)))
#+end_src

* (blasphemy) external packages
Need to install these seperately, but some configuration here
These packages are all good enough to be built in to be honest

Lets at least stick with gnu/nongnu elpa

disable native comp warnings buffer from popping up
#+begin_src elisp
(setq native-comp-async-report-warnings-errors 'silent)
#+end_src

** orderless
https://github.com/oantolin/orderless
I like orderless too much, and it's not too complicated of a package.

Otherwise the default custom partial-completion stuff we have works well enough to not impact our workflow too much
#+begin_src elisp :tangle no
  (use-package orderless :ensure nil :pin gnu
    :config
    (setq completion-styles '(orderless) completion-category-overrides nil completion-category-defaults nil)
    (defun my-icomplete-styles () (setq-local completion-styles '(orderless)))
    (remove-hook 'icomplete-minibuffer-setup-hook #'icomplete-partial-completion-setup)
    (add-hook 'icomplete-minibuffer-setup-hook 'my-icomplete-styles)
    (define-key icomplete-minibuffer-map " " #'self-insert-command))
#+end_src

** avy
avy jumping is so nice
https://github.com/abo-abo/avy

Otherwise we just use isearch and standard vi f/F motions
#+begin_src elisp
  (use-package avy :ensure nil :pin gnu :defer 2
    :config
    (define-key viper-vi-basic-map "gss" #'avy-goto-char-2)
    (define-key viper-vi-basic-map "gs/" #'avy-goto-char-timer))
#+end_src

** which key
amazing package when I forget my own keybindings
https://github.com/justbur/emacs-which-key

no good replacement for this outside of just describe function to find the keybind but we have to know the function first
#+begin_src elisp
  (use-package which-key :ensure t :pin gnu :defer 2
    :config
    (which-key-mode))
#+end_src

** my own hurl mode :)
well this oen is self explanatory
#+begin_src elisp
  (when (not (require 'hurl-mode nil 'noerrror))
    (package-vc-install "https://github.com/JasZhe/hurl-mode"))
  (use-package hurl-mode :mode "\\.hurl\\'")
#+end_src

** my own window stool mode :)
#+begin_src elisp
  (when (not (require 'window-stool nil 'noerrror))
    (package-vc-install "https://github.com/JasZhe/window-stool"))
  (use-package window-stool :defer 2
    :config
    (add-hook 'prog-mode-hook #'window-stool-mode)
    (add-hook 'org-mode-hook #'window-stool-mode))
#+end_src


** pdf tools
just browse pdfs with external tools
#+begin_src elisp
  (use-package pdf-tools :ensure nil :pin gnu
    :mode "\\.pdf\\'"
    :config
      (setq my/pdf-vi-state-modify-map (make-sparse-keymap))
      (define-key my/pdf-vi-state-modify-map "o" #'pdf-outline)
      (define-key my/pdf-vi-state-modify-map "H" #'pdf-view-fit-height-to-window)
      (define-key my/pdf-vi-state-modify-map "W" #'pdf-view-fit-width-to-window)
      (define-key my/pdf-vi-state-modify-map "j" #'pdf-view-next-line-or-next-page)
      (define-key my/pdf-vi-state-modify-map "k" #'pdf-view-previous-line-or-previous-page)
      (setq pdf-view-resize-factor 1.10)
      (define-key my/pdf-vi-state-modify-map "+" #'pdf-view-enlarge)
      (define-key my/pdf-vi-state-modify-map "-" #'pdf-view-shrink)

      (viper-modify-major-mode 'pdf-view-mode 'vi-state my/pdf-vi-state-modify-map)
    )
#+end_src

** magit
I want to actually learn how to use the built in vc mode a lot more, but there are some cases where having magit is really nice i.e. rebasing or staging specific lines rather than the whole file.
#+begin_src elisp :tangle no
  (use-package magit :ensure nil :pin gnu :defer 5
    :config
    (add-to-list 'auto-mode-alist '("/git-rebase-todo\\'" . git-rebase-mode))
    
    (define-key my/leader-prefix-map "gg" #'magit)
    (setq my/magit-vi-state-modify-map
          (make-composed-keymap
           nil
           (make-composed-keymap 
            (list my/viper-vi-basic-motion-keymap
                  my/viper-vi-motion-g-keymap
                  my/viper-vi-motion-leader-keymap)
            magit-mode-map)))
    (define-key my/magit-vi-state-modify-map "x" #'magit-discard)
    (define-key my/magit-vi-state-modify-map "`" #'magit-process-buffer)
    (define-key my/magit-vi-state-modify-map "E" #'magit-ediff)
    (define-key my/magit-vi-state-modify-map (kbd "C-l") #'magit-log)
    (define-key my/magit-vi-state-modify-map (kbd "C-b") #'magit-branch)
    (define-key my/magit-vi-state-modify-map "p" #'magit-push)
    (define-key my/magit-vi-state-modify-map "F" #'magit-pull)
    (define-key my/magit-vi-state-modify-map " gF" #'magit-fetch)

    (viper-modify-major-mode 'magit-status-mode 'vi-state my/magit-vi-state-modify-map))
#+end_src

#+begin_src elisp
  (rassq-delete-all 'git-rebase-mode auto-mode-alist)
#+end_src

** consult
#+begin_src elisp :tangle no
  (use-package consult :ensure t :pin gnu :defer 5
    :init
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)
    :config
    (setq completion-in-region-function #'consult-completion-in-region)
    )
#+end_src

* external language packages
** web mode
no good replacement, just have to turn on js-mode or js-jsx-mode and html-mode
#+begin_src elisp
    (when (not (require 'web-mode nil 'noerrror))
      (package-vc-install '(web-mode :url "https://github.com/fxbois/web-mode"
                                     :rev "82847071ce93293bdb7945db08d970f13fd883cf")))
    (use-package web-mode :ensure nil :pin gnu
      :mode "\\.gohtml\\'"
      :config
      (setq web-mode-engines-alist '(("go" . "\\.gohtml\\'") ("svelte" . "\\.svelte\\'"))))
#+end_src

** clojure
#+begin_src elisp :tangle no
  (use-package clojure-mode :ensure t :pin gnu :defer 5)
  (use-package cider :ensure t :pin nongnu :defer 5)
#+end_src

** kotlin
#+begin_src elisp :tangle no
  (when (not (require 'kotlin-mode nil 'noerror))
    (package-vc-install '(kotlin-ts-mode :url "https://gitlab.com/bricka/emacs-kotlin-ts-mode"
                                         :rev "c884b3442806a21cbcf28ac24853f05da8ac6658")))
  (use-package kotlin-ts-mode :ensure nil :mode "\\.kt\\'"
    :config
    (with-eval-after-load 'eglot
      (add-to-list 'eglot-server-programs '(kotlin-ts-mode . ("kotlin-language-server")))))

  (add-hook 'kotlin-ts-mode #'eglot-ensure)
#+end_src

* custom
#+begin_src elisp
  (custom-set-variables
   ;; custom-set-variables was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   '(package-selected-packages '(window-stool))
   '(package-vc-selected-packages
     '((window-stool :vc-backend Git :url "https://github.com/JasZhe/window-stool")))
   '(safe-local-variable-values
     '((eval add-hook 'after-save-hook
             (lambda nil
               (org-babel-tangle))
             nil t))))
  (custom-set-faces
   ;; custom-set-faces was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   )
#+end_src

* Local variables                                                        
;; Local Variables:                                                      
;; eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle)) nil t)
;; End:                                                                  

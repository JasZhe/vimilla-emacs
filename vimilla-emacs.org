#+title: Minimalistic Vim Flavoured Emacs Config
#+PROPERTY: header-args :tangle yes :comments link :noeval :mkdirp yes

* Mac settings
if machine isn't a mac then this won't do anything anyways so need to do some OS version check or whatever
#+begin_src elisp
  (setq mac-option-modifier 'meta)
#+end_src

* General Settings
enable fido-vertical mode, viper mode, global hl and visual lines
#+begin_src elisp
  (add-to-list 'completion-styles 'substring)
  (fido-vertical-mode)
  (viper-mode)
  (global-hl-line-mode)
  (global-visual-line-mode)

  (keymap-set minibuffer-local-completion-map "TAB" #'icomplete-force-complete)
  (keymap-set global-map "C-z" #'viper-mode) ;; C-z to suspend frame is annoying with viper

  (setq visual-bell t)
  (setq ring-bell-function 'ignore)
  (setq scroll-preserve-screen-position t)
#+end_src

* Tab bar
basically minimal projectile and persp
#+begin_src elisp
  (defun find-git-dir (dir)
   "Search up the directory tree looking for a .git folder."
   (cond
    ((eq major-mode 'dired-mode) "Dired")
    ((not dir) "process")
    ((string= dir "/") "no-git")
    (t (vc-root-dir))))

  (defun git-tabbar-buffer-groups ()
    "Groups tabs in tabbar-mode by the git repository they are in."
    (list (find-git-dir (buffer-file-name (current-buffer)))))
  ;; (setq tabbar-buffer-groups-function 'git-tabbar-buffer-groups)
#+end_src


* Viper
:PROPERTIES:
:header-args: :tangle ~/.emacs.d/viper :comments link :noeval
:END:
viper is the only built in thing that handles /some/ of the Doom/Vim stuff that I want (since it emulates Vi and not Vim)


** general
hacky global var to have a "global" viper state
is this better than the default behavior?
Maybe.. maybe not but now this should enable viper mode even on major modes not specified by viper itself
#+begin_src elisp

  (setq my/global-viper-state 'vi)
  (defun set-global-viper-state (arg)
    (cond ((eq my/global-viper-state 'vi) (viper-change-state-to-vi))
          ((eq my/global-viper-state 'emacs) (viper-change-state-to-emacs))
          ((eq my/global-viper-state 'ins) (viper-change-state-to-insert))
          (t (viper-change-state-to-vi))
    ))
  (add-to-list 'window-state-change-functions #'set-global-viper-state)
#+end_src

want backspace in insert deletes to previous line when curr line is empty
want some indication of which mode we're in outside of the modeline

stole the terminal code for cursor from here https://github.com/syl20bnr/spacemacs/issues/7112#issuecomment-389855491
works on iterm2 at least, 0 for box, 6 for bar cursor
#+begin_src elisp
  (setq viper-inhibit-startup-message 't)
  (setq viper-expert-level '5)

  ;; prefer the following to be in whatever state I'm already in
  (setq viper-emacs-state-mode-list (remove 'Custom-mode viper-emacs-state-mode-list))
  (setq viper-emacs-state-mode-list (remove 'dired-mode viper-emacs-state-mode-list))
  (setq viper-emacs-state-mode-list (remove 'occur-mode viper-emacs-state-mode-list))
  (setq viper-emacs-state-mode-list (remove 'help-mode viper-emacs-state-mode-list))
  
  (add-hook 'viper-insert-state-hook (lambda ()
                                       (global-hl-line-mode -1)
                                       (setq my/global-viper-state 'ins)
                                       (send-string-to-terminal "\033[6 q")
                                       (setq viper-ex-style-editing nil)))

  ;; otherwise hl-line-mode stays off after running an ex command like :w
  (add-hook 'viper-minibuffer-exit-hook (lambda () (global-hl-line-mode) (send-string-to-terminal "\033[0 q")))

  (add-hook 'viper-minibuffer-exit-hook #'viper-change-state-to-vi)
  (add-hook 'viper-vi-state-hook (lambda ()
                                   (global-hl-line-mode)
                                   (setq my/global-viper-state 'vi)
                                   (set-face-attribute 'hl-line nil :background "LightCyan1")
                                   (send-string-to-terminal "\033[0 q")))
  (add-hook 'viper-emacs-state-hook (lambda ()
                                      (global-hl-line-mode)
                                      (setq my/global-viper-state 'emacs)
                                      (set-face-attribute 'hl-line nil :background "LavenderBlush1")
                                      (send-string-to-terminal "\033[0 q")))

  (add-hook 'minibuffer-mode-hook #'viper-change-state-to-insert)
  (add-hook 'minibuffer-exit-hook #'viper-change-state-to-vi)
  (setq viper-insert-state-cursor-color nil)
#+end_src

qol to use c-h for help commands, and something for us to type faster
#+begin_src elisp
  (setq viper-want-ctl-h-help 't)
  (setq viper-fast-keyseq-timeout 100)
#+end_src

better ESC key handling to exit visual mode and close mini buffer
#+begin_src elisp
  (advice-add 'viper-intercept-ESC-key :after #'deactivate-mark)
  (advice-add 'viper-intercept-ESC-key :after (lambda () (ignore-errors (abort-minibuffers))))
#+end_src

** pop mark navigation
#+begin_src elisp
    (define-key viper-vi-basic-map "\C-o" #'pop-global-mark)
                ;;(lambda () (interactive) (let ((current-prefix-arg t)) (set-mark-command current-prefix-arg))))
#+end_src

** respect visual lines cursor movement
#+begin_src elisp
(define-key viper-vi-basic-map "k" #'previous-line)
(define-key viper-vi-basic-map "j" #'next-line)
#+end_src

** Window movement
not necessary viper, but same idea
#+begin_src elisp
  (define-key global-map (kbd "C-w") nil)

  (define-key global-map "\C-wv" #'split-window-horizontally)
  (define-key global-map "\C-wq" #'delete-window)
  (define-key global-map "\C-w\C-w" #'other-window)

  (define-key global-map "\C-wl" #'windmove-right)
  (define-key global-map "\C-w\C-l" #'windmove-right)

  (define-key global-map "\C-wh" #'windmove-left)
  (define-key global-map "\C-w\C-h" #'windmove-left)

  (define-key global-map "\C-wk" #'windmove-up)
  (define-key global-map "\C-w\C-k" #'windmove-up)

  (define-key global-map "\C-wj" #'windmove-down)
  (define-key global-map "\C-w\C-j" #'windmove-down)

  (define-key global-map "\C-w=" #'balance-windows)
#+end_src

** pseudo visual mode
*** pseudo visual line
have a variable for us to know if we're in the a pseudo line selection or normal selection
#+begin_src elisp  
  (setq my/line-selection-p nil)

  (defun my/select-lines (arg)
    "go to beginning of line and select rectangle mark and also set line selection flag"
    (interactive "p")
    (setq my/line-selection-p t)
    (beginning-of-line)
    (rectangle-mark-mode arg)
    (end-of-visual-line))

  ;;(advice-mapc `(lambda (fun props) (advice-remove 'rectangle-previous-line fun)) 'rectangle-previous-line)
  ;;(advice-mapc `(lambda (fun props) (advice-remove 'rectangle-next-line fun)) 'rectangle-next-line)

  (advice-add 'rectangle-previous-line :after                                             
              (lambda (&rest args) (when my/line-selection-p (end-of-line))))
  (advice-add 'rectangle-next-line :after
              (lambda (&rest args) (when my/line-selection-p (end-of-line))))

  (defun my/set-mark-command (arg)
    "set mark, and also unset line selection flag"
    (interactive "P")
    (setq my/line-selection-p nil)
    (set-mark-command arg))

  (defun my/visual-block (arg)
    "set rectangle mark, and also unset line selection flag"
    (interactive "P")
    (setq my/line-selection-p nil)
    (rectangle-mark-mode arg))
#+end_src

v or V will set that line selection var accordingly
deactivate mark on esc
#+begin_src elisp
  (define-key viper-vi-basic-map "v" nil)
  (define-key viper-vi-basic-map "v" #'my/set-mark-command)
  (define-key viper-vi-basic-map "V" nil)
  (define-key viper-vi-basic-map "V" #'my/select-lines)
  
  (define-key viper-vi-basic-map "\C-v" #'my/visual-block)
#+end_src

*** viper-ex to automatically use region if active
#+begin_src elisp
  ;;(advice-mapc `(lambda (fun props) (advice-remove 'viper-ex fun)) 'viper-ex)
  (advice-add 'viper-ex :around
              (lambda (orig-fun &rest args)
                (let ((current-prefix-arg t))
                  (if (use-region-p) (apply orig-fun current-prefix-arg args)
                    (apply orig-fun args)))))
#+end_src

*** join lines on selected region
if the region exists then we jump to the beginning of the region and merge the number of lines selected
#+begin_src elisp
  ;; (advice-mapc `(lambda (fun props) (advice-remove 'viper-join-lines fun)) 'viper-join-lines)
  (advice-add 'viper-join-lines :around
              (lambda (orig-fun arg &rest args)
                (interactive "P")
                (if (use-region-p)
                    (let* ((start (region-beginning))
                          (end (region-end))
                          (numlines (count-lines start end)))
                      (goto-char start)
                      (apply orig-fun `(,numlines)))
                  (apply orig-fun `(,arg)))))
#+end_src

*** better yanking/killing for visual selection
#+begin_src elisp
    (defun viper-delete-region-or-motion-command (arg)
       "convenience function for deleting a region, including rectangles"
       (interactive "P")
       (if (use-region-p)
           (progn
             (unless rectangle-mark-mode (forward-char))
             (kill-region (region-beginning) (region-end) (use-region-p)))
         (viper-command-argument arg)))

    (defun viper-yank-region-or-motion-command (arg)
       "convenience function for yanking a region, including rectangles"
       (interactive "P")
       (if (use-region-p)
           (progn
             (unless rectangle-mark-mode (forward-char))
             (copy-region-as-kill (region-beginning) (region-end) t)
             (unless rectangle-mark-mode (backward-char))
             )
         (viper-command-argument arg)))

    (defun viper-paste-into-region (arg)
      "if region is active, delete region before pasting
  respects rectangle mode in a similar way to vim/doom"
      (interactive "P")
      (when (use-region-p)
        (unless rectangle-mark-mode (forward-char))
        (let ((start (region-beginning)))
          (delete-active-region)
          (goto-char start)))
          (yank arg))

     (define-key viper-vi-basic-map "d" #'viper-delete-region-or-motion-command)
     (define-key viper-vi-basic-map "y" #'viper-yank-region-or-motion-command)
     (define-key viper-vi-basic-map "p" #'viper-paste-into-region)
#+end_src

** undo
thank god for undo-only but emacs > 28 only
need to remap isearch-backward since i wanna use C-r for redo
#+begin_src elisp
  (define-key viper-vi-basic-map "u" #'undo-only)
  (define-key viper-vi-basic-map (kbd "C-r") #'undo-redo)
  (define-key viper-vi-basic-map (kbd "C-M-r")  #'isearch-backward)
#+end_src

** "g" prefix commands
#+begin_src elisp
  (define-prefix-command 'my-vi-g-prefix-map)
  (define-key viper-vi-basic-map "g" #'my-vi-g-prefix-map)
  (define-key 'my-vi-g-prefix-map "g" #'beginning-of-buffer)
#+end_src

*** movement since we have visual lines
#+begin_src elisp
  (define-key 'my-vi-g-prefix-map "k" #'viper-previous-line)
  (define-key 'my-vi-g-prefix-map "j" #'viper-next-line)
#+end_src

*** tab bar movement
#+begin_src elisp
  (define-key 'my-vi-g-prefix-map "t" #'tab-bar-switch-to-next-tab)
  (define-key 'my-vi-g-prefix-map "T" #'tab-bar-switch-to-prev-tab)
#+end_src


** pseudo "leader" prefix
#+begin_src elisp
  (define-prefix-command 'my-vi-leader-prefix-map)
  (define-key viper-vi-basic-map " " #'my-vi-leader-prefix-map)
  (define-key my-vi-leader-prefix-map "," #'ido-switch-buffer)
  (define-key my-vi-leader-prefix-map "u" #'universal-argument)


  (define-key my-vi-leader-prefix-map "F" #'project-find-file)
  (define-key my-vi-leader-prefix-map "G" #'vc-git-grep) ;; good enough
#+end_src

*** "open" prefix
#+begin_src elisp
  (define-prefix-command 'my-vi-open-prefix-map)
  (define-key my-vi-leader-prefix-map "o" #'my-vi-open-prefix-map)
  (define-key my-vi-open-prefix-map "e" #'eshell)
  (define-key my-vi-open-prefix-map "s" #'shell)
#+end_src

*** "project" prefix
#+begin_src elisp
  (define-prefix-command 'my-vi-project-prefix-map)
  (define-key my-vi-leader-prefix-map "p" #'my-vi-project-prefix-map)
  (define-key my-vi-project-prefix-map "e" #'project-eshell)
  (define-key my-vi-project-prefix-map "s" #'project-shell)
#+end_src

*** "help" prefix
#+begin_src elisp
  (define-prefix-command 'my-vi-help-prefix-map)
  (define-key my-vi-leader-prefix-map "h" #'my-vi-help-prefix-map)
  (define-key my-vi-help-prefix-map "k" #'describe-key)
  (define-key my-vi-help-prefix-map "f" #'describe-function)
  (define-key my-vi-help-prefix-map "v" #'describe-variable)
  (define-key my-vi-help-prefix-map "m" #'describe-mode)
  (define-key my-vi-help-prefix-map "o" #'describe-symbol)
#+end_src

*** "buffer" prefix
#+begin_src elisp
  (define-prefix-command 'my-vi-buffer-prefix-map)
  (define-key my-vi-leader-prefix-map "b" #'my-vi-buffer-prefix-map)
  (define-key my-vi-buffer-prefix-map "r" #'revert-buffer)
  (define-key my-vi-buffer-prefix-map "p" #'previous-buffer)
  (define-key my-vi-buffer-prefix-map "n" #'next-buffer)
#+end_src

*** "tab" bar prefix
#+begin_src elisp
  (define-prefix-command 'my-vi-tabbar-prefix-map)
  (define-key my-vi-leader-prefix-map "\t" #'my-vi-tabbar-prefix-map)
  (define-key my-vi-tabbar-prefix-map "n" #'tab-bar-new-tab)
  (define-key my-vi-tabbar-prefix-map "d" #'tab-bar-close-tab)
#+end_src 

** pseudo "files" "f" prefix
#+begin_src elisp
    (define-prefix-command 'my-vi-files-prefix-map)
    (define-key my-vi-leader-prefix-map "f" #'my-vi-files-prefix-map)
    (define-key my-vi-files-prefix-map "f" #'find-file)
#+end_src

** code folding
#+begin_src elisp
  (hs-minor-mode)
  (define-key viper-vi-basic-map "zC" #'hs-hide-all)
  (define-key viper-vi-basic-map "zO" #'hs-show-all)
  (define-key viper-vi-basic-map "zo" #'hs-show-block)
  (define-key viper-vi-basic-map "zc" #'hs-hide-block)
  (define-key viper-vi-basic-map "za" #'hs-toggle-hiding)
#+end_src

** eglot
#+begin_src elisp
  (define-key 'my-vi-g-prefix-map "d" #'xref-find-definitions)
  (define-key 'my-vi-g-prefix-map "D" #'xref-find-references)
#+end_src

#+begin_src elisp
    (define-prefix-command 'my-vi-code-prefix-map)
    (define-key my-vi-leader-prefix-map "c" #'my-vi-code-prefix-map)
    (define-key my-vi-code-prefix-map "f" #'eglot-format-buffer)
    (define-key my-vi-code-prefix-map "x" #'flymake-show-project-diagnostics)
#+end_src

* Org
#+begin_src elisp
  (setq org-startup-indented t)
  (setq org-indent-indentation-per-level 4)
#+end_src

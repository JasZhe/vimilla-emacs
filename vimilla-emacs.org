#+title: Minimalistic Vim Flavoured Emacs Config
#+PROPERTY: header-args :tangle init.el :results silent

* CANCELLED separate document for keybindings?
I do enjoy having everything in the one file though and a lot of this stuff is not /just/ setting keybinds,
its also doing a lot of elisp stuff that work /with/ the keybinds

* WIP other git commands that VC doesn't handle like git rebase and stuff
something like this

mainly for these two:
git fetch
git rebase

and need to figure out keymappings

just a simple wrapper in the case where we can't install magit
#+begin_src elisp
  (defun my/vc-git-editor-command (command)
    "command is a git subcommand that requires an editor.
  example usage: (my/vc-git-editor-command \"rebase -i HEAD~3\")"
    (interactive "P")
    (unless server-mode (server-force-delete) (server-mode))
    (let ((command (if command command (read-string "command: git "))))
      (async-shell-command
       (concat "GIT_EDITOR=\"emacsclient\" bash -c \"git " command "\""))))

  (defun my/vc-git-rebase-i (&optional branch)
    "if branch isn't supplied from arg, prompt for it"
    (interactive)
    (let ((revision (if branch branch (read-string "revision: "))))
      (my/vc-git-editor-command (concat "rebase -i " revision))))

  (defun my/vc-git-rebase-abort ()
    (interactive)
    (async-shell-command "rebase --abort"))

  (defun my/vc-git-rebase-continue ()                  
    (interactive)                                 
    (async-shell-command "rebase --continue"))

  (defun my/vc-git-fetch ()                  
    (interactive)                                  
    (async-shell-command "git fetch"))
#+end_src

* Mac settings
if machine isn't a mac then this won't do anything anyways so need to do some OS version check or whatever
#+begin_src elisp
  (setq mac-option-modifier 'meta)
  (setq mac-command-modifier 'super)
  (define-key global-map (kbd "s-/") #'comment-line)
#+end_src

* misc startup tasks
enable fido-vertical mode, viper mode, global hl and visual lines
stole the completing read stuff from:
https://www.reddit.com/r/emacs/comments/zl6amy/completionatpoint_using_completingread_icomplete/

#+begin_src elisp
  (setq viper-mode t)
  (require 'viper)
  (require 'rect)
  (fido-vertical-mode)
  (viper-mode)
  (global-hl-line-mode)
  (global-visual-line-mode)
  (setq column-number-mode t)

  (keymap-set minibuffer-local-completion-map "TAB" #'icomplete-force-complete)
  (keymap-set global-map "C-z" #'viper-mode) ;; C-z to suspend frame is annoying with viper

  (setq scroll-margin 8)
  (setq visual-bell t)
  (setq ring-bell-function 'ignore)
  (setq scroll-preserve-screen-position t)
#+end_src

* in-buffer searching
** advice to highlight matches with viper search
#+begin_src elisp
  (advice-add #'viper-search :after
              (lambda (string &rest args)
                (hi-lock-face-buffer string)))
#+end_src

** optional incremental occur, similar to swiper
[[*better escape handling][advice to turn off highlighting on escape]]
#+begin_src elisp
  ;; keep highlighting after isearch
  (setq lazy-highlight-cleanup nil)

  ;; be explicit about using this advice
  (setq my/ioccur-p nil)
  (defun my/ioccur ()
    (interactive)
    (setq my/ioccur-p t)
    (call-interactively 'isearch-forward))

  (add-hook 'isearch-mode-hook
           (lambda ()
              (if my/ioccur-p
                  (advice-add #'isearch-printing-char :after
                              (lambda (&rest args)
                                (if isearch-regexp (isearch-occur isearch-regexp)
                                  (isearch-occur isearch-string))))
                (advice-mapc `(lambda (fun props) (advice-remove 'isearch-printing-char fun)) 'isearch-printing-char))))

  (add-hook 'isearch-mode-end-hook (lambda () (setq my/ioccur-p nil)))
#+end_src

* xref completion settings
luckily this is built in lol
#+begin_src elisp
  (use-package xref
    :config
    (progn
      (setq xref-search-program 'ripgrep)
      (setq xref-show-xrefs-function #'xref-show-definitions-completing-read)      
      (setq xref-show-definitions-function #'xref-show-definitions-completing-read)
      )
    )
#+end_src

* Window commands
not necessary viper, but same idea
#+begin_src elisp
  (winner-mode)

  (define-key global-map (kbd "\C-w") nil)

  (define-key global-map (kbd "\C-wu") #'winner-undo)
  (define-key global-map (kbd "\C-wr") #'winner-redo)

  (define-key global-map (kbd "\C-w<")
              (lambda (arg) (interactive "P") (shrink-window-horizontally (if arg arg 1))))
  (define-key global-map (kbd "\C-w>")
              (lambda (arg) (interactive "P") (enlarge-window-horizontally (if arg arg 1))))

  (define-key global-map (kbd "\C-w-")
              (lambda (arg) (interactive "P") (shrink-window (if arg arg 1))))
  (define-key global-map (kbd "\C-w+")
              (lambda (arg) (interactive "P") (enlarge-window (if arg arg 1))))

  (define-key global-map "\C-wv" #'split-window-horizontally)
  (define-key global-map "\C-ws" #'split-window-vertically)

  (define-key global-map "\C-wq" #'delete-window)
  (define-key global-map "\C-w\C-w" #'other-window)

  (define-key global-map "\C-wl" #'windmove-right)
  (define-key global-map "\C-w\C-l" #'windmove-right)

  (define-key global-map "\C-wh" #'windmove-left)
  (define-key global-map "\C-w\C-h" #'windmove-left)

  (define-key global-map "\C-wk" #'windmove-up)
  (define-key global-map "\C-w\C-k" #'windmove-up)

  (define-key global-map "\C-wj" #'windmove-down)
  (define-key global-map "\C-w\C-j" #'windmove-down)

  (define-key global-map "\C-w=" #'balance-windows)

  (define-key global-map (kbd "\C-wo") #'maximize-window)
  (define-key global-map "\C-w\C-o" #'delete-other-windows)
#+end_src

* development
** qol
#+begin_src elisp
  (add-hook 'prog-mode-hook #'flymake-mode)
  (setq treesit-font-lock-level 4)
  (which-function-mode)
  (electric-pair-mode)
#+end_src

** go use treesit
#+begin_src elisp
(add-to-list 'auto-mode-alist '("\\.go\\'" . go-ts-mode))
#+end_src

** some more basic elisp highlighting
stole most of this from here:
https://stackoverflow.com/questions/18289329/how-to-highlight-all-the-functions-name-in-emacs-lisp-mode

#+begin_src elisp
    (defface font-lock-func-face 
      '((nil (:foreground "#7F0055" :weight bold))
        (t (:bold t :italic t)))
    "Font Lock mode face used for function calls."
    :group 'font-lock-highlighting-faces)

  (font-lock-add-keywords
   'emacs-lisp-mode
   '(("(\\s-*\\(\\_<\\(?:\\sw\\|\\s_\\)+\\)\\_>"
      1 'font-lock-constant-face)) 'append)

  (defun my-fl (_limit)
    (let ((opoint  (point))
          (found   nil))
      (with-syntax-table emacs-lisp-mode-syntax-table
        (while (not found)
          (cond ((condition-case ()
                     (save-excursion
                       (skip-chars-forward "'")
                       (setq opoint  (point))
                       (let ((obj  (read (current-buffer))))
                         (and (symbolp obj)  (fboundp obj)
                              (progn (set-match-data (list opoint (point))) t))))
                   (error nil))
                 (forward-sexp 1)
                 (setq opoint  (point)
                       found   t))
                (t
                 (if (looking-at "\\(\\sw\\|\\s_\\)")
                     (forward-sexp 1)
                   (forward-char 1)))))
        found)))
#+end_src
           
** in buffer completion
from:
https://www.reddit.com/r/emacs/comments/zl6amy/completionatpoint_using_completingread_icomplete/
#+begin_src elisp
  (setq enable-recursive-minibuffers t)
  (defun completing-read-in-region (start end collection &optional predicate)
     "Prompt for completion of region in the minibuffer if non-unique.
    Use as a value for `completion-in-region-function'."
     (let* ((initial (buffer-substring-no-properties start end))
            (all (completion-all-completions initial collection predicate
                                             (length initial)))
            (completion (cond
                         ((atom all) nil)
                         ((and (consp all) (atom (cdr all))) (car all))
                         (t (completing-read
                             "Completion: " collection predicate t initial)))))
       (cond (completion (completion--replace start end completion) t)
             (t (message "No completion") nil))))
   (setq completion-in-region-function #'completing-read-in-region)
#+end_src

** eshell
#+begin_src elisp
  (defun my/eshell-send-cmd-async ()
    (interactive)
    (let ((cmd (string-trim (buffer-substring-no-properties eshell-last-output-end (progn (end-of-line) (point))))))
      (unless (eshell-head-process)
        (delete-region eshell-last-output-end (point))
        (insert (format "async-shell-command \"%s\"" cmd)))
      )
    )

  (use-package eshell
    :config
    (add-to-list 'eshell-modules-list 'eshell-tramp)
    (setq my/eshell-vi-state-modify-map (make-sparse-keymap))
    (setq my/eshell-insert-state-modify-map (make-sparse-keymap))

    (define-key my/eshell-vi-state-modify-map (kbd "C-<return>") #'my/eshell-send-cmd-async)
    (define-key my/eshell-vi-state-modify-map " ma" #'my/eshell-send-cmd-async)
    (define-key my/eshell-insert-state-modify-map (kbd "C-<return>") #'my/eshell-send-cmd-async)

    (viper-modify-major-mode 'eshell-mode 'vi-state my/eshell-vi-state-modify-map)
    (viper-modify-major-mode 'eshell-mode 'insert-state my/eshell-insert-state-modify-map)
    )
#+end_src

* Font and theme
current system uses iosevka custom nerd font
#+begin_src elisp
  (when (member "IosevkaCustom Nerd Font Propo" (font-family-list))
    (set-face-attribute 'default nil :font "IosevkaCustom Nerd Font Propo" :height 130))
  (when (member "Iosevka Etoile" (font-family-list))
    (set-face-attribute 'variable-pitch nil :font "Iosevka Etoile" :height 130))
#+end_src

** modus
#+begin_src elisp
  (setq modus-themes-headings
        '((1 . (rainbow overline background variable-pitch 1.25))
          (2 . (rainbow background variable-pitch 1.15))
          (3 . (rainbow bold variable-pitch 1.1))
          (t . (semilight variable-pitch 1.05))))

  (setq modus-themes-bold-constructs t)
  (setq modus-themes-italic-constructs t)
  (setq modus-themes-org-blocks 'gray-background)
  (load-theme 'modus-operandi)
#+end_src

* Tab bar
basically minimal projectile and persp
#+begin_src elisp
  (defun find-git-dir (dir)
   "Search up the directory tree looking for a .git folder."
   (cond
    ((eq major-mode 'dired-mode) "Dired")
    ((not dir) "process")
    ((string= dir "/") "no-git")
    (t (vc-root-dir))))

  (defun git-tabbar-buffer-groups ()
    "Groups tabs in tabbar-mode by the git repository they are in."
    (list (find-git-dir (buffer-file-name (current-buffer)))))
#+end_src



* Viper
:PROPERTIES:
:header-args: :tangle viper :results silent
:END:
viper is the only built in thing that handles /some/ of the Doom/Vim stuff that I want (since it emulates Vi and not Vim)

** vi state stuff
hacky global var to have a "global" viper state
is this better than the default behavior?
Maybe.. maybe not but now this should enable viper mode even on major modes not specified by viper itself
*** global viper state
TODO: add a hook on buffer creation to see if viper is enabled or not, and if not enable it, then switch to the global state?
#+begin_src elisp

  (setq my/global-viper-state 'vi)
  (defun set-global-viper-state (arg)
    (cond ((eq my/global-viper-state 'vi) (viper-change-state-to-vi))
          ((eq my/global-viper-state 'emacs) (viper-change-state-to-emacs))
          ((eq my/global-viper-state 'ins) (viper-change-state-to-insert))
          (t (viper-change-state-to-vi))
    ))
  (add-to-list 'window-state-change-functions #'set-global-viper-state)
#+end_src

**** want better normal state bindings in the "emacs state" buffers
TODO: maybe we just set all of these to nil since we have this pseudo global state?
#+begin_src elisp
  ;; prefer the following to be in whatever state I'm already in                                       
  (setq viper-emacs-state-mode-list (remove 'Custom-mode viper-emacs-state-mode-list))                 
  (setq viper-emacs-state-mode-list (remove 'dired-mode viper-emacs-state-mode-list))                  
  (setq viper-emacs-state-mode-list (remove 'occur-mode viper-emacs-state-mode-list))                  
  (setq viper-emacs-state-mode-list (remove 'help-mode viper-emacs-state-mode-list))                   
  (setq viper-emacs-state-mode-list (remove 'completion-list-mode viper-emacs-state-mode-list))
  (setq viper-emacs-state-mode-list (remove 'completion-list-mode viper-emacs-state-mode-list))


  ;; then remove all emacs states and replace with insert states                                       
  (setq viper-insert-state-mode-list (append viper-emacs-state-mode-list viper-insert-state-mode-list))
  (setq viper-emacs-state-mode-list nil)
#+end_src

*** hl line for diff modes, viper viper insert delets to prev line
stole the terminal code for cursor from here https://github.com/syl20bnr/spacemacs/issues/7112#issuecomment-389855491
works on iterm2 at least, 0 for box, 6 for bar cursor
#+begin_src elisp
  (setq viper-inhibit-startup-message 't)
  (setq viper-expert-level '5)

  (add-hook 'viper-insert-state-hook (lambda ()
                                       (global-hl-line-mode -1)
                                       (setq my/global-viper-state 'ins)
                                       (when (not (display-graphic-p)) (send-string-to-terminal "\033[6 q"))
                                       (setq viper-ex-style-editing nil)))

  ;; otherwise hl-line-mode stays off after running an ex command like :w

  (add-hook 'viper-minibuffer-exit-hook (lambda () (global-hl-line-mode) (when (not (display-graphic-p)) (send-string-to-terminal "\033[0 q"))))

  (add-hook 'viper-vi-state-hook (lambda ()
                                   (global-hl-line-mode)
                                   (setq my/global-viper-state 'vi)
                                   (set-face-attribute 'hl-line nil :background "LightCyan1")
                                   (when (not (display-graphic-p)) (send-string-to-terminal "\033[0 q"))))
  (add-hook 'viper-emacs-state-hook (lambda ()
                                      (global-hl-line-mode)
                                      (setq my/global-viper-state 'emacs)
                                      (set-face-attribute 'hl-line nil :background "LavenderBlush1")
                                      (when (not (display-graphic-p)) (send-string-to-terminal "\033[0 q"))))

  (add-hook 'minibuffer-mode-hook #'viper-change-state-to-insert)
  (add-hook 'minibuffer-exit-hook #'viper-change-state-to-vi)
  (setq viper-insert-state-cursor-color nil)
#+end_src

** help commands
qol to use c-h for help commands, and something for us to type faster
#+begin_src elisp
  (setq viper-want-ctl-h-help 't)
  (setq viper-fast-keyseq-timeout 100)
#+end_src

** better escape handling
better ESC key handling to exit visual mode and close mini buffer
#+begin_src elisp
  ;; (advice-mapc `(lambda (fun props) (advice-remove 'viper-intercept-ESC-key fun)) 'viper-intercept-ESC-key)
  (advice-add 'viper-intercept-ESC-key :after #'deactivate-mark)
  (advice-add 'viper-intercept-ESC-key :after (lambda () (ignore-errors (abort-minibuffers))))
  (advice-add 'viper-intercept-ESC-key :after (lambda () (ignore-errors (cua-clear-rectangle-mark))))
  (advice-add 'viper-intercept-ESC-key :after (lambda () (lazy-highlight-cleanup t)))
  (advice-add 'viper-intercept-ESC-key :after (lambda ()
                                                (dolist (hist viper-search-history)
                                                  (hi-lock-unface-buffer hist))))
#+end_src

** pop mark navigation
#+begin_src elisp
  ;; add to global marks when window stuff happens so we can switch back to prev position
  (setq window-scroll-functions nil)
  ;; not perfect but good enough, need to also make sure region not active, so we don't reset the region on scroll
  (add-to-list 'window-scroll-functions (lambda (window _)
                                          (when (and (not (region-active-p)) (eq window (selected-window)))
                                            (push-mark nil t nil))))
  (setq window-buffer-change-functions nil)
  (add-to-list 'window-buffer-change-functions (lambda (_)
                                                 (with-current-buffer (other-buffer)
                                                   (push-mark nil t nil))))
  (define-key viper-vi-basic-map "\C-i" #'xref-go-forward)
  (define-key viper-vi-basic-map "\t" nil)
  (define-key viper-vi-basic-map "\C-o"
              (lambda ()
                (interactive)
                (condition-case nil
                    (xref-go-back)
                  (error
                   (pop-global-mark)
                   nil))
              ))
#+end_src

** respect visual lines cursor movement
#+begin_src elisp
  (define-key viper-vi-basic-map "k" #'previous-line)
  (define-key viper-vi-basic-map "j" #'next-line)
#+end_src

** forward "enter" and "q" in vi state
good enough solution without getting too complicated
we never really type these in normal mode anyways
and these are pretty useful in some buffers

default behavior of the enter key is pretty meh anyways
q is just bound to viper-nil as well
#+begin_src elisp
  (define-key viper-vi-basic-map (kbd "RET") nil)
  (define-key viper-vi-basic-map "q" nil)
#+end_src

** pseudo visual mode
*** hacky advice for next/previous line to emulate visual mode
basically a bunch of mark manipualtion essentially.

a lot of the problem is just around making sure that starting line is always marked, similar to vim
#+begin_src elisp
  (setq selected-start-line -1)
  (add-hook 'activate-mark-hook (lambda () (setq selected-start-line (line-number-at-pos))))
  ;; (advice-mapc `(lambda (fun props) (advice-remove 'next-line fun)) 'next-line)
  (advice-add 'next-line :around
              (lambda (orig-fun &rest args)
                (interactive)
                ;; because now we're not getting the last newline
                (if (< (line-number-at-pos) selected-start-line)
                    (setq extra-line-after-yank t)
                  (setq extra-line-after-yank nil))

                (if my/line-selection-p
                    (cond
                     ((= (line-number-at-pos) selected-start-line)
                      (progn
                        (beginning-of-line)
                        (set-mark-command nil)
                        (end-of-line)
                        (apply orig-fun args)
                        (end-of-line)
                        ))
                     ((= (+ (line-number-at-pos) 1) selected-start-line)
                      (progn
                        (apply orig-fun args)
                        (beginning-of-line)
                        (set-mark-command nil)
                        (end-of-line)))
                     ((< (line-number-at-pos) selected-start-line)
                      (apply orig-fun args))
                     (t 
                      (progn
                        (apply orig-fun args)
                        (end-of-line)))
                     )
                  (apply orig-fun args))))

  (advice-add 'previous-line :around
              (lambda (orig-fun &rest args)
                (interactive)
                (if (< (line-number-at-pos) selected-start-line)
                    (setq extra-line-after-yank t)
                  (setq extra-line-after-yank nil))
                (if my/line-selection-p
                    (cond 
                     ((= (line-number-at-pos) selected-start-line)
                      (progn
                        (end-of-line)
                        (set-mark-command nil)
                        (beginning-of-line)
                        (apply orig-fun args)
                        (beginning-of-line)))
                     ((> (line-number-at-pos) selected-start-line)
                      (apply orig-fun args)
                      (end-of-line))		   
                     ((= (- (line-number-at-pos) 1) selected-start-line)
                      (progn 
                      (apply orig-fun args)
                      (end-of-line)
                      (set-mark-command nil)
                      (beginning-of-line)))
                     (t
                      (progn
                        (apply orig-fun args)
                        (beginning-of-line))))
                  (apply orig-fun args))))
  ;; (advice-mapc `(lambda (fun props) (advice-remove 'previous-line fun)) 'previous-line)
#+end_src

*** pseudo visual line
have a variable for us to know if we're in the a pseudo line selection or normal selection
#+begin_src elisp  
  (setq my/line-selection-p nil)
  (setq my/lines-selected 0)

  (add-hook 'deactivate-mark-hook (lambda () (setq my/line-selection-p nil)))

  (defun my/select-lines (arg)
    "go to beginning of line and select rectangle mark and also set line selection flag"
    (interactive "p")
    (setq my/line-selection-p t)
    (beginning-of-line)
    (set-mark-command nil)
    (end-of-line))

  (defun my/set-mark-command (arg)
    "set mark, and also unset line selection flag"
    (interactive "P")
    (setq my/line-selection-p nil)
    (set-mark-command arg))

  (defun my/visual-block (arg)
    "set rectangle mark, and also unset line selection flag"
    (interactive "P")
    (setq my/line-selection-p nil)
    (rectangle-mark-mode arg))
#+end_src

v or V will set that line selection var accordingly
deactivate mark on esc
#+begin_src elisp
  (define-key viper-vi-basic-map "v" nil)
  (define-key viper-vi-basic-map "v" #'my/set-mark-command)
  (define-key viper-vi-basic-map "V" nil)
  (define-key viper-vi-basic-map "V" #'my/select-lines)
  (define-key viper-vi-basic-map "\C-v" #'my/visual-block)
#+end_src

*** viper-ex to automatically use region if active
#+begin_src elisp
  ;;(advice-mapc `(lambda (fun props) (advice-remove 'viper-ex fun)) 'viper-ex)
  (advice-add 'viper-ex :around
              (lambda (orig-fun &rest args)
                (let ((current-prefix-arg t))
                  (if (use-region-p) (apply orig-fun current-prefix-arg args)
                    (apply orig-fun args)))))
#+end_src

*** join lines on selected region
if the region exists then we jump to the beginning of the region and merge the number of lines selected
#+begin_src elisp
  ;; (advice-mapc `(lambda (fun props) (advice-remove 'viper-join-lines fun)) 'viper-join-lines)
  (advice-add 'viper-join-lines :around
              (lambda (orig-fun arg &rest args)
                (interactive "P")
                (if (use-region-p)
                    (let* ((start (region-beginning))
                          (end (region-end))
                          (numlines (count-lines start end)))
                      (goto-char start)
                      (apply orig-fun `(,numlines)))
                  (apply orig-fun `(,arg)))))
#+end_src

*** hacky stuff to make yanking/killing work for our line visual selection
#+begin_src elisp
  (setq my/line-yank-p nil)
  (defun viper-delete-region-or-motion-command (arg)
    "convenience function for deleting a region, including rectangles"
    (interactive "P")
    (if (use-region-p)
        (let ((start (region-beginning)) (end (region-end)))
          (if rectangle-mark-mode
              (kill-rectangle start end arg)
            (progn
              (forward-char)
              (if my/line-selection-p
                  (setq my/line-yank-p t)
                (setq my/line-yank-p nil))
              (kill-region start end t))))
      (viper-command-argument arg)))

  (defun viper-copy-region-or-motion-command (arg)
    "convenience function for yanking a region, including rectangles"
    (interactive "P")
    (if (use-region-p)
        (let ((start (region-beginning)) (end (region-end)))
          (if rectangle-mark-mode
              (copy-rectangle-as-kill start end)
            (progn
              (forward-char)
              (if my/line-selection-p
                  (setq my/line-yank-p t)
                (setq my/line-yank-p nil))
              (copy-region-as-kill start end t)
              (backward-char))
            ))
      (viper-command-argument arg)))

  (defun viper-paste-into-region (arg)
    "if region is active, delete region before pasting
  respects rectangle mode in a similar way to vim/doom"
    (interactive "P")
    (cond (my/line-yank-p
           (progn
             (viper-open-line nil)
             (viper-change-state-to-vi)
             (when (use-region-p) (delete-active-region))
             (yank)
             (forward-line)))
          ((and (not killed-rectangle) (use-region-p))
           (progn
             (let ((start (region-beginning)))
               (forward-char)
               (delete-active-region)
               (yank))))
          (killed-rectangle
           (progn 
             (yank-rectangle)
             (setq killed-rectangle nil)))
          (t (yank arg))))

  (define-key viper-vi-basic-map "d" #'viper-delete-region-or-motion-command)
  (define-key viper-vi-basic-map "y" #'viper-copy-region-or-motion-command)
  (define-key viper-vi-basic-map "p" #'viper-paste-into-region)
#+end_src

** undo
thank god for undo-only but emacs > 28 only
need to remap isearch-backward since i wanna use C-r for redo
#+begin_src elisp
  (define-key viper-vi-basic-map "u" #'undo-only)
  (define-key viper-vi-basic-map (kbd "C-r") #'undo-redo)
  (define-key viper-vi-basic-map (kbd "C-M-r")  #'isearch-backward)
#+end_src

** "g" prefix commands
*** beginning of buffer
#+begin_src elisp
  (setq my/g-prefix-map (make-sparse-keymap))
  (define-key viper-vi-basic-map "g" my/g-prefix-map)
  (define-key my/g-prefix-map "g" (lambda () (interactive) (viper-goto-line 1)))
#+end_src

*** movement since we have visual lines
#+begin_src elisp
  (define-key my/g-prefix-map "k" #'viper-previous-line)
  (define-key my/g-prefix-map "j" #'viper-next-line)
#+end_src
*** tab bar movement
#+begin_src elisp
  (define-key my/g-prefix-map "t" #'tab-bar-switch-to-next-tab)
  (define-key my/g-prefix-map "T" #'tab-bar-switch-to-prev-tab)
#+end_src

*** cua mode for multiple cursors
#+begin_src elisp
  (define-key my/g-prefix-map "zz" #'cua-rectangle-mark-mode)
#+end_src

** pseudo "leader" prefix
TODO imenu keybinding
#+begin_src elisp
    (setq my/leader-prefix-map (make-sparse-keymap))
    (define-key viper-vi-basic-map " " my/leader-prefix-map)

    (define-key my/leader-prefix-map ","
                (lambda () (interactive) (project-switch-to-buffer (project--read-project-buffer))))
    (define-key my/leader-prefix-map "<" #'switch-to-buffer)
              
    (define-key my/leader-prefix-map "u" #'universal-argument)
    (define-key universal-argument-map " u" #'universal-argument-more)

    (define-key my/leader-prefix-map "F" #'project-find-file)
    (define-key my/leader-prefix-map "G" #'project-find-regexp) ;; good enough
#+end_src

*** "open" prefix
#+begin_src elisp
  (define-key my/leader-prefix-map "oe" #'eshell)
  (define-key my/leader-prefix-map "os" #'shell)
#+end_src

*** "project" prefix
#+begin_src elisp
  (define-key my/leader-prefix-map "pp" #'project-switch-project)
  (define-key my/leader-prefix-map "pe" #'project-eshell)
  (define-key my/leader-prefix-map "ps" #'project-shell)
  (define-key my/leader-prefix-map "pd" #'project-forget-project)
#+end_src

*** "help" prefix
#+begin_src elisp
  (define-key my/leader-prefix-map "hk" #'describe-key)
  (define-key my/leader-prefix-map "hf" #'describe-function)
  (define-key my/leader-prefix-map "hv" #'describe-variable)
  (define-key my/leader-prefix-map "hm" #'describe-mode)
  (define-key my/leader-prefix-map "ho" #'describe-symbol)
#+end_src

*** "buffer" prefix
#+begin_src elisp
  (define-key my/leader-prefix-map "br" #'revert-buffer)
  (define-key my/leader-prefix-map "bp" #'previous-buffer)
  (define-key my/leader-prefix-map "bn" #'next-buffer)
  (define-key my/leader-prefix-map "bi" #'ibuffer)
#+end_src

*** "tab" bar prefix
#+begin_src elisp
  (define-key my/leader-prefix-map "\tn" #'tab-bar-new-tab)
  (define-key my/leader-prefix-map "\td" #'tab-bar-close-tab)
  (define-key my/leader-prefix-map "\tr" #'tab-bar-rename-tab)
#+end_src 

*** "search" prefix
#+begin_src elisp
  (define-key my/leader-prefix-map "ss" #'my/ioccur)
  (define-key my/leader-prefix-map "si" #'imenu)
#+end_src

*** "notes" prefix (bookmarks)
in lieu of org-roam, use bookmarks
pretty handy tbh
**** simple project bookmarks
#+begin_src elisp
(setq bookmark-use-annotations t)

; note the call-interactively does pass the prefix args
(defun my/set-project-bookmark ()
  (interactive)
  (minibuffer-with-setup-hook
      (lambda ()
        (let ((prefix (concat (project-name (project-current)) ": ")))
          (when (project-name (project-current))
            (insert prefix))))
        (call-interactively 'bookmark-set))
)

(defun my/jump-to-project-bookmark ()
  (interactive)
  (minibuffer-with-setup-hook
      (lambda ()
        (let ((prefix (concat (project-name (project-current)) ": ")))
          (when (project-name (project-current))
            (insert prefix))))
        (call-interactively 'bookmark-jump))
)
#+end_src

#+begin_src elisp
  (setq bookmark-save-flag 1)
  (setq bookmark-use-annotations t)
  (setq bookmark-automatically-show-annotations nil)

  (define-key my/leader-prefix-map "nrf" #'my/jump-to-project-bookmark)
  (define-key my/leader-prefix-map "nrl" #'list-bookmarks)
  (define-key my/leader-prefix-map "nri" #'bookmark-set)
  (define-key my/leader-prefix-map "nrn" #'bookmark-set)
  (define-key my/leader-prefix-map "nrd" #'bookmark-delete)
  (define-key my/leader-prefix-map "bmm" #'my/set-project-bookmark)
  (define-key my/leader-prefix-map "bmj" #'my/jump-to-project-bookmark)
#+end_src

*** pseudo "files" "f" prefix
#+begin_src elisp
    (define-key my/leader-prefix-map "ff" #'find-file)
#+end_src

** viper motion keymap
TBD for use in specific major mode keymaps so we at least keep motions
in special modes
#+begin_src elisp
  (setq my/viper-vi-basic-motion-keymap (make-sparse-keymap))
  (define-key my/viper-vi-basic-motion-keymap "h" #'viper-backward-char)
  (define-key my/viper-vi-basic-motion-keymap "l" #'viper-forward-char)
  (define-key my/viper-vi-basic-motion-keymap "j" #'next-line)
  (define-key my/viper-vi-basic-motion-keymap "k" #'previous-line)
  (define-key my/viper-vi-basic-motion-keymap "w" #'viper-forward-word)
  (define-key my/viper-vi-basic-motion-keymap "b" #'viper-backward-word)
  (define-key my/viper-vi-basic-motion-keymap "e" #'viper-end-of-word)
#+end_src

I might be able to live without these ones so they can be overriden
#+begin_src elisp
  (setq my/viper-vi-extra-motion-keymap my/viper-vi-basic-motion-keymap)
  (define-key my/viper-vi-extra-motion-keymap "W" #'viper-forward-Word)
  (define-key my/viper-vi-extra-motion-keymap "B" #'viper-backward-Word)
  (define-key my/viper-vi-extra-motion-keymap "E" #'viper-end-of-Word)

  (define-key my/viper-vi-extra-motion-keymap "f" #'viper-find-char-forward)
  (define-key my/viper-vi-extra-motion-keymap "F" #'viper-find-char-backward)
  (define-key my/viper-vi-extra-motion-keymap "t" #'viper-goto-char-forward)
  (define-key my/viper-vi-extra-motion-keymap "T" #'viper-goto-char-backward)
#+end_src

** eglot/xref
#+begin_src elisp
  (define-key my/leader-prefix-map "cd" #'xref-find-definitions)
  (define-key viper-vi-basic-map "gd" #'xref-find-definitions)

  (define-key my/leader-prefix-map "cD" #'xref-find-references)
  (define-key viper-vi-basic-map "gD" #'xref-find-references)
#+end_src

#+begin_src elisp
  (define-key my/leader-prefix-map "cf" #'eglot-format-buffer)
  (define-key my/leader-prefix-map "xf" #'eglot-format-buffer)
  (define-key my/leader-prefix-map "ca" #'eglot-code-actions)
#+end_src

** development
#+begin_src elisp
  (define-key viper-vi-basic-map "K" #'eldoc)
#+end_src

** window positioning commands
*** respect scroll margin
#+begin_src elisp
  (define-key viper-vi-basic-map "H"
              (lambda (arg) (interactive "P")
                (if arg (viper-window-top arg)
                  (viper-window-top (+ scroll-margin 1)))))
  (define-key viper-vi-basic-map "L"
              (lambda (arg) (interactive "P")
                (if arg (viper-window-bottom arg)
                  (viper-window-bottom (+ scroll-margin 1)))))
  (define-key viper-vi-basic-map "zz" #'recenter-top-bottom)
#+end_src

*** goto line not deactivating mark
#+begin_src elisp
  (advice-mapc `(lambda (fun props) (advice-remove 'viper-goto-line fun)) 'viper-goto-line)
  (advice-add 'viper-goto-line :around
              (lambda (orig-fun &rest args)
                (cl-letf (((symbol-function 'deactivate-mark) (lambda (&optional _) nil)))
                  (apply orig-fun args))))

#+end_src

** code folding
#+begin_src elisp
  (add-hook 'prog-mode-hook #'hs-minor-mode)
  (define-key viper-vi-basic-map "zC" #'hs-hide-all)
  (define-key viper-vi-basic-map "zO" #'hs-show-all)
  (define-key viper-vi-basic-map "zo" #'hs-show-block)
  (define-key viper-vi-basic-map "zc" #'hs-hide-block)
  (define-key viper-vi-basic-map "za" #'hs-toggle-hiding)
#+end_src

** advise viper-brac/ket-function
holy shit lol..
viper-cmd.el:viper-brac-function or viper-ket-function

basically dynamically binding the read-char to return the initial read-char in the viper call so that we don't double prompt user for read-char

TODO: maybe make an easier way to add new bindings
otherwise this works lol
#+begin_src elisp
  ;; [ - backwards
  (advice-mapc `(lambda (fun props) (advice-remove 'viper-brac-function fun)) 'viper-brac-function)
  (advice-add 'viper-brac-function :around
              (lambda (orig-fun &rest args)
                (let ((char (read-char)))
                  (cond ((viper= ?b char) (previous-buffer))
                        ((viper= ?t char) (tab-bar-switch-to-prev-tab))
                        (t
                         ;; hack so that we can override read-char and only need input once
                         (cl-letf (((symbol-function 'read-char) (lambda (_ _ _) char)))
                           (apply orig-fun args)
                           )
                         )
                        ))))
  ;; ] - forwards
  (advice-mapc `(lambda (fun props) (advice-remove 'viper-key-function fun)) 'viper-key-function)
  (advice-add 'viper-ket-function :around
              (lambda (orig-fun &rest args)
                (let ((char (read-char)))
                  (cond ((viper= ?b char) (next-buffer))
                        ((viper= ?t char) (tab-bar-switch-to-next-tab))
                        (t
                         ;; hack so that we can override read-char and only need input once
                         (cl-letf (((symbol-function 'read-char) (lambda (_ _ _) char)))
                           (apply orig-fun args)
                           )
                         )
                        ))))
#+end_src

** extra VC keybindings
#+begin_src elisp
  (define-key global-map "\C-xvf" #'vc-pull)
  (define-key global-map "\C-xvF" #'my/vc-git-fetch)

  (define-key global-map "\C-xv\C-ri" #'my/vc-git-rebase-i)
  (define-key global-map "\C-xv\C-ra" #'my/vc-git-rebase-abort)
  (define-key global-map "\C-xv\C-rc" #'my/vc-git-rebase-continue)
  (use-package vc-git :defer t
    :config
    (setq my/vc-log-vi-state-modify-map
	  (make-composed-keymap my/viper-vi-basic-motion-keymap vc-git-log-view-mode-map))
    (viper-modify-major-mode 'vc-git-log-view-mode 'vi-state my/vc-log-vi-state-modify-map))
#+end_src

*** VC Dir mode
#+begin_src elisp
  (use-package vc-dir :defer t
    :config
    (setq my/vc-dir-vi-state-modify-map
          (make-composed-keymap my/viper-vi-basic-motion-keymap vc-dir-mode-map))
    (viper-modify-major-mode 'vc-dir-mode 'vi-state my/vc-dir-vi-state-modify-map))
#+end_src

** dired
#+begin_src elisp
  (use-package dired :defer t
    :config
    (setq my/dired-vi-state-modify-map
          (make-composed-keymap my/viper-vi-basic-motion-keymap dired-mode-map))
    (viper-modify-major-mode 'dired-mode 'vi-state my/dired-vi-state-modify-map)
    )
#+end_src

** elisp eval buffer
#+begin_src elisp
  (setq my/elisp-vi-state-modify-map (make-sparse-keymap))
  (define-key my/elisp-vi-state-modify-map " meb" #'eval-buffer)
  (viper-modify-major-mode 'emacs-lisp-mode 'vi-state my/elisp-vi-state-modify-map)
#+end_src
* Org

grabbed the src block fontification from here
https://orgmode.org/worg/org-contrib/babel/examples/fontify-src-code-blocks.html

Just a bunch of convenience keymaps, some faces, and some basic settings
#+begin_src elisp
  (setq org-directory "~/orgmode/")
  (setq org-attach-id-dir (concat (file-name-as-directory org-directory) (file-name-as-directory ".attach")))
  (setq org-todo-keywords '((sequence "TODO(t)" "WIP(w)" "|" "DONE" "CANCELLED")))
  (setq org-attach-use-interitance t)

  (setq org-startup-indented t)
  (setq org-indent-indentation-per-level 4)

  ;; allow dabbrev expand on tab when in insert mode
  (defun line-before-point-empty-p ()
    (string-blank-p (buffer-substring-no-properties (point-at-bol) (point))))

  (use-package org
    :config
    (progn
      (setq org-image-actual-width '(300))
      (setq org-goto-interface 'outline-path-completionp)
      (setq org-outline-path-complete-in-steps nil)
      (setq org-return-follows-link t)
      (setq my/org-vi-state-modify-map (make-sparse-keymap))

      (define-key my/org-vi-state-modify-map "zi" #'org-toggle-inline-images)
      (define-key my/org-vi-state-modify-map " si" #'org-goto)
      (define-key my/org-vi-state-modify-map " oaa" #'org-agenda)

      (define-key my/org-vi-state-modify-map " msl" #'org-demote-subtree)
      (define-key my/org-vi-state-modify-map " msh" #'org-promote-subtree)

      (define-key my/org-vi-state-modify-map " maa" #'org-attach)
      (define-key my/org-vi-state-modify-map " mA" #'org-archive-subtree)

      (define-key my/org-vi-state-modify-map " mds" #'org-schedule)
      (define-key my/org-vi-state-modify-map " mdd" #'org-deadline)

      (define-key my/org-vi-state-modify-map " msr" #'org-refile)

      (define-key my/org-vi-state-modify-map " mll" #'org-insert-link)
      (define-key my/org-vi-state-modify-map " nl" #'org-store-link)

      (viper-modify-major-mode 'org-mode 'vi-state my/org-vi-state-modify-map)

      (define-key org-mode-map "\t"
                  (lambda (arg)
                    (interactive "P")
                    (if (and (not (line-before-point-empty-p)) (string= viper-current-state "insert-state"))
                        (dabbrev-expand arg)
                      (org-cycle arg))))))
#+end_src

* (blasphemy) external packages
Need to install these seperately, but some configuration here
These packages are all good enough to be built in to be honest

Lets at least stick with gnu/nongnu elpa

** orderless
https://github.com/oantolin/orderless
I like orderless too much, and it's not too complicated of a package.
#+begin_src elisp
  (use-package orderless :ensure nil :pin gnu
    :config
    (setq completion-styles '(orderless basic) completion-category-overrides '((file (styles basic partial-completion))))
    (defun my-icomplete-styles () (setq-local completion-styles '(orderless)))
    (add-hook 'icomplete-minibuffer-setup-hook 'my-icomplete-styles)
    (define-key minibuffer-local-completion-map " " #'self-insert-command))
#+end_src

** avy
avy jumping is so nice
https://github.com/abo-abo/avy
#+begin_src elisp
  (use-package avy :ensure nil :pin gnu
    :config
    (define-key viper-vi-basic-map "gss" #'avy-goto-char-2)
    (define-key viper-vi-basic-map "gs/" #'avy-goto-char-timer))
#+end_src

** which key
amazing package when I forget my own keybindings
https://github.com/justbur/emacs-which-key
#+begin_src elisp
  (use-package which-key :ensure nil :pin gnu
    :config
    (which-key-mode))
#+end_src

** my own hurl mode :)
well this oen is self explanatory
#+begin_src elisp
  (when (not (require 'hurl-mode nil 'noerrror))
    (package-vc-install "https://github.com/JasZhe/hurl-mode"))
  (use-package hurl-mode :mode "\\.hurl\\'")
#+end_src

** my own window stool mode :)
#+begin_src elisp
  (when (not (require 'window-stool nil 'noerrror))
    (package-vc-install "https://github.com/JasZhe/window-stool"))
  (use-package window-stool
    :config
    (add-hook 'prog-mode-hook #'window-stool-mode)
    (add-hook 'org-mode-hook #'window-stool-mode))
#+end_src

** web mode
#+begin_src elisp
  (use-package web-mode :ensure nil :pin gnu :defer t
    :mode "\\.gohtml\\'"
    :config
    (setq web-mode-engines-alist '(("go" . "\\.gohtml\\'") ("svelte" . "\\.svelte\\'")))
    )
#+end_src

** pdf tools
#+begin_src elisp
  (use-package pdf-tools :ensure nil :pin gnu
    :config
      (setq my/pdf-vi-state-modify-map (make-sparse-keymap))
      (define-key my/pdf-vi-state-modify-map "o" #'pdf-outline)
      (define-key my/pdf-vi-state-modify-map "H" #'pdf-view-fit-height-to-window)
      (define-key my/pdf-vi-state-modify-map "W" #'pdf-view-fit-width-to-window)
      (setq pdf-view-resize-factor 1.10)
      (define-key my/pdf-vi-state-modify-map "+" #'pdf-view-enlarge)
      (define-key my/pdf-vi-state-modify-map "-" #'pdf-view-shrink)

      (viper-modify-major-mode 'pdf-view-mode 'vi-state my/pdf-vi-state-modify-map)
    )
#+end_src

** magit
I want to actually learn how to use the built in vc mode a lot more, but there are some cases where having magit is really nice i.e. rebasing or staging specific lines rather than the whole file.
#+begin_src elisp
    (use-package magit :ensure nil :pin gnu
      :config
      (define-key my/leader-prefix-map "gg" #'magit)
      (setq my/magit-vi-state-modify-map
            (make-composed-keymap my/viper-vi-basic-motion-keymap magit-mode-map))

      (viper-modify-major-mode 'magit-status-mode 'vi-state my/magit-vi-state-modify-map)
      )
#+end_src

* Local variables                                                        
;; Local Variables:                                                      
;; eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle)) nil t)
;; End:                                                                  

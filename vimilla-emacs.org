#+title: Minimalistic Vim Flavoured Emacs Config
#+PROPERTY: header-args :tangle yes :comments link :mkdirp yes

* Mac settings
if machine isn't a mac then this won't do anything anyways so need to do some OS version check or whatever
#+begin_src elisp
  (setq mac-option-modifier 'meta)
#+end_src

* General Settings
enable fido-vertical mode, viper mode, global hl and visual lines
stole the completing read stuff from:
https://www.reddit.com/r/emacs/comments/zl6amy/completionatpoint_using_completingread_icomplete/

#+begin_src elisp
  (setq viper-mode t)
  (require 'viper)
  (require 'rect)
  (fido-vertical-mode)
  (viper-mode)
  (global-hl-line-mode)
  (global-visual-line-mode)

  (keymap-set minibuffer-local-completion-map "TAB" #'icomplete-force-complete)
  (keymap-set global-map "C-z" #'viper-mode) ;; C-z to suspend frame is annoying with viper

  (setq scroll-margin 8)
  (setq visual-bell t)
  (setq ring-bell-function 'ignore)
  (setq scroll-preserve-screen-position t)
#+end_src

** Searching
#+begin_src elisp
  (advice-mapc `(lambda (fun props) (advice-remove 'isearch-printing-char fun)) 'isearch-printing-char)
  (advice-add #'isearch-printing-char :after
              (lambda (&rest args)
                (if isearch-regexp (isearch-occur isearch-regexp)
                  (isearch-occur isearch-string))))
#+end_src

** in buffer completion
#+begin_src elisp
  (setq enable-recursive-minibuffers t)
  (defun completing-read-in-region (start end collection &optional predicate)
     "Prompt for completion of region in the minibuffer if non-unique.
    Use as a value for `completion-in-region-function'."
     (let* ((initial (buffer-substring-no-properties start end))
            (all (completion-all-completions initial collection predicate
                                             (length initial)))
            (completion (cond
                         ((atom all) nil)
                         ((and (consp all) (atom (cdr all))) (car all))
                         (t (completing-read
                             "Completion: " collection predicate t initial)))))
       (cond (completion (completion--replace start end completion) t)
             (t (message "No completion") nil))))
   (setq completion-in-region-function #'completing-read-in-region)
#+end_src

** xref
luckily this is built in lol
#+begin_src elisp
  (use-package xref
    :config
    (progn
      (setq xref-search-program 'ripgrep)
      (setq xref-show-xrefs-function #'xref-show-definitions-completing-read)      
      (setq xref-show-definitions-function #'xref-show-definitions-completing-read)
      )
    )

  (defun iproject-search () (interactive)                                                                        
         (let ((shk-search-string isearch-string))                                                     
           (project-find-regexp (if isearch-regexp shk-search-string (regexp-quote shk-search-string)))
           (isearch-abort)))
  (define-key isearch-mode-map (kbd "M-s g") #'iproject-search)
#+end_src

** some more basic elisp highlighting
#+begin_src elisp
    (defface font-lock-func-face 
      '((nil (:foreground "#7F0055" :weight bold))
        (t (:bold t :italic t)))
    "Font Lock mode face used for function calls."
    :group 'font-lock-highlighting-faces)

  (font-lock-add-keywords
   'emacs-lisp-mode
   '(("(\\s-*\\(\\_<\\(?:\\sw\\|\\s_\\)+\\)\\_>"
      1 'font-lock-constant-face)) 'append)

  (defun my-fl (_limit)
    (let ((opoint  (point))
          (found   nil))
      (with-syntax-table emacs-lisp-mode-syntax-table
        (while (not found)
          (cond ((condition-case ()
                     (save-excursion
                       (skip-chars-forward "'")
                       (setq opoint  (point))
                       (let ((obj  (read (current-buffer))))
                         (and (symbolp obj)  (fboundp obj)
                              (progn (set-match-data (list opoint (point))) t))))
                   (error nil))
                 (forward-sexp 1)
                 (setq opoint  (point)
                       found   t))
                (t
                 (if (looking-at "\\(\\sw\\|\\s_\\)")
                     (forward-sexp 1)
                   (forward-char 1)))))
        found)))

  ;; (add-hook 'emacs-lisp-mode-hook
  ;; 	  (lambda ()
  ;; 	    (font-lock-add-keywords nil
  ;; 				    '((my-fl . 'font-lock-constant-face)) 'append)))
#+end_src
           
* Tab bar
basically minimal projectile and persp
#+begin_src elisp
  (defun find-git-dir (dir)
   "Search up the directory tree looking for a .git folder."
   (cond
    ((eq major-mode 'dired-mode) "Dired")
    ((not dir) "process")
    ((string= dir "/") "no-git")
    (t (vc-root-dir))))

  (defun git-tabbar-buffer-groups ()
    "Groups tabs in tabbar-mode by the git repository they are in."
    (list (find-git-dir (buffer-file-name (current-buffer)))))
  ;; (setq tabbar-buffer-groups-function 'git-tabbar-buffer-groups)
#+end_src


* Viper
:PROPERTIES:
:header-args: :tangle ~/.emacs.d/viper :comments link 
:END:
viper is the only built in thing that handles /some/ of the Doom/Vim stuff that I want (since it emulates Vi and not Vim)


** vi state stuff
hacky global var to have a "global" viper state
is this better than the default behavior?
Maybe.. maybe not but now this should enable viper mode even on major modes not specified by viper itself
#+begin_src elisp

  (setq my/global-viper-state 'vi)
  (defun set-global-viper-state (arg)
    (cond ((eq my/global-viper-state 'vi) (viper-change-state-to-vi))
          ((eq my/global-viper-state 'emacs) (viper-change-state-to-emacs))
          ((eq my/global-viper-state 'ins) (viper-change-state-to-insert))
          (t (viper-change-state-to-vi))
    ))
  (add-to-list 'window-state-change-functions #'set-global-viper-state)
#+end_src

want backspace in insert deletes to previous line when curr line is empty
want some indication of which mode we're in outside of the modeline

stole the terminal code for cursor from here https://github.com/syl20bnr/spacemacs/issues/7112#issuecomment-389855491
works on iterm2 at least, 0 for box, 6 for bar cursor
#+begin_src elisp
  (setq viper-inhibit-startup-message 't)
  (setq viper-expert-level '5)

  (add-hook 'viper-insert-state-hook (lambda ()
                                       (global-hl-line-mode -1)
                                       (setq my/global-viper-state 'ins)
                                       (when (not (display-graphic-p)) (send-string-to-terminal "\033[6 q"))
                                       (setq viper-ex-style-editing nil)))

  ;; otherwise hl-line-mode stays off after running an ex command like :w
  (add-hook 'viper-minibuffer-exit-hook (lambda () (global-hl-line-mode) (when (not (display-graphic-p)) (send-string-to-terminal "\033[0 q"))))

  (add-hook 'viper-minibuffer-exit-hook #'viper-change-state-to-vi)
  (add-hook 'viper-vi-state-hook (lambda ()
                                   (global-hl-line-mode)
                                   (setq my/global-viper-state 'vi)
                                   (set-face-attribute 'hl-line nil :background "LightCyan1")
                                   (when (not (display-graphic-p)) (send-string-to-terminal "\033[0 q"))))
  (add-hook 'viper-emacs-state-hook (lambda ()
                                      (global-hl-line-mode)
                                      (setq my/global-viper-state 'emacs)
                                      (set-face-attribute 'hl-line nil :background "LavenderBlush1")
                                      (when (not (display-graphic-p)) (send-string-to-terminal "\033[0 q"))))

  (add-hook 'minibuffer-mode-hook #'viper-change-state-to-insert)
  (add-hook 'minibuffer-exit-hook #'viper-change-state-to-vi)
  (setq viper-insert-state-cursor-color nil)
#+end_src

*** want better normal state bindings in the "emacs state" buffers
#+begin_src elisp

  ;; prefer the following to be in whatever state I'm already in                                       
  (setq viper-emacs-state-mode-list (remove 'Custom-mode viper-emacs-state-mode-list))                 
  (setq viper-emacs-state-mode-list (remove 'dired-mode viper-emacs-state-mode-list))                  
  (setq viper-emacs-state-mode-list (remove 'occur-mode viper-emacs-state-mode-list))                  
  (setq viper-emacs-state-mode-list (remove 'help-mode viper-emacs-state-mode-list))                   
  (setq viper-emacs-state-mode-list (remove 'completion-list-mode viper-emacs-state-mode-list))

  ;; then remove all emacs states and replace with insert states                                       
  (setq viper-insert-state-mode-list (append viper-emacs-state-mode-list viper-insert-state-mode-list))

  
#+end_src
** help commands
qol to use c-h for help commands, and something for us to type faster
#+begin_src elisp
  (setq viper-want-ctl-h-help 't)
  (setq viper-fast-keyseq-timeout 100)
#+end_src

** better esp handling
better ESC key handling to exit visual mode and close mini buffer
#+begin_src elisp
  (advice-add 'viper-intercept-ESC-key :after #'deactivate-mark)
  (advice-add 'viper-intercept-ESC-key :after (lambda () (ignore-errors (abort-minibuffers))))
  (advice-add 'viper-intercept-ESC-key :after (lambda () (ignore-errors (cua-clear-rectangle-mark))))
#+end_src

** pop mark navigation
#+begin_src elisp
    (define-key viper-vi-basic-map "\C-o" #'pop-global-mark)
                ;;(lambda () (interactive) (let ((current-prefix-arg t)) (set-mark-command current-prefix-arg))))
#+end_src

** respect visual lines cursor movement
#+begin_src elisp
(define-key viper-vi-basic-map "k" #'previous-line)
(define-key viper-vi-basic-map "j" #'next-line)
#+end_src

** forward "enter" and "q" in vi state
good enough solution without getting too complicated
we never really type these in normal mode anyways
and these are pretty useful in some buffers

default behavior of the enter key is pretty meh anyways
#+begin_src elisp
  (define-key viper-vi-basic-map (kbd "RET") nil)
  (define-key viper-vi-basic-map "q" nil)
#+end_src

** Window movement
TODO resizing functions
also zz and stuff to center screen
not necessary viper, but same idea
#+begin_src elisp
  (define-key global-map (kbd "C-w") nil)

  (define-key global-map "\C-wv" #'split-window-horizontally)
  (define-key global-map "\C-wq" #'delete-window)
  (define-key global-map "\C-w\C-w" #'other-window)

  (define-key global-map "\C-wl" #'windmove-right)
  (define-key global-map "\C-w\C-l" #'windmove-right)

  (define-key global-map "\C-wh" #'windmove-left)
  (define-key global-map "\C-w\C-h" #'windmove-left)

  (define-key global-map "\C-wk" #'windmove-up)
  (define-key global-map "\C-w\C-k" #'windmove-up)

  (define-key global-map "\C-wj" #'windmove-down)
  (define-key global-map "\C-w\C-j" #'windmove-down)

  (define-key global-map "\C-w=" #'balance-windows)

  (define-key global-map "\C-wo" #'delete-other-windows)
  (define-key global-map "\C-w\C-o" #'delete-other-windows)
#+end_src

** pseudo visual mode
*** hacky advice for next/previous line to emulate visual mode
basically a bunch of mark manipualtion essentially.

a lot of the problem is just around making sure that starting line is always marked, similar to vim
#+begin_src elisp
  (setq selected-start-line -1)
  (add-hook 'activate-mark-hook (lambda () (setq selected-start-line (line-number-at-pos))))
  ;; (advice-mapc `(lambda (fun props) (advice-remove 'next-line fun)) 'next-line)
  (advice-add 'next-line :around
              (lambda (orig-fun &rest args)
                (interactive)
                ;; because now we're not getting the last newline
                (if (< (line-number-at-pos) selected-start-line)
                    (setq extra-line-after-yank t)
                  (setq extra-line-after-yank nil))
	      
                (if my/line-selection-p
                    (cond
                     ((= (line-number-at-pos) selected-start-line)
                      (progn
                        (beginning-of-line)
                        (set-mark-command nil)
                        (end-of-line)
                        (apply orig-fun args)
                        (end-of-line)
                        ))
                     ((= (+ (line-number-at-pos) 1) selected-start-line)
                      (progn
                        (apply orig-fun args)
                        (beginning-of-line)
                        (set-mark-command nil)
                        (end-of-line)))
                     ((< (line-number-at-pos) selected-start-line)
                      (apply orig-fun args))
                     (t 
                      (progn
                        (apply orig-fun args)
                        (end-of-line)))
                     )
                  (apply orig-fun args))))

  (advice-add 'previous-line :around
              (lambda (orig-fun &rest args)
                (interactive)
                (if (< (line-number-at-pos) selected-start-line)
                    (setq extra-line-after-yank t)
                  (setq extra-line-after-yank nil))
                (if my/line-selection-p
                    (cond 
                     ((= (line-number-at-pos) selected-start-line)
                      (progn
                        (end-of-line)
                        (set-mark-command nil)
                        (beginning-of-line)
                        (apply orig-fun args)
                        (beginning-of-line)))
                     ((> (line-number-at-pos) selected-start-line)
                      (apply orig-fun args)
                      (end-of-line))		   
                     ((= (- (line-number-at-pos) 1) selected-start-line)
                      (progn 
                      (apply orig-fun args)
                      (end-of-line)
                      (set-mark-command nil)
                      (beginning-of-line)))
                     (t
                      (progn
                        (apply orig-fun args)
                        (beginning-of-line))))
                  (apply orig-fun args))))
  ;; (advice-mapc `(lambda (fun props) (advice-remove 'previous-line fun)) 'previous-line)
#+end_src

*** pseudo visual line
have a variable for us to know if we're in the a pseudo line selection or normal selection
#+begin_src elisp  
  (setq my/line-selection-p nil)
  (setq my/lines-selected 0)

  (add-hook 'deactivate-mark-hook (lambda () (setq my/line-selection-p nil)))

  (defun my/select-lines (arg)
    "go to beginning of line and select rectangle mark and also set line selection flag"
    (interactive "p")
    (setq my/line-selection-p t)
    (beginning-of-line)
    (set-mark-command nil)
    (end-of-line))

  (defun my/set-mark-command (arg)
    "set mark, and also unset line selection flag"
    (interactive "P")
    (setq my/line-selection-p nil)
    (set-mark-command arg))

  (defun my/visual-block (arg)
    "set rectangle mark, and also unset line selection flag"
    (interactive "P")
    (setq my/line-selection-p nil)
    (rectangle-mark-mode arg))
#+end_src

v or V will set that line selection var accordingly
deactivate mark on esc
#+begin_src elisp
  (define-key viper-vi-basic-map "v" nil)
  (define-key viper-vi-basic-map "v" #'my/set-mark-command)
  (define-key viper-vi-basic-map "V" nil)
  (define-key viper-vi-basic-map "V" #'my/select-lines)
  (define-key viper-vi-basic-map "\C-v" #'my/visual-block)
#+end_src

*** viper-ex to automatically use region if active
#+begin_src elisp
  ;;(advice-mapc `(lambda (fun props) (advice-remove 'viper-ex fun)) 'viper-ex)
  (advice-add 'viper-ex :around
              (lambda (orig-fun &rest args)
                (let ((current-prefix-arg t))
                  (if (use-region-p) (apply orig-fun current-prefix-arg args)
                    (apply orig-fun args)))))
#+end_src

*** join lines on selected region
if the region exists then we jump to the beginning of the region and merge the number of lines selected
#+begin_src elisp
  ;; (advice-mapc `(lambda (fun props) (advice-remove 'viper-join-lines fun)) 'viper-join-lines)
  (advice-add 'viper-join-lines :around
              (lambda (orig-fun arg &rest args)
                (interactive "P")
                (if (use-region-p)
                    (let* ((start (region-beginning))
                          (end (region-end))
                          (numlines (count-lines start end)))
                      (goto-char start)
                      (apply orig-fun `(,numlines)))
                  (apply orig-fun `(,arg)))))
#+end_src

*** hacky stuff to make yanking/killing work for our line visual selection
#+begin_src elisp
  (setq my/line-yank-p nil)
  (defun viper-delete-region-or-motion-command (arg)
    "convenience function for deleting a region, including rectangles"
    (interactive "P")
    (if (use-region-p)
        (let ((start (region-beginning)) (end (region-end)))
          (if rectangle-mark-mode
              (kill-rectangle start end arg)
            (progn
              (forward-char)
              (if my/line-selection-p
                  (setq my/line-yank-p t)
                (setq my/line-yank-p nil))
              (kill-region start end t))))
      (viper-command-argument arg)))

  (defun viper-copy-region-or-motion-command (arg)
    "convenience function for yanking a region, including rectangles"
    (interactive "P")
    (if (use-region-p)
        (let ((start (region-beginning)) (end (region-end)))
          (if rectangle-mark-mode
              (copy-rectangle-as-kill start end)
            (progn
              (forward-char)
              (if my/line-selection-p
                  (setq my/line-yank-p t)
                (setq my/line-yank-p nil))
              (copy-region-as-kill start end t)
              (backward-char))
            ))
      (viper-command-argument arg)))

  (defun viper-paste-into-region (arg)
    "if region is active, delete region before pasting
  respects rectangle mode in a similar way to vim/doom"
    (interactive "P")
    (cond (my/line-yank-p
           (progn
             (viper-open-line nil)
             (viper-change-state-to-vi)
             (yank)
             (forward-line)))
          ((use-region-p)
           (progn 
             (unless rectangle-mark-mode (forward-char))
             (let ((start (region-beginning)))
               (delete-active-region)
               (goto-char start)
               (yank)
               (delete-blank-lines))))
          (killed-rectangle (yank-rectangle))
          (t (yank arg))))

  (define-key viper-vi-basic-map "d" #'viper-delete-region-or-motion-command)
  (define-key viper-vi-basic-map "y" #'viper-copy-region-or-motion-command)
  (define-key viper-vi-basic-map "p" #'viper-paste-into-region)
#+end_src

#+RESULTS:
: viper-paste-into-region

** undo
thank god for undo-only but emacs > 28 only
need to remap isearch-backward since i wanna use C-r for redo
#+begin_src elisp
  (define-key viper-vi-basic-map "u" #'undo-only)
  (define-key viper-vi-basic-map (kbd "C-r") #'undo-redo)
  (define-key viper-vi-basic-map (kbd "C-M-r")  #'isearch-backward)
#+end_src

** "g" prefix commands
#+begin_src elisp
  (setq my/g-prefix-map (make-sparse-keymap))
  (define-key viper-vi-basic-map "g" my/g-prefix-map)
  (define-key my/g-prefix-map "g" #'beginning-of-buffer)
#+end_src

*** movement since we have visual lines
#+begin_src elisp
  (define-key my/g-prefix-map "k" #'viper-previous-line)
  (define-key my/g-prefix-map "j" #'viper-next-line)
#+end_src

*** tab bar movement
#+begin_src elisp
  (define-key my/g-prefix-map "t" #'tab-bar-switch-to-next-tab)
  (define-key my/g-prefix-map "T" #'tab-bar-switch-to-prev-tab)
#+end_src

*** cua mode for multiple cursors
#+begin_src elisp
  (define-key my/g-prefix-map "zz" #'cua-rectangle-mark-mode)
#+end_src

** pseudo "leader" prefix
TODO imenu keybinding
#+begin_src elisp
  (setq my/leader-prefix-map (make-sparse-keymap))
  (define-key viper-vi-basic-map " " my/leader-prefix-map)

  (define-key my/leader-prefix-map ","
              (lambda (arg)
                "switch to project buffer, with prefix argument, switch to any buffer"
                (interactive "P")
                (if arg (ido-switch-buffer)
                  (project-switch-to-buffer (project--read-project-buffer)))))
  (define-key my/leader-prefix-map "u" #'universal-argument)

  (define-key my/leader-prefix-map "F" #'project-find-file)
  (define-key my/leader-prefix-map "G" #'project-find-regexp) ;; good enough
#+end_src

*** "open" prefix
#+begin_src elisp
  (define-key my/leader-prefix-map "oe" #'eshell)
  (define-key my/leader-prefix-map "os" #'shell)
#+end_src

*** "project" prefix
#+begin_src elisp
  (define-key my/leader-prefix-map "pp" #'project-switch-project)
  (define-key my/leader-prefix-map "pe" #'project-eshell)
  (define-key my/leader-prefix-map "ps" #'project-shell)
#+end_src

*** "help" prefix
#+begin_src elisp
  (define-key my/leader-prefix-map "hk" #'describe-key)
  (define-key my/leader-prefix-map "hf" #'describe-function)
  (define-key my/leader-prefix-map "hv" #'describe-variable)
  (define-key my/leader-prefix-map "hm" #'describe-mode)
  (define-key my/leader-prefix-map "ho" #'describe-symbol)
#+end_src

*** "buffer" prefix
#+begin_src elisp
  (define-key my/leader-prefix-map "br" #'revert-buffer)
  (define-key my/leader-prefix-map "bp" #'previous-buffer)
  (define-key my/leader-prefix-map "bn" #'next-buffer)
  (define-key my/leader-prefix-map "bi" #'ibuffer)
#+end_src

*** "tab" bar prefix
#+begin_src elisp
  (define-key my/leader-prefix-map "\tn" #'tab-bar-new-tab)
  (define-key my/leader-prefix-map "\td" #'tab-bar-close-tab)
#+end_src 

*** "search" prefix
#+begin_src elisp
  (define-key my/leader-prefix-map "ss" #'isearch-forward)
  (define-key my/leader-prefix-map "si" #'imenu)
#+end_src

*** "notes" prefix
in lieu of org-roam, use bookmarks
pretty handy tbh
#+begin_src elisp
  (setq bookmark-save-flag 1)
  (setq bookmark-use-annotations t)
  (define-key my/leader-prefix-map "nrf" #'bookmark-jump)
  (define-key my/leader-prefix-map "nrl" #'list-bookmarks)
  (define-key my/leader-prefix-map "nri" #'bookmark-set)
  (define-key my/leader-prefix-map "nrn" #'bookmark-set)
  (define-key my/leader-prefix-map "nrd" #'bookmark-delete)
#+end_src

*** pseudo "files" "f" prefix
#+begin_src elisp
    (define-key my/leader-prefix-map "ff" #'find-file)
#+end_src

** window positioning commands
respect scroll margin
#+begin_src elisp
  (define-key viper-vi-basic-map "H"
              (lambda (arg) (interactive "P")
                (if arg (viper-window-top arg)
                  (viper-window-top (+ scroll-margin 1)))))
  (define-key viper-vi-basic-map "L"
              (lambda (arg) (interactive "P")
                (if arg (viper-window-bottom arg)
                  (viper-window-bottom (+ scroll-margin 1)))))
  (define-key viper-vi-basic-map "zz" #'recenter-top-bottom)
#+end_src

** code folding
#+begin_src elisp
  (hs-minor-mode)
  (define-key viper-vi-basic-map "zC" #'hs-hide-all)
  (define-key viper-vi-basic-map "zO" #'hs-show-all)
  (define-key viper-vi-basic-map "zo" #'hs-show-block)
  (define-key viper-vi-basic-map "zc" #'hs-hide-block)
  (define-key viper-vi-basic-map "za" #'hs-toggle-hiding)
#+end_src

** eglot/xref
#+begin_src elisp
  (define-key my/leader-prefix-map "d" #'xref-find-definitions)
  (define-key my/leader-prefix-map "D" #'xref-find-references)
#+end_src

#+begin_src elisp
    (define-key my/leader-prefix-map "cf" #'eglot-format-buffer)
    (define-key my/leader-prefix-map "xf" #'eglot-format-buffer)
#+end_src

* development
** go use treesit
#+begin_src elisp
(add-to-list 'auto-mode-alist '("\\.go\\'" . go-ts-mode))
#+end_src
* Org

#+begin_src elisp

  (setq org-directory "~/orgmode/")
  (setq org-attach-id-dir (concat (file-name-as-directory org-directory) ".attach"))
  (defface org-block-begin-line
    '((t (:underline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF")))
    "Face used for the line delimiting the begin of source blocks.")

  (defface org-block-background
    '((t (:background "#FFFFEA")))
    "Face used for the source block background.")

  (defface org-block-end-line
    '((t (:overline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF")))
    "Face used for the line delimiting the end of source blocks.")

  (setq org-startup-indented t)
  (setq org-indent-indentation-per-level 4)

  ;; allow dabbrev expand on tab when in insert mode
  (defun line-before-point-empty-p ()
    (string-blank-p (buffer-substring-no-properties (point-at-bol) (point))))

  (use-package org
    :config
    (progn
      (setq org-goto-interface 'outline-path-completionp)
      (setq org-outline-path-complete-in-steps nil)
      (setq my-org-modifier-map (make-sparse-keymap))
      (define-key my-org-modifier-map " si" #'org-goto)
      (define-key my-org-modifier-map " msl" #'org-demote-subtree)
      (define-key my-org-modifier-map " msh" #'org-promote-subtree)
      (viper-modify-major-mode 'org-mode 'vi-state my-org-modifier-map)

      (define-key org-mode-map "\t"
                  (lambda (arg)
                    (interactive "P")
                    (if (and (not (line-before-point-empty-p)) (string= viper-current-state "insert-state"))
                        (dabbrev-expand arg)
                      (org-cycle arg))))))
#+end_src


* Local variables                                                        
;; Local Variables:                                                      
;; eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle)) nil t)
;; End:                                                                  

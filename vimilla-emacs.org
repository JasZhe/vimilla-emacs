#+title: Minimalistic Vim Flavoured Emacs Config
#+PROPERTY: header-args :tangle init.el :results silent :lexical t

* lexical
#+begin_src elisp
;;; -*- lexical-binding: t; -*-
#+end_src

* check if use-package exists
Otherwise we do some hacky thing to make the rest of the config somewhat work
#+begin_src elisp
  (unless (boundp 'package-archives)
    (package-initialize))
#+end_src

#+begin_src elisp
  (require 'cl-lib)
  (unless (fboundp 'use-package)
    (defmacro use-package (&rest body)
      "Very hacky macro to wrap each statement in a"
      `(progn 
      ,@(cl-map 'list
              (lambda (stmt)
                (message "%s" stmt)
                `(ignore-errors ,stmt)
                )
              body
        )
      )
    )
    )
#+end_src

* CANCELLED separate document for keybindings?
I do enjoy having everything in the one file though and a lot of this stuff is not /just/ setting keybinds,
its also doing a lot of elisp stuff that work /with/ the keybinds

* having my own minor mode for keymaps just for the M-<tab> to normal minibuffer optionally after icomplete
#+begin_src elisp
;; Main use is to have my key bindings have the highest priority
;; https://github.com/kaushalmodi/.emacs.d/blob/master/elisp/modi-mode.el

(defvar my-mode-map (make-sparse-keymap)
  "Keymap for `my-mode'.")

;;;###autoload
(define-minor-mode my-mode
  "A minor mode so that my key settings override annoying major modes."
  ;; If init-value is not set to t, this mode does not get enabled in
  ;; `fundamental-mode' buffers even after doing \"(global-my-mode 1)\".
  ;; More info: http://emacs.stackexchange.com/q/16693/115
  :init-value t
  :lighter " my-mode"
  :keymap my-mode-map)

;;;###autoload
(define-globalized-minor-mode global-my-mode my-mode my-mode)

;; https://github.com/jwiegley/use-package/blob/master/bind-key.el
;; The keymaps in `emulation-mode-map-alists' take precedence over
;; `minor-mode-map-alist'
(add-to-list 'emulation-mode-map-alists `((my-mode . ,my-mode-map)))

;; Turn off the minor mode in the minibuffer
(defun turn-off-my-mode ()
  "Turn off my-mode."
  (my-mode -1))
#+end_src

* WIP other git commands that VC doesn't handle like git rebase and stuff
something like this

mainly for these two:
git fetch
git rebase

and need to figure out keymappings

just a simple wrapper in the case where we can't install magit
#+begin_src elisp
  (defun my/vc-git-editor-command (command)
    "command is a git subcommand that requires an editor.
   example usage: (my/vc-git-editor-command \"rebase -i HEAD~3\")"
    (interactive "P")
    (unless server-mode (server-force-delete) (server-mode))
    (let ((command (if command command (read-string "command: git "))))
      (compile (concat "GIT_EDITOR=\"emacsclient\" bash -c \"git " command "\""))))

  (defun my/vc-git-rebase-i (&optional branch)
    "if branch isn't supplied from arg, prompt for it"
    (interactive)
    (let ((revision (if branch branch (read-string "revision: "))))
      (my/vc-git-editor-command (concat "rebase -i " revision))))

  (defun my/vc-git-rebase-abort ()
    (interactive)
    (compile "git rebase --abort"))

  (defun my/vc-git-rebase-continue ()                  
    (interactive)                                 
    (compile "git rebase --continue"))

  (defun my/vc-git-fetch ()                  
    (interactive)                                  
    (compile "git fetch -v"))

  (defun my/vc-get-remote ()
    (let* ((remote-names (split-string (shell-command-to-string "git remote")))
           (remote-urls
            (mapcar (lambda (r)
                      (cons r 
                            (string-trim
                             (shell-command-to-string (concat "git remote get-url " r)))))
                    remote-names))
           (annotation-fn (lambda (candidate) (cdr (assoc candidate remote-urls))))
           (completion-extra-properties `(:annotation-function ,annotation-fn))
           (remote (completing-read "Remote: " remote-urls)))
      remote))

  (defun my/vc-set-remote-url ()
    (interactive)
    (let* ((remote (my/vc-get-remote))
           (curr-url (string-trim
                      (shell-command-to-string (concat "git remote get-url " remote))))

           (new-url (minibuffer-with-setup-hook (lambda () (insert curr-url))
                      (read-string (concat "Set url for remote <" remote ">: ")))))
      (compile (concat "git remote set-url " remote " " new-url))))

  (defun my/vc-set-branch-upstream ()
    (interactive)
    (let* ((remote (my/vc-get-remote))
           (curr-branch (car (vc-git-branches)))
           (upstream (minibuffer-with-setup-hook
                         (lambda () (insert remote "/" curr-branch))
                       (read-string (concat "set branch <" curr-branch "> upstream to: ")))))
      (compile (concat "git branch -u " upstream))))

  (defun my/vc-add-remote ())
  (defun my/vc-delete-remote ())
  (defun my/vc-set-remote-url ())
#+end_src

** git diff for .. or ...
#+begin_src elisp

  (defun vc-git-common-ancestor-diff (files &optional rev1 rev2 buffer _async)
    "Get a difference report using Git between two revisions of FILES."
    (let (process-file-side-effects
          (command "diff"))
      (vc-git--asciify-coding-system)
      (if rev2
          ;; Diffing against the empty tree.
          (unless rev1 (setq rev1 "4b825dc642cb6eb9a060e54bf8d69288fbee4904"))
        (setq command "diff-index")
        (unless rev1 (setq rev1 "HEAD")))
      (if vc-git-diff-switches
          (apply #'vc-git-command (or buffer "*vc-diff*")
             1 ; bug#21969
                 files
                 command
                 "--exit-code"
                 (append (vc-switches 'git 'diff)
                         (list "-p" (concat (or rev1 "HEAD") "..." rev2) "--")))
        (vc-git-command (or buffer "*vc-diff*") 1 files
                        "difftool" "--exit-code" "--no-prompt" "-x"
                        (concat "diff "
                                (mapconcat #'identity
                                           (vc-switches nil 'diff) " "))
                        (concat rev1 "..." rev2) "--"))))

  (defun vc-git-diff-advice (orig-fun &rest args)
    (if (and (eq this-command #'vc-root-version-diff) (not current-prefix-arg))
        (apply #'vc-git-common-ancestor-diff args)
      (apply orig-fun args))
    )
  (advice-add #'vc-git-diff :around #'vc-git-diff-advice)
#+end_src

* convenient alias
org really hates the parens matching when < or > is involved
#+begin_src elisp
  (defalias 'gt #'>)
  (defalias 'gt= #'>=)
  (defalias 'lt #'<)
  (defalias 'lt= #'<=)
  (defun neq (obj1 obj2)
    "Convenience for not 'eq'"
    (not (eq obj1 obj2)))

#+end_src

* ediff-setup
#+begin_src elisp
  (use-package ediff :defer t
    :config
    (advice-remove 'ediff-quit #'disable-y-or-n-p)
    (defun disable-y-or-n-p (orig-fun &rest args)
      (cl-letf (((symbol-function 'y-or-n-p) (lambda (prompt) t)))
        (apply orig-fun args)))
    (advice-add 'ediff-quit :around #'disable-y-or-n-p)

    (setq ediff-keep-variants nil)
    (setq ediff-window-setup-function #'ediff-setup-windows-plain)
    (setq ediff-split-window-function #'split-window-horizontally))
#+end_src

#+begin_src elisp
  (defun vc-ediff-file-at-point ()
    (interactive)
    (when (eq major-mode 'diff-mode)
      (setq my-ediff-prior-window-configuration (current-window-configuration))
      (let ((old-revision (first diff-vc-revisions))
            (new-revision (second diff-vc-revisions))
            (file-to-diff (save-window-excursion
                            (diff-goto-source)
                            (buffer-file-name))))
        (vc-version-ediff `(,file-to-diff) old-revision new-revision))))

  (add-hook 'ediff-quit-hook
            (lambda () (when (window-configuration-p my-ediff-prior-window-configuration)
                         (set-window-configuration my-ediff-prior-window-configuration)))
            100)
#+end_src

* linux settings
#+begin_src elisp
  (when (eq system-type 'gnu/linux)
    (setq x-super-keysym 'meta)
    (setq x-meta-keysym 'super))
#+end_src

* Mac settings
if machine isn't a mac then this won't do anything anyways so need to do some OS version check or whatever

Also keybinds for super key
see the emacs wiki page for how this works:
https://www.emacswiki.org/emacs/iTerm2

Basically go to iterm settings -> keys -> + button to add a keybind
make a keybind for cmd-/ and set it to send an escape sequence for [1;P9
then map that [1;P9 to whatever we want.

The P9 can go to like P56. [1;P9 maps to like CTRL CMD OPTION A, which we probably aren't gonna use lol so it's safe to map that to something more useful
#+begin_src elisp
  (setq mac-option-modifier 'meta)
  (setq mac-command-modifier 'super)
  (define-key global-map (kbd "s-/") #'comment-line)

  ;; terminal stuff, C-/ in case we don't have iterm config
  (define-key global-map (kbd "C-/") #'comment-line)
  (define-key global-map (kbd "C-_") #'comment-line)
  (define-key input-decode-map "\e[1;P9" (kbd "s-/"))

  ;; mac ligatures
  (when (fboundp 'mac-auto-operator-composition-mode)
    (mac-auto-operator-composition-mode))
#+end_src

* terminal settings
#+begin_src elisp
  (defun macos-term-select-text-to-clipboard (text)
    (unless (eq system-type 'gnu/linux)
      (shell-command (concat "echo \"" text "\" | pbcopy" ))))

  ;; ITERM2 MOUSE SUPPORT
  (unless (or window-system (daemonp))
    (require 'mouse)
    (xterm-mouse-mode t)
    (defun track-mouse (e)) 
    (setq mouse-sel-mode t)
    (setq interprogram-cut-function #'macos-term-select-text-to-clipboard)) ;; good enough
#+end_src

* Window commands
:PROPERTIES:
:VISIBILITY: folded
:END:
not necessary viper, but same idea
need to set the window map before viper loads cause we use it in the motion keymap
#+begin_src elisp
  (winner-mode)

  (defun my/set-transparency-in-terminal ()
    (interactive)
    (unless (string= (face-background 'default) "unspecified-bg")
      (setq prev-default-face-bg (face-background 'default)))
    (unless (display-graphic-p (selected-frame))
      (set-face-background 'default "unspecified-bg" (selected-frame))))

  (defun my/unset-transparency-in-terminal ()
    (interactive)
    (unless (display-graphic-p (selected-frame))
      (set-face-background 'default prev-default-face-bg (selected-frame))))

  (defun my/set-frame-alpha (&optional arg)
    (interactive "sFrame Alpha? ")
    (if
        (and arg (not (string-empty-p arg)))
        (set-frame-parameter nil 'alpha  (string-to-number arg))
      (set-frame-parameter nil 'alpha 90)))

  (defun my/set-frame-alpha-background (&optional arg)
    (interactive "sFrame Alpha Background? ")
    (if
        (and arg (not (string-empty-p arg)))
        (set-frame-parameter nil 'alpha-background  (string-to-number arg))
      (set-frame-parameter nil 'alpha-background 90)))
  (set-frame-parameter nil 'alpha-background 85)

  (setq my-window-map (make-sparse-keymap))

  (define-key my-window-map "u" #'winner-undo)
  (define-key my-window-map "r" #'winner-redo)

  (define-key my-window-map "<"
              (lambda (arg) (interactive "P") (shrink-window-horizontally (if arg arg 1))))
  (define-key my-window-map ">"
              (lambda (arg) (interactive "P") (enlarge-window-horizontally (if arg arg 1))))

  (define-key my-window-map "-"
              (lambda (arg) (interactive "P") (shrink-window (if arg arg 1))))
  (define-key my-window-map "+"
              (lambda (arg) (interactive "P") (enlarge-window (if arg arg 1))))

  (define-key my-window-map "v" #'split-window-horizontally)
  (define-key my-window-map "s" #'split-window-vertically)

  (define-key my-window-map "q" #'delete-window)
  (define-key my-window-map "\C-w" #'other-window)

  (define-key my-window-map "l" #'windmove-right)
  (define-key my-window-map "\C-l" #'windmove-right)

  (define-key my-window-map "h" #'windmove-left)
  (define-key my-window-map "\C-h" #'windmove-left)

  (define-key my-window-map "k" #'windmove-up)
  (define-key my-window-map "\C-k" #'windmove-up)

  (define-key my-window-map "j" #'windmove-down)
  (define-key my-window-map "\C-j" #'windmove-down)

  (define-key my-window-map "=" #'balance-windows)

  (define-key my-window-map "o" #'maximize-window)
  (define-key my-window-map "\C-o" #'delete-other-windows)

  (define-key global-map (kbd "\C-w") nil)
  (define-key global-map (kbd "\C-w") my-window-map)
#+end_src

* misc startup tasks
viper mode, global hl and visual lines
stole the completing read stuff from:
#+begin_src elisp

  (setq gc-cons-threshold most-positive-fixnum)

  ;; Lower threshold back to 8 MiB (default is 800kB)
  (add-hook 'emacs-startup-hook
            (lambda () (setq gc-cons-threshold (* 1024 1024 16)))) ;; 16MB

  (run-with-idle-timer 2 t #'garbage-collect)

  (setq inhibit-startup-screen t)

  (use-package menu-bar :defer t :config (menu-bar-mode 0))
  (use-package tool-bar :defer t :config (tool-bar-mode 0))

  (setq viper-mode t)
  (require 'viper)
  (require 'rect)

  (use-package scroll-bar :defer t)
  (viper-mode)
  (global-hl-line-mode)
  (global-auto-revert-mode)
  (setq auto-revert-verbose nil)
  (global-visual-line-mode)
  (when (fboundp #'global-visual-wrap-prefix-mode)
    (global-visual-wrap-prefix-mode)
    (setq visual-wrap-extra-indent 4))

  (when (fboundp #'kill-ring-deindent-mode)
    (kill-ring-deindent-mode))

  (add-hook 'prog-mode-hook (lambda () (modify-syntax-entry ?_ "-") (modify-syntax-entry ?_ "_")))

  (setq revert-without-query '(".*")) ;; allow reverting without confirm
  (setq column-number-mode t)
  (setq scroll-margin 8)
  (setq visual-bell t)
  (setq ring-bell-function 'ignore)
  (setq scroll-preserve-screen-position t)
  (setq eval-expression-print-level nil)
  (setq eval-expression-print-length nil)
#+end_src

** steal doom's auto save transform
#+begin_src elisp
  (ignore-errors
    (make-directory (concat (file-name-directory user-init-file) ".local/"))
    (make-directory (concat (file-name-directory user-init-file) ".local/autosave/"))
    (make-directory (concat (file-name-directory user-init-file) ".local/backups/")))

  (setq auto-save-file-name-transforms 
        `(("\\`/[^/]*:\\([^/]*/\\)*\\([^/]*\\)\\'" "/Users/jason.z/.emacs.d/.local/cache/autosave/tramp-\\2" t)
          (".*" ,(concat (file-name-directory user-init-file) ".local/autosave/\\1") t)))
  (setq back-directory-alist `((".*" ,(concat (file-name-directory user-init-file) ".local/backups/"))))

#+end_src

** yank from kill ring keybind
#+begin_src elisp
  (define-key global-map (kbd "C-S-p") #'yank-from-kill-ring)
#+end_src

* auto save buffers
#+begin_src elisp
  (setq auto-save-visited-interval 7)
  (auto-save-visited-mode)
#+end_src

* better backup file behavior
#+begin_srC elisp
  (setq backup-directory-alist `(("." . "~/.emacs.d/save-backups")))
  (setq backup-by-copying t)
  (setq delete-old-versions t
        kept-new-versions 6
        kept-old-versions 2
        version-control t)
#+end_srC 

* enhancing icomplete inbuffer completions
https://www.rahuljuliato.com/posts/in-buffer-icomplete

https://www.rahuljuliato.com/posts/in-buffer-icomplete-2
#+begin_src elisp
  ;;; ICOMPLETE
  (use-package icomplete
    :bind (:map icomplete-minibuffer-map
                ("C-n" . icomplete-forward-completions)
                ("C-p" . icomplete-backward-completions)
                ("C-v" . icomplete-vertical-toggle)
                ("RET" . icomplete-force-complete-and-exit))
    :config
    (setq icomplete-delay-completions-threshold 0)
    (setq icomplete-compute-delay 0)
    (setq icomplete-show-matches-on-no-input t)
    (setq icomplete-hide-common-prefix nil)
    (setq icomplete-prospects-height 10)
    (setq icomplete-separator " . ")
    (setq icomplete-with-completion-tables t)
    (setq icomplete-in-buffer t)
    (setq icomplete-max-delay-chars 0)
    (setq icomplete-scroll t)
    (advice-add 'completion-at-point
                :after #'minibuffer-hide-completions)

    (defcustom icomplete-vertical-selected-prefix-marker "Â» "
      "Prefix string used to mark the selected completion candidate.
  If `icomplete-vertical-render-prefix-marker' is t, the string
  setted here is used as a prefix of the currently selected entry in the
  list.  It can be further customized by the face
  `icomplete-vertical-selected-prefix-face'."
      :type 'string
      :group 'icomplete
      :version "31")

    (defcustom icomplete-vertical-unselected-prefix-marker "  "
      "Prefix string used on the unselected completion candidates.
  If `icomplete-vertical-render-prefix-marker' is t, the string
  setted here is used as a prefix for all unselected entries in the list.
  list.  It can be further customized by the face
  `icomplete-vertical-unselected-prefix-face'."
      :type 'string
      :group 'icomplete
      :version "31")

    (defcustom icomplete-vertical-in-buffer-adjust-list t
      "Control whether in-buffer completion should align the cursor position.
  If this is t and `icomplete-in-buffer' is t, and `icomplete-vertical-mode'
  is activated, the in-buffer vertical completions are shown aligned to the
  cursor position when the completion started, not on the first column, as
  the default behaviour."
      :type 'boolean
      :group 'icomplete
      :version "31")

    (defcustom icomplete-vertical-render-prefix-marker t
      "Control whether a marker is added as a prefix to each candidate.
  If this is t and `icomplete-vertical-mode' is activated, a marker,
  controlled by `icomplete-vertical-selected-prefix-marker' is shown
  as a prefix to the current under selection candidate, while the
  remaining of the candidates will receive the marker controlled
  by `icomplete-vertical-unselected-prefix-marker'."
      :type 'boolean
      :group 'icomplete
      :version "31")

    (defface icomplete-vertical-selected-prefix-face
      '((t :inherit font-lock-keyword-face :weight bold :foreground "cyan"))
      "Face used for the prefix set by `icomplete-vertical-selected-prefix-marker'."
      :group 'icomplete
      :version "31")

    (defface icomplete-vertical-unselected-prefix-face
      '((t :inherit font-lock-keyword-face :weight normal :foreground "gray"))
      "Face used for the prefix set by `icomplete-vertical-unselected-prefix-marker'."
      :group 'icomplete
      :version "31")

    (defun icomplete-vertical--adjust-lines-for-column (lines buffer data)
      "Adjust the LINES to align with the column in BUFFER based on DATA."
      (if icomplete-vertical-in-buffer-adjust-list
          (let ((column
                 (with-current-buffer buffer
                   (save-excursion
                     (goto-char (car data))
                     (current-column)))))
            (dolist (l lines)
              (add-text-properties
               0 1 `(display ,(concat (make-string column ?\s) (substring l 0 1)))
               l))
            lines)
        lines))

    (defun icomplete-vertical--add-marker-to-selected (comp)
      "Add markers to the selected/unselected COMP completions."
      (if (and icomplete-vertical-render-prefix-marker
               (get-text-property 0 'icomplete-selected comp))
          (concat (propertize icomplete-vertical-selected-prefix-marker
                              'face 'icomplete-vertical-selected-prefix-face)
                  comp)
        (concat (propertize icomplete-vertical-unselected-prefix-marker
                            'face 'icomplete-vertical-unselected-prefix-face)
                comp)))

    (cl-defun icomplete--render-vertical
        (comps md &aux scroll-above scroll-below
               (total-space ; number of mini-window lines available
                (1- (min
                     icomplete-prospects-height
                     (truncate (max-mini-window-lines) 1)))))
      ;; Welcome to loopapalooza!
      ;;
      ;; First, be mindful of `icomplete-scroll' and manual scrolls.  If
      ;; `icomplete--scrolled-completions' and `icomplete--scrolled-past'
      ;; are:
      ;;
      ;; - both nil, there is no manual scroll;
      ;; - both non-nil, there is a healthy manual scroll that doesn't need
      ;;   to be readjusted (user just moved around the minibuffer, for
      ;;   example);
      ;; - non-nil and nil, respectively, a refiltering took place and we
      ;;   may need to readjust them to the new filtered `comps'.
      (when (and icomplete-scroll
                 icomplete--scrolled-completions
                 (null icomplete--scrolled-past))
        (cl-loop with preds
                 for (comp . rest) on comps
                 when (equal comp (car icomplete--scrolled-completions))
                 do
                 (setq icomplete--scrolled-past preds
                       comps (cons comp rest))
                 (completion--cache-all-sorted-completions
                  (icomplete--field-beg)
                  (icomplete--field-end)
                  comps)
                 and return nil
                 do (push comp preds)
                 finally (setq icomplete--scrolled-completions nil)))
      ;; Then, in this pretty ugly loop, collect completions to display
      ;; above and below the selected one, considering scrolling
      ;; positions.
      (cl-loop with preds = icomplete--scrolled-past
               with succs = (cdr comps)
               with space-above = (- total-space
                                     1
                                     (cl-loop for (_ . r) on comps
                                              repeat (truncate total-space 2)
                                              while (listp r)
                                              count 1))
               repeat total-space
               for neighbor = nil
               if (and preds (> space-above 0)) do
               (push (setq neighbor (pop preds)) scroll-above)
               (cl-decf space-above)
               else if (consp succs) collect
               (setq neighbor (pop succs)) into scroll-below-aux
               while neighbor
               finally (setq scroll-below scroll-below-aux))
      ;; Halfway there...
      (let* ((selected (propertize (car comps) 'icomplete-selected t))
             (chosen (append scroll-above (list selected) scroll-below))
             (tuples (icomplete--augment md chosen))
             max-prefix-len max-comp-len lines nsections)
        (add-face-text-property 0 (length selected)
                                'icomplete-selected-match 'append selected)
        ;; Figure out parameters for horizontal spacing
        (cl-loop
         for (comp prefix) in tuples
         maximizing (length prefix) into max-prefix-len-aux
         maximizing (length comp) into max-comp-len-aux
         finally (setq max-prefix-len max-prefix-len-aux
                       max-comp-len max-comp-len-aux))
        ;; Serialize completions and section titles into a list
        ;; of lines to render
        (cl-loop
         for (comp prefix suffix section) in tuples
         when section
         collect (propertize section 'face 'icomplete-section) into lines-aux
         and count 1 into nsections-aux
         for comp = (icomplete-vertical--add-marker-to-selected comp)
         when (get-text-property 0 'icomplete-selected comp)
         do (add-face-text-property 0 (length comp)
                                    'icomplete-selected-match 'append comp)
         collect (concat prefix
                         (make-string (max 0 (- max-prefix-len (length prefix))) ? )
                         (completion-lazy-hilit comp)
                         (make-string (max 0 (- max-comp-len (length comp))) ? )
                         suffix)
         into lines-aux
         finally (setq lines lines-aux
                       nsections nsections-aux))
        ;; Kick out some lines from the beginning due to extra sections.
        ;; This hopes to keep the selected entry more or less in the
        ;; middle of the dropdown-like widget when `icomplete-scroll' is
        ;; t.  Funky, but at least I didn't use `cl-loop'
        (setq lines
              (nthcdr
               (cond ((<= (length lines) total-space) 0)
                     ((> (length scroll-above) (length scroll-below)) nsections)
                     (t (min (ceiling nsections 2) (length scroll-above))))
               lines))

        ;; HACK TO BE ABLE TO USE M-<tab> TO USE NORMAL MINIBUFFER COMPLETION
        (my-mode)
        (when icomplete--in-region-buffer
          (setq lines (icomplete-vertical--adjust-lines-for-column
                       lines icomplete--in-region-buffer completion-in-region--data)))
        ;; At long last, render final string return value.  This may still
        ;; kick out lines at the end.
        (concat " \n"
                (cl-loop for l in lines repeat total-space concat l concat "\n")))))
#+end_src

* minibuffer setup

Use partial-completion by default, most similar to orderless
useful keybinds C-j to exit minibuffer with first candidate
M-j to exit minibuffer with whatever is in the input

#+begin_src elisp
  (fido-vertical-mode)

  (use-package savehist
    :init
    (savehist-mode))

  (if (gt= emacs-major-version 30)
      (setq completions-sort 'historical)
    (setq completions-sort nil) ;; no sorting makes completion faster
    )

  (define-key minibuffer-local-completion-map "\t" #'icomplete-force-complete)
  (define-key minibuffer-local-completion-map (kbd "C-<return>") #'viper-exit-minibuffer)
  (define-key global-map (kbd "C-z") #'viper-mode) ;; C-z to suspend frame is annoying with viper

  (setq completion-styles '(partial-completion basic) completion-category-overrides nil completion-category-defaults nil)
  ;; need this hook otherwise i think fido setup or something overrides the completion which is annoying
  (defun my-icomplete-styles () (setq-local completion-styles '(partial-completion basic)))
  (add-hook 'icomplete-minibuffer-setup-hook 'my-icomplete-styles)

  (defvar my-icomplete-prev-command nil)
  (defun my-icomplete-save ()
    "save the prvious icomplete session"
    (setq my-icomplete-prev-command this-command)
    (add-hook 'post-command-hook #'my-icomplete-exit-save-input nil 'local))

  (defvar my-icomplete-prev-input "")
  (defun my-icomplete-exit-save-input ()
    (setq my-icomplete-prev-input (minibuffer-contents-no-properties)))

  (add-hook 'icomplete-minibuffer-setup-hook 'my-icomplete-save)

  (defun my-icomplete-repeat ()
    (interactive)
    (when (and (not (equal my-icomplete-prev-command #'my-icomplete-repeat))
               (commandp my-icomplete-prev-command))
      (minibuffer-with-setup-hook
          (lambda () (insert my-icomplete-prev-input))
        (call-interactively my-icomplete-prev-command))))

  (viper-map! :leader "'" #'my-icomplete-repeat)

  ;; insert * at the beginning so we don't have to match exactly at the beginning
  ;; but only in the icomplete minibuffer so we don't clash with viper minibuffer and stuff
  ;; NOTE: command category can slow down M-x
  (defun icomplete-partial-completion-setup ()
    (unless (or 
             (eq (icomplete--category) 'file)
             )
      (insert "*")))

  (add-hook 'icomplete-minibuffer-setup-hook #'icomplete-partial-completion-setup)

  (defvar icomplete-current-command nil)
  ;; insert wild card to sorta emulate orderless

  (defun icomplete-partial-completion-insert-wildcard ()
    (interactive)
    (if (memq icomplete-current-command
              (list 'viper-ex
                    'eww))
        (insert " ")
      (insert "*")))

  (define-key icomplete-minibuffer-map " " #'icomplete-partial-completion-insert-wildcard)
  ;; this allows us to still insert spaces
  (define-key viper-insert-basic-map (kbd "M-SPC SPC") (lambda () (interactive) (insert " ")))

  (defun my/minibuffer-setup-hook ()
    (setq icomplete-current-command this-command)
    ;; (setq-local icomplete-show-matches-on-no-input nil)
    )

  (add-hook 'minibuffer-setup-hook #'my/minibuffer-setup-hook 100)
#+end_src

* in-buffer searching
** advice to highlight matches with viper search
#+begin_src elisp
  (advice-add #'viper-search :after
              (lambda (string &rest args)
                (hi-lock-face-buffer string)))
#+end_src

** optional incremental occur, similar to swiper
[[*better escape handling][advice to turn off highlighting on escape]]
#+begin_src elisp
  ;; keep highlighting after isearch
  (setq lazy-highlight-cleanup nil)

  (defun my/ioccur-minibuf-after-edit (beg end len)
    (setq my/ioccur-string (buffer-substring-no-properties (1+ (length my/ioccur-prompt-string)) (point-max)))
    (when (gt (length (string-replace ".*" "" my/ioccur-string)) 2)
      (ignore-errors (occur-1 my/ioccur-string
                              my/ioccur-nlines-arg
                              (list my/occur-buffer)))))

  (setq my/ioccur-prompt-string "Find: ")
  (setq my/ioccur-string "")

  (defun my/ioccur (arg)
    "Run a pseudo interactive grep, which will incrementally update the xref buffer based on minibuffer input.
  With a prefix-arg run normally and specfiy a directory"
    (interactive "P")
    (setq my/ioccur-string "")
    (setq my/occur-buffer (current-buffer))
    (setq my/ioccur-nlines-arg (when arg (prefix-numeric-value arg)))
    (minibuffer-with-setup-hook
        (lambda ()
          (local-set-key (kbd "SPC") (lambda () (interactive) (insert ".*")))
          (add-hook 'after-change-functions #'my/ioccur-minibuf-after-edit nil 'local))
      (occur-1 (read-regexp my/ioccur-prompt-string)
               my/ioccur-nlines-arg
               (list my/occur-buffer))))

  (viper-map! :mode 'occur-mode
              :n "i" #'occur-edit-mode)

  (viper-map! :leader
              "ss" #'my/ioccur
              ;; not sure why but we need to rescan the imenu for our igrep xref buffer
              "si" (lambda () (interactive)
                     (imenu--menubar-select imenu--rescan-item)
                     (call-interactively 'imenu)))
#+end_src

* ripgrep wrapper
#+begin_src elisp
  (defun ripgrep ()
    (interactive)
    (call-interactively 'grep))

  (defun rripgrep ()
    (interactive)
    (call-interactively 'rgrep))

  (defun rripgrep-multiline ()
    (interactive)
    (call-interactively 'rgrep))

  (defun rgrep-multiline ()
    (interactive)
    (grep-apply-setting 'grep-command "grep -Pazo --color=auto -nH --null -e ")
    (call-interactively 'rgrep))

  (defun grep-options-advice ()
    "A convenient way for us to put different options depending on the grep command being run.
  See notes:emacs-notes-and-tips for more details."
    (cond ((or (eq this-command 'ripgrep) (eq this-command 'rripgrep))
           (progn
             (grep-apply-setting 'grep-command "rg -nS --no-heading ") ;; for normal single file grep
             (grep-apply-setting 'grep-find-template "find <D> <X> -type f <F> -exec rg <C> -nS --no-heading -H  <R> /dev/null {} +"))) ;; for rgrep; uses grep-find-template
          ((eq this-command 'rripgrep-multiline)
           (progn
             (grep-apply-setting 'grep-find-template "find <D> <X> -type f <F> -exec rg <C> -nSU --no-heading -H  <R> /dev/null {} +")))
          ((eq this-command 'rgrep-multiline)
           (progn
             (grep-apply-setting 'grep-find-template "find -H <D> <X> -type f <F> -exec grep -zo <C> -nH --null -e <R> \\{\\} +")))
          (t (progn ;; defaults in case I want to change them later to do something different, otherwise don't really need this last case
               (grep-apply-setting 'grep-find-template "find -H <D> <X> -type f <F> -exec grep <C> -nH --null -e <R> \\{\\} +")
               (grep-apply-setting 'grep-command "grep --color=auto -nH --null -e ")))
          )
    )

  (advice-add #'grep-compute-defaults :before #'grep-options-advice)
#+end_src

* completion

** default to dabbrev-capf
#+begin_src elisp
  (require 'dabbrev)
  ;; #'dabbrev-completion resets the global variables first so we do the same
  (advice-add #'dabbrev-capf :before #'dabbrev--reset-global-variables)
  (add-hook 'completion-at-point-functions #'dabbrev-capf 100)
#+end_src

** xref completion settings
advice for various search commands =project-find-regexp=, =xref-find-apropos=
nice quality of life similar to how we do partial completion
#+begin_src elisp
  (use-package xref
    :config
    (setq xref-search-program
          (cond ((executable-find "rg") 'ripgrep)
                ((executable-find "ugrep") 'ugrep)
                (t 'grep)))
    (setq xref-show-xrefs-function #'xref-show-definitions-completing-read)
    (setq xref-show-definitions-function #'xref-show-definitions-completing-read)

   
  (defun search-advice (orig-fun regexp)
    (let ((xref-show-xrefs-function #'xref--show-xref-buffer))
      (minibuffer-with-setup-hook
          (lambda ()
            ;; for some reason this doesn't apply in xref find apropos but that's honestly ok
            ;; cause it uses a space separated list of words anyways
            (local-set-key (kbd "M-SPC") (lambda () (interactive) (insert " ")))
            (local-set-key (kbd "SPC") (lambda () (interactive) (insert ".*"))))
        (funcall orig-fun regexp))))
  (advice-add 'project-find-regexp :around #'search-advice)
  (advice-add 'xref-find-apropos :around #'search-advice)
  (advice-add 'previous-history-element :after #'end-of-line) ;; usually we want to go to end of line



    (setq my/xref-vi-state-modify-map
          (make-composed-keymap
           nil
           (make-composed-keymap
            (list my/viper-vi-basic-motion-keymap
                  my/viper-vi-motion-g-keymap
                  my/viper-vi-motion-leader-keymap)
            xref--xref-buffer-mode-map)))
    (viper-modify-major-mode 'xref--xref-buffer-mode 'vi-state my/xref-vi-state-modify-map))
#+end_src

** in buffer completion
from:
https://www.reddit.com/r/emacs/comments/zl6amy/completionatpoint_using_completingread_icomplete/

Ctrl-J to force completion and exit

This is mostly just a simpler version of consult and only concerned with completion at point basically
https://www.gnu.org/software/emacs/manual/html_node/elisp/Programmed-Completion.html
https://www.gnu.org/software/emacs/manual/html_node/elisp/Programmed-Completion.html

bunch of stuff here to basically call the function version of /collection/ inside the current buffer
no idea how necessary that is
#+begin_src elisp
  (setq enable-recursive-minibuffers t)
  (setq icomplete-in-buffer t)
  (setq minibuffer-visible-completions t)
  (when (fboundp 'global-completion-preview-mode) (global-completion-preview-mode))

  ;; for default completion behavior in the *completions* buffer, should we decide to use it
  (define-key completion-in-region-mode-map (kbd "C-n") #'minibuffer-next-completion)
  (define-key completion-in-region-mode-map (kbd "C-p") #'minibuffer-previous-completion)
  (when (boundp 'minibuffer-visible-completions-map)
    (define-key minibuffer-visible-completions-map (kbd "C-n") #'minibuffer-next-completion)
    (define-key minibuffer-visible-completions-map (kbd "C-p") #'minibuffer-previous-completion))
  (setq completions-format 'one-column)
  (setq completions-max-height 20)
  (setq completions-header-format nil)

  (define-error 'no-completions "completing-read-in-region: No completions")
  (defun completing-read-in-region (start end collection &optional predicate)
    "Prompt for completion of region in the minibuffer if non-unique.
    Use as a value for `completion-in-region-function'."
    (let* ((initial (buffer-substring-no-properties start end))
           (limit (car (completion-boundaries initial collection predicate "")))
           (all (completion-all-completions initial collection predicate (length initial)))
           ;; when the completion candidate list a single one, for some reason completing-read
           ;; will delete a bunch of lines.
           ;; to couteract this, we basically undo an atomic change and set the completion variable
           (completion (cond
                        ((atom all) nil)
                        ((and (consp all) (atom (cdr all)))
                         (concat (substring initial 0 limit) (car all)))
                        (t
                         (setq completion 
                               (catch 'done
                                 (atomic-change-group 
                                   (let ((completion
                                          (completing-read "Completion: " collection predicate nil initial)))
                                     (throw 'done completion)))))))))
      (cond (completion (completion--replace start end completion) t)
            (t (signal 'no-completions nil)))))
  ;;(setq completion-in-region-function #'completing-read-in-region)
  (setq completion-in-region-function #'completion--in-region) ;; this is default


  ;; similar to doom's +corfu/move-to-minibuffer
  (define-key my-mode-map (kbd "M-<tab>")
              (lambda ()
                (interactive)
                (unwind-protect
                    (let ((completion-in-region-function
                           (if completion-in-region--data #'completing-read-in-region #'completion--in-region)))
                      (call-interactively #'complete-symbol))
                  )))

  (setq tab-always-indent 'complete)
#+end_src

*** better indent-for-tab-command and backtab behavior
#+begin_src elisp
  (defun indent-current-line ()
    "Indent the line. Stolen from the middle section of `indent-for-tab-command'."
    (or (not (eq (indent--funcall-widened indent-line-function) 'noindent))
        (indent--default-inside-comment)
        (when (or (lt= (current-column) (current-indentation))
                  (not (eq tab-always-indent 'complete)))
          (indent--funcall-widened (default-value 'indent-line-function)))))

  ;; want backtab to undo our indents basically but not do completion
  (defun indent-for-backtab-command ()
    "Want backtab to reindent the line if we've overintended with tab.
  Otheriwse, shift backwards by tab-width."
    (interactive)
    (if-let ((cmd (ignore-errors
                    (lookup-key (symbol-value (intern (concat (symbol-name major-mode) "-map")))
                                [backtab]))))
        (call-interactively cmd)
      (let ((text-before-pt (buffer-substring-no-properties (line-beginning-position) (point)))
            ;; get the would be indented column then undo the changes and restore point
            (indented-column (catch 'done (save-excursion
                                            (atomic-change-group
                                              (indent-current-line)
                                              (throw 'done (current-column)))))))

        ;; only deindent if we're equal to or before the would-be indented column
        ;; otherwise, go back to the intended indented position
        (if (lt= (current-column) indented-column)
            (indent-rigidly (if (region-active-p) (region-beginning) (line-beginning-position))
                            (if (region-active-p) (region-end) (line-end-position))
                            (- tab-width))
          (indent-current-line)))))

  (defun indent-for-tab-check-empty-before-point (orig-fun &rest args)
    "Around advice for `indent-for-tab-command'.
  Insert tabs DWIM style if the current position is already indented and
  we're at the beginning of the text on the current line.
  ORIG-FUN is `indent-for-tab-command' and ARGS is prefix-arg for that."
    (let ((text-before-pt (buffer-substring-no-properties (line-beginning-position) (point)))
          ;; get the would be indented column then undo the changes and restore point
          (indented-column (catch 'done (save-excursion
                                          (atomic-change-group
                                            (indent-current-line)
                                            (throw 'done (current-column)))))))
      ;; only indent if we're equal to or past the would-be indented column
      (if (and (gt= (current-column) indented-column)
               (string-blank-p text-before-pt))
          (insert-tab current-prefix-arg)
        (apply orig-fun args))))

  (advice-add 'indent-for-tab-command :around #'indent-for-tab-check-empty-before-point)
  (define-key viper-insert-basic-map [backtab] #'indent-for-backtab-command)
#+end_src

**** Unused
an alternative method that we won't be using in favor of the above
but this would insert a tab character upon 2 consecutive no-completion signals
#+begin_src elisp :tangle no
  (setq no-completion-count 0)

  (defun reset-no-completions-count ()
    (unless (eq this-command 'indent-for-tab-command)
      (setq no-completion-count 0)
      (remove-hook 'post-command-hook #'reset-no-completions-count) 
      )
    )
  (defun indent-for-tab-command-ad (orig-fun &rest args)
    (condition-case err
        (apply orig-fun args)
      (no-completions
       (setq no-completion-count (1+ no-completion-count))
       (add-hook 'post-command-hook #'reset-no-completions-count)
       (when (= no-completion-count 2)
         (insert-tab)
         (setq no-completion-count 0)
         )
       )
      )
    )

#+end_src

* vc settings
No need for the other backends
#+begin_src elisp
  (use-package vc :config
    (setq-default vc-handled-backends '(SVN Git Hg))
    (setq vc-git-diff-switches '("--histogram" "--diff-algorithm=histogram"))
    )
#+end_src

** diff stage hunk to separate buffer                                :WIP:
Want to follow more magit-like behavior
and adjust ~diff-hunk-kill~ to send the hunk to a separate
diff buffer that we can then commit

0. Assume using a unified context
   Otherwise, if we want the "context" diff, we can just use ediff instead
   Or convert after staging, or before to see it in context-mode, and changing back to unified.

1. Need to be able to add the file and junk to the new buffer
   maybe using ~diff-hunk-file-names~ or ~diff-beginning-of-file-and-junk~
2. Need to place the hunk under the correct file in the new buffer
   Can use a re-search-forward
3. Need to place the hunks in the correct order
   We can use the meta data in the header line of the hunk (starting with @@)
   to order things correctly
   
#+begin_src elisp
  ;; fallback to hunk based diff
  (setq diff-font-lock-syntax 'hunk-also)

  (defun diff-kill-hunk-a (og-fn &rest args)
    (let* ((stage-buf (get-buffer-create "*vc-stage-diff*"))
           (current-vc-revisions diff-vc-revisions)
           (beg-of-file-and-junk (save-excursion (diff-beginning-of-file-and-junk) (point)))
           (hunk-file-b (car (diff-hunk-file-names)))
           (hunk-file-a (cadr (diff-hunk-file-names)))
           (end-of-file-and-junk (save-excursion
                                   (diff-beginning-of-file-and-junk)
                                   (re-search-forward (concat "--- " hunk-file-a))
                                   (re-search-forward (concat "+++ " hunk-file-b))
                                   (point)))
           (file-and-junk (buffer-substring beg-of-file-and-junk (1+ end-of-file-and-junk)))
           (hunk-header-re (rx-to-string
                            `(: bol "@@ -" (group (1+ digit)) "," (1+ digit)
                                " +" (group (1+ digit)) "," (1+ digit) " @@")))
           (hunk-header (save-excursion
                          (re-search-backward hunk-header-re)
                          (buffer-substring-no-properties
                           (line-beginning-position)
                           (line-end-position))))
           (hunk-header-start (progn
                                (string-match hunk-header-re hunk-header)
                                (string-to-number
                                 (substring hunk-header (match-beginning 1) (match-end 1)))))
           (hunk-bounds (diff-bounds-of-hunk))
           (file-bounds (ignore-errors (diff-bounds-of-file)))
           ;; If the current hunk is the only one for its file, kill the
           ;; file header too.
           (hunk-and-file-killed (save-excursion
                                   (and file-bounds
                                        (progn (goto-char (car file-bounds))
                                               (= (progn (diff-hunk-next) (point))
                                                  (car hunk-bounds)))
                                        (progn (goto-char (cadr hunk-bounds))
                                               ;; bzr puts a newline after the last hunk.
                                               (while (looking-at "^\n")
                                                 (forward-char 1))
                                               (= (point) (cadr file-bounds))))))
           )
      ;;(message "killed hunk header start %s %s" hunk-header-start hunk-header)
      ;; kill-ring-deindent-mode can mess with whitespace in killed hunks
      ;; which can cause patches to not apply
      (if (and (boundp 'kill-ring-deindent-mode) kill-ring-deindent-mode)
          (progn
            (kill-ring-deindent-mode -1)
            (apply og-fn args)
            (kill-ring-deindent-mode))
        (apply og-fn args))
      (with-current-buffer stage-buf
        (display-buffer stage-buf)
        (diff-mode)

        (ignore-errors
          (setq-local diff-vc-backend (car (vc-deduce-fileset t)))
          (setq-local diff-vc-revisions current-vc-revisions))
        (diff-mode)

        ;; if the file-headers already exist don't do anything
        (let* ((found-file (condition-case nil
                               (save-excursion
                                 (goto-char (point-min))
                                 (re-search-forward (concat "--- " hunk-file-a))
                                 (re-search-forward (concat "+++ " hunk-file-b))
                                 t)
                             (error nil))))
          (message "found-file %s %s" found-file file-and-junk)
          (unless (or found-file hunk-and-file-killed)
            (goto-char (point-max))
            (insert file-and-junk))
          
          (goto-char (point-min))

          (message "wee %s %s %s" (point) hunk-file-a hunk-file-b )
          (condition-case nil
              (progn 
                (re-search-forward (concat "--- " hunk-file-a))
                (re-search-forward (concat "+++ " hunk-file-b))
                (message "wee %s %s %s" (point) hunk-file-a hunk-file-b )
                (forward-line)
                (beginning-of-line))
            (error (message "WTF %s %s" hunk-file-a hunk-file-b ))
            )
          

          ;; we should be in the right file in the stage buffer now
          (ignore-errors
            (let ((start-of-next-file
                   (save-excursion
                     (condition-case nil
                         (progn 
                           (re-search-forward diff-file-header-re)
                           (diff-beginning-of-file-and-junk)
                           (point)
                           )
                       ;; no next file
                       (error (point-max))
                       )
                     )
                   ))
              
              ;; insert the hunk at the correct position
              ;; using hunk headers eg: @@ -0,0 +1,3 @@
              (while
                  (progn
                    (message "before diff hunk next")
                    (diff-hunk-next)
                    ;;(message "after diff hunk next")
                    ;; don't go past the expected file
                    (if (> (point) start-of-next-file)
                        (progn
                          (message "after diff hunk next2a")
                          (goto-char start-of-next-file) nil)
                      ;;(message "after diff hunk next2")
                      (let* ((stage-hunk-header (buffer-substring-no-properties
                                                 (line-beginning-position)
                                                 (line-end-position)))
                             (stage-hunk-header-start
                              (progn
                                ;;(message "after diff hunk next2b")
                                (string-match hunk-header-re stage-hunk-header)
                                (string-to-number
                                 (substring stage-hunk-header (match-beginning 1) (match-end 1)))
                                )
                              ))
                        (message "stage hunk header start %s %s %s" stage-hunk-header-start
                                 hunk-header-start
                                 (> hunk-header-start stage-hunk-header-start))
                        (> hunk-header-start stage-hunk-header-start)
                        )
                      )
                    )
                ))
            )
          ;;(ignore-errors (diff-hunk-next))
          (message "yanking after %s"
                   (buffer-substring-no-properties (line-beginning-position)
                                                   (line-end-position)))
          (when (looking-at hunk-header-re)
            (message "goto prev line %s"
                     (buffer-substring-no-properties (line-beginning-position)
                                                     (line-end-position)))
            (previous-line))
          (end-of-line)
          
          (yank)
          (save-excursion
            (diff-hunk-prev)

            ;; don't want to deal with the headers and they sometimes cause
            ;; "patch fragment without header" errors
            ;; not sure, maybe something to do with our ordering?
            (re-search-forward hunk-header-re)
            (delete-region (point) (line-end-position)) 
            )
          )
        (run-hooks 'vc-diff-finish-functions)

        (diff-setup-whitespace)
        (diff-setup-buffer-type)
        )
      )
    )

  ;; (vc-call-backend 'git 'diff "/home/jason/.emacs.d/vimilla-emacs.org" "HEAD^" "HEAD" (current-buffer) 1)

  (add-to-list 'display-buffer-alist
               '("\\*vc-stage-diff\\*"
                 (display-buffer-below-selected)))

  (defun vc-diff-internal-ad (&rest args)
    (ignore-errors (kill-buffer "*vc-stage-diff*"))
    (clone-buffer "*vc-stage-diff*")
    (with-current-buffer (get-buffer-create "*vc-stage-diff*")
      (read-only-mode -1)
      (erase-buffer)
      (vc-setup-buffer (current-buffer))
      )
    )

  (advice-add #'diff-hunk-kill :around #'diff-kill-hunk-a)
  (advice-add #'vc-diff-internal :after #'vc-diff-internal-ad)
#+end_srC

* speedbar
use as a dummy file viewer
#+begin_src elisp
  (use-package speedbar :defer t
    :config
    (setq speedbar-show-unknown-files t)
    (setq speedbar-frame-parameters (delete '(minibuffer) speedbar-frame-parameters))
    (setq speedbar-update-flag nil)
    (setq my/speedbar-vi-state-modify-map (make-sparse-keymap))
    (define-key my/speedbar-vi-state-modify-map (kbd "<tab>") #'speedbar-toggle-line-expansion)
    (define-key my/speedbar-vi-state-modify-map (kbd "C-i") #'speedbar-toggle-line-expansion)
    (define-key my/speedbar-vi-state-modify-map (kbd "-") #'speedbar-up-directory)
    (viper-modify-major-mode 'speedbar-mode 'vi-state my/speedbar-vi-state-modify-map))
#+end_src

* ibuffer
#+begin_src elisp
  (use-package ibuffer :defer t
    :config
    ;; add project level grouping
    (defun set-ibuffer-project-groups ()
      (setq ibuffer-saved-filter-groups
            (list (let ((l (seq-filter #'identity
                                       (cl-mapcar
                                        (lambda (p)
                                          (let* ((project (project--find-in-directory (car p)))
                                                 (pname (project-name project))
                                                 (pbufs (cl-find-if (lambda (b) (buffer-file-name b)) (project-buffers project))))
                                            (when pbufs
                                              `( ,pname (filename . ,pname)))))
                                        (seq-filter
                                         (lambda (p) (project-buffers (project--find-in-directory (car p))))
                                         project--list)))))
                    (add-to-list 'l "projects"))))
      (ibuffer-switch-to-saved-filter-groups "projects"))
    (add-hook 'ibuffer-hook #'set-ibuffer-project-groups))
#+end_src

* simple project bookmarks
#+begin_src elisp
  (setq bookmark-use-annotations t)
  (setq bookmark-save-flag 1)
  (setq bookmark-automatically-show-annotations nil)

                                          ; note the call-interactively does pass the prefix args
  (defun my/set-project-bookmark ()
    (interactive)
    (minibuffer-with-setup-hook
        (lambda ()
          (let ((prefix (concat (project-name (project-current)) ": ")))
            (when (project-name (project-current))
              (insert prefix))))
      (call-interactively 'bookmark-set)))

  (defun my/jump-to-project-bookmark ()
    (interactive)
    (minibuffer-with-setup-hook
        (lambda ()
          (let ((prefix (concat (project-name (project-current)) ": ")))
            (when (project-name (project-current))
              (insert prefix))))
      (call-interactively 'bookmark-jump)))


  (viper-map! :leader 
              "nrf" #'my/jump-to-project-bookmark
              "bmm" #'my/set-project-bookmark
              "bmj" #'my/jump-to-project-bookmark)
#+end_src


* development
** set environment vars at path
this might be nice if we need to set env vars without direnv

idea is to maybe pass some shell command to cd into a folder
and source some.envrc, then using that same shell, just copy all the environment vars from there using =setenv=
#+begin_src elisp
  (defun split-string-at-first-match (string regex)
    (let ((pos (string-match regex string)))
      (if pos
          (list (substring string 0 pos)
                (substring string (+ pos (length (match-string 0 string)))))
        (list string))))
                               
  (defun copy-env-vars-from-shell-1 (cmd)
    (mapc (lambda (env-var-string)
            (let* ((split (split-string-at-first-match env-var-string "="))
                   (name (cl-first split))
                   (val (cl-second split)))
              (when (and name val)
                (setq val (string-replace " " "\\ " val))
                (setenv name val)
                (when (string-equal "PATH" name)
                  (setq exec-path (append (parse-colon-path val) (list exec-directory)))
                  ;; eshell path
                  (setq-default eshell-path-env val)
                  (when (fboundp 'eshell-set-path) (eshell-set-path val))))))
          (split-string (shell-command-to-string cmd) "\n")))

  (defun copy-env-vars-from-shell ()
    (interactive)
    (copy-env-vars-from-shell-1 "bash --login -i -c printenv"))
#+end_src

** tramp environment variables
#+begin_src elisp
  (defun get-docker-env-vars ()
    "Gets the environment variables set by ENV in dockerfile by looking at /proc/1/environ.
      Meant for eshell in mind."
    (interactive)
    (mapc (lambda (env-var-string)
            (let* ((split (split-string env-var-string "="))
                   (name (cl-first split))
                   (val (cl-second split)))
              (unless (string-equal "TERM" name)
                (if (string-equal "PATH" name)
                    (progn
                      ;; eshell path
                      (setq eshell-path-env val)
                      (when (fboundp 'eshell-set-path) (eshell-set-path val)))
                  (setenv name val)))))
          (split-string (shell-command-to-string "tr \'\\0\' \'\\n\' < /proc/1/environ") "\n")))

  (use-package tramp :defer t
    :config
    (add-to-list 'tramp-remote-path 'tramp-own-remote-path)
    (setq enable-remote-dir-locals t)


    (setq tramp-ssh-controlmaster-options (concat "-o ControlPath=/tmp/ssh-ControlPath-%%r@%%h:%%p " "-o ControlMaster=auto -o ControlPersist=yes"))
    (setq tramp-use-ssh-controlmaster-options t)

    (defun dired-do-delete-advice-remote (orig-fun &rest args)
      ;; this way we use the default value as opposed to the alternative of
      ;; setting delete-by-moving-to-trash to the value of (file-remote-p default-directory)
      (if (file-remote-p default-directory)
          (let ((delete-by-moving-to-trash nil))
            (apply orig-fun args)
            )
        (apply orig-fun args)
        )
      )
    (advice-add 'dired-internal-do-deletions :around #'dired-do-delete-advice-remote)
    )

  (with-eval-after-load 'tramp
    (add-to-list 'tramp-methods
                 '("sshx11"
                   (tramp-login-program        "ssh")
                   (tramp-login-args           (("-l" "%u") ("-p" "%p") ("%c")
                                                ("-e" "none") ("-X") ("%h")))
                   (tramp-async-args           (("-q")))
                   (tramp-remote-shell         "/bin/sh")
                   (tramp-remote-shell-login   ("-l"))
                   (tramp-remote-shell-args    ("-c"))
                   (tramp-gw-args              (("-o" "GlobalKnownHostsFile=/dev/null")
                                                ("-o" "UserKnownHostsFile=/dev/null")
                                                ("-o" "StrictHostKeyChecking=yes")
                                                ("-o" "ForwardX11=yes")))
                   (tramp-default-port         22)))
    (tramp-set-completion-function "sshx11" tramp-completion-function-alist-ssh))
#+end_src

** qol
#+begin_src elisp
  (add-hook 'prog-mode-hook #'flymake-mode)
  (setq treesit-font-lock-level 4)
  (setq-default indent-tabs-mode nil)
  (which-function-mode)
  (setq which-func-display 'header)
  (add-hook 'prog-mode-hook
            (lambda ()
              (unless (eq major-mode 'web-mode)
                (electric-pair-local-mode))))
  (add-hook 'prog-mode-hook #'hs-minor-mode)
#+end_src

*** which-key
This is built into emacs30 now
#+begin_src elisp
  (use-package which-key :defer 2
    :config
    (which-key-mode))
#+end_src



*** flymake diagnostic at point function
#+begin_src elisp
  (defun my/flymake-diagnostics-at-point ()
    (interactive)
    (let ((diags (flymake-diagnostics (point))))
      (if (not (seq-empty-p diags))
          (message "%s"
                   (cl-reduce (lambda (acc d) (concat acc (flymake--diag-text d)))
                              (flymake-diagnostics (point))
                              :initial-value ""))
        (message "No diagnostics at point."))))

  (use-package flymake :defer t
    :config
    (viper-map! :leader
                "cx" #'my/flymake-diagnostics-at-point
                "cX" #'flymake-show-buffer-diagnostics)
    (viper-map! :n "C-c x" #'my/flymake-diagnostics-at-point)
    )
#+end_src

*** compilaton mode in side window
#+begin_src elisp
  (add-to-list 'display-buffer-alist '((major-mode . compilation-mode)
                                       (display-buffer-in-side-window)))
#+end_src

*** flymake project diagnostics in side window
#+begin_src elisp
  (add-to-list 'display-buffer-alist
               '((or (major-mode . flymake-project-diagnostics-mode)
                     (major-mode . flymake-diagnostics-buffer-mode))
                 (display-buffer-in-side-window)))
#+end_src

*** eldoc display buffer in bottom side window
#+begin_src elisp
  (add-to-list 'display-buffer-alist
               '("\\*eldoc.*\\*"
                 (display-buffer-in-side-window)))
#+end_src

*** help display buffer in bottom side window
#+begin_src elisp
  (add-to-list 'display-buffer-alist
               '((major-mode . help-mode)
                 (display-buffer-in-side-window)
                 (window-height . 0.35)))
#+end_src

*** messages display buffer in bottom side window
#+begin_src elisp
  (add-to-list 'display-buffer-alist
               '((major-mode . messages-buffer-mode)
                 (display-buffer-in-side-window)
                 (window-height . 0.15)))
#+end_src

** arduino
#+begin_src elisp
  (define-derived-mode arduino-mode c-mode "arduino"
    "My own mode which is a wrapper for c-mode for editing arduino files.")
  (use-package eglot :defer t
    :config
    (add-to-list 'eglot-server-programs '(arduino-mode . ("~/go/1.22.2/bin/arduino-language-server"
                                                          "-clangd" "/usr/bin/clangd"
                                                          "-cli" "/opt/homebrew/bin/arduino-cli"
                                                          "-cli-config" "/Users/jasonzhen/Library/Arduino15/arduino-cli.yaml"
                                                          "-fqbn" "arduino:avr:uno"))))

  (add-hook 'arduino-mode-hook #'eglot-ensure)

  (add-to-list 'auto-mode-alist '("\\.ino\\'" . arduino-mode))
#+end_src

** golang

#+begin_src elisp
  (add-to-list 'auto-mode-alist '("\\.go\\'" . go-ts-mode))
  (add-hook 'go-ts-mode-hook #'eglot-ensure)

  (use-package go-ts-mode :defer t
    :config
    (setq go-ts-mode-indent-offset tab-width))

  (defun unset-go-env-vars ()
    "This is needed so that for example, if one project has a go work file but the other doesn't,
    we don't still use the other project's go work file."
    (mapc (lambda (env-var-string)
            (let* ((split (split-string env-var-string "="))
                   (name (cl-first split)))
              (when (and name (not (string-empty-p name)))
                (setenv name ""))))
          (split-string (shell-command-to-string "bash --login -c \"go env\"") "\n")))

  (defun copy-go-env-vars-from-shell ()
    (interactive)
    (unset-go-env-vars)
    (copy-env-vars-from-shell)
    (mapc (lambda (env-var-string)
            (let* ((split (split-string env-var-string "="))
                   (name (cl-first split))
                   (val (cl-second split)))
              (when (and name val (not (string-empty-p name)) (not (string-empty-p val)))
                (setenv name (string-trim val "[ '\"]" "[ '\"]")))))
          (split-string (shell-command-to-string "bash --login -c \"go env\"") "\n"))
    (call-interactively 'eglot-reconnect))
#+end_src

*** Steal some qol stuff from doom
#+begin_src elisp
  (defvar +go-test-last nil
    "The last test run.")

  (defun +go--spawn (cmd)
    (save-selected-window
      (compile cmd)))

  (defun +go--run-tests (args)
    (let ((cmd (concat "go test -test.v " args)))
      (setq +go-test-last (concat "cd " default-directory ";" cmd))
      (+go--spawn cmd)))

  (defun +go/test-single ()
    "Run single test at point."
    (interactive)
    (if (string-match "_test\\.go" buffer-file-name)
        (save-excursion
          (re-search-backward "^func[ ]+\\(([[:alnum:]]*?[ ]?[*]?[[:alnum:]]+)[ ]+\\)?\\(Test[[:alnum:]_]+\\)(.*)")
          (+go--run-tests (concat "-run" "='^\\Q" (match-string-no-properties 2) "\\E$'")))
      (error "Must be in a _test.go file")))

  (defun +go/test-file ()
    "Run all tests in current file."
    (interactive)
    (if (string-match "_test\\.go" buffer-file-name)
        (save-excursion
          (goto-char (point-min))
          (let ((func-list))
            (while (re-search-forward "^func[ ]+\\(([[:alnum:]]*?[ ]?[*]?[[:alnum:]]+)[ ]+\\)?\\(Test[[:alnum:]_]+\\)(.*)" nil t)
              (push (match-string-no-properties 2) func-list))
            (+go--run-tests (concat "-run" "='^(" (string-join func-list "|")  ")$'"))))
      (error "Must be in a _test.go file")))

  (use-package go-ts-mode :defer t
    :config
    (setq my/go-vi-state-modify-map (make-sparse-keymap))
    (define-key my/go-vi-state-modify-map " mts" #'+go/test-single)
    (define-key my/go-vi-state-modify-map " mtf" #'+go/test-file)
    (viper-modify-major-mode 'go-ts-mode 'vi-state my/go-vi-state-modify-map))
#+end_src

** python
#+begin_src elisp
  (add-hook 'python-mode-hook (lambda () (setq-local tab-width python-indent-offset)))
  (add-hook 'python-ts-mode-hook (lambda () (setq-local tab-width python-indent-offset)))
#+end_src

*** basic venv wrapper
#+begin_src elisp
  (defvar before-venv-process-environment nil
    "Process environment with no venv")

  (defvar before-venv-exec-path nil
    "Exec path with no venv")

  (defvar venv-mode-line-indicator "")


  (defun copy-pipenv-vars-from-shell ()
    (interactive)
    (if before-venv-process-environment
        (setq process-environment before-venv-process-environment)
      (setq before-venv-process-environment process-environment))

    (copy-env-vars-from-shell-1 "bash --login -i -c \"pipenv run printenv\""))


  (defun copy-python-venv-vars-from-shell ()
    (interactive)
    (if before-venv-exec-path
        (setq exec-path (copy-sequence exec-path))
      (setq before-venv-exec-path (copy-sequence exec-path)))

    (if before-venv-process-environment
        (setq process-environment (copy-sequence before-venv-process-environment))
      (setq before-venv-process-environment (copy-sequence process-environment)))

    (let ((venv-name (read-directory-name "venv folder:" nil nil nil nil)))
      (setq venv-mode-line-indicator (concat "venv:" (project-name (project-current nil venv-name))))
      (add-to-list 'mode-line-misc-info '(t venv-mode-line-indicator)) 
      (copy-env-vars-from-shell-1 (format "bash --login -i -c \". %s && printenv\""
                                          (concat venv-name "bin/activate")))))


  (defun deactivate-python-venv ()
    (interactive)
    (setq exec-path before-venv-exec-path)
    (setq process-environment before-venv-process-environment)
    (setq before-venv-process-environment nil
          before-venv-exec-path nil) 

    (setq-default eshell-path-env (mapconcat #'identity before-venv-exec-path ":"))
    (when (fboundp 'eshell-set-path)
      (eshell-set-path (mapconcat #'identity before-venv-exec-path ":")))
    (setq mode-line-misc-info (delete '(t venv-mode-line-indicator) mode-line-misc-info)))
#+end_src

** javascript/typescript

for typescript, when installing interactively, need to make sure that for the subdirectory where
parser.c lives, we input typescript/src

some weird issue with typescript treesitter v0.20.4, would avoid that branch until its fixed <2024-02-08 Thu>
#+begin_src elisp
  (setq-default tab-width 4)

  (use-package js :defer t
    :config
    (setq js-indent-level 4)
    (add-hook 'js-mode-hook #'eglot-ensure))

  (use-package typescript-ts-mode :defer t
    :config
    (setq typescript-ts-mode-indent-offset 4)
    (add-hook 'typescript-ts-mode-hook #'eglot-ensure))

  (add-to-list 'auto-mode-alist '("\\.ts\\'" . typescript-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.js\\'" . js-ts-mode))
#+end_src

** elisp highlighting
:PROPERTIES:
:VISIBILITY: folded
:END:

stole most of this from doom
https://github.com/doomemacs/doomemacs/blob/03d692f129633e3bf0bd100d91b3ebf3f77db6d1/modules/lang/emacs-lisp/autoload.el#L346-L381

#+begin_src elisp
  (use-package elisp-mode :defer t
    :config
    (require 'advice) ;; for ad-get-orig-definition

    (defun +emacs-lisp-highlight-vars-and-faces (end)
      "Match defined variables and functions.

    Functions are differentiated into special forms, built-in functions and
    library/userland functions"
      (catch 'matcher
        (while (re-search-forward "\\(?:\\sw\\|\\s_\\)+" end t)
          (let ((ppss (save-excursion (syntax-ppss))))
            (cond ((nth 3 ppss)  ; strings
                   (search-forward "\"" end t))
                  ((nth 4 ppss)  ; comments
                   (forward-line +1))
                  ((let ((symbol (intern-soft (match-string-no-properties 0))))
                     (and (cond ((null symbol) nil)
                                ((eq symbol t) nil)
                                ((keywordp symbol) nil)
                                ((special-variable-p symbol)
                                 (setq +emacs-lisp--face 'font-lock-variable-name-face))
                                ((and (fboundp symbol)
                                      (eq (char-before (match-beginning 0)) ?\()
                                      (not (memq (char-before (1- (match-beginning 0)))
                                                 (list ?\' ?\`))))
                                 (let ((unaliased (indirect-function symbol)))
                                   (unless (or (macrop unaliased)
                                               (special-form-p unaliased))
                                     (let (unadvised)
                                       (while (not (eq (setq unadvised (ad-get-orig-definition unaliased))
                                                       (setq unaliased (indirect-function unadvised)))))
                                       unaliased)
                                     (setq +emacs-lisp--face
                                           (if (subrp unaliased)
                                               'font-lock-constant-face
                                             'font-lock-function-name-face))))))
                          (throw 'matcher t)))))))
        nil))

    (font-lock-add-keywords 'emacs-lisp-mode `((+emacs-lisp-highlight-vars-and-faces . +emacs-lisp--face)) 'append))
#+end_src
                
** eshell
#+begin_src elisp
  (defun my/eshell-in-bottom-side-window (arg)
    (interactive "P")
    (let ((eshell-buffer (save-window-excursion (eshell))))
      (select-window (display-buffer-in-side-window eshell-buffer '()))))
#+end_src

#+begin_src elisp
  (defun my/eshell-send-cmd-async ()
    (interactive)
    (let ((cmd (string-trim (buffer-substring-no-properties eshell-last-output-end (progn (end-of-line) (point))))))
      (unless (eshell-head-process)
        (delete-region eshell-last-output-end (point))
        (insert (format "async-shell-command \"%s\"" cmd)))))

  (use-package eshell :defer t
    :config
    (add-to-list 'eshell-modules-list 'eshell-tramp)
    (setq my/eshell-vi-state-modify-map (make-sparse-keymap))
    (setq my/eshell-insert-state-modify-map (make-sparse-keymap))

    (define-key my/eshell-vi-state-modify-map (kbd "C-<return>") #'my/eshell-send-cmd-async)
    (define-key my/eshell-vi-state-modify-map " ma" #'my/eshell-send-cmd-async)
    (define-key my/eshell-insert-state-modify-map (kbd "C-<return>") #'my/eshell-send-cmd-async)
    (define-key my/eshell-insert-state-modify-map (kbd "M-<return>") #'my/eshell-send-cmd-async)

    (defun slurp (f)
      (with-temp-buffer
        (insert-file-contents f)
        (buffer-substring-no-properties (point-min) (point-max))))

    (define-key my/eshell-insert-state-modify-map (kbd "C-r")
                (lambda ()
                  (interactive)
                  (let ((selected (completing-read "History: "
                                                   (cl-remove-if-not
                                                    (lambda (elem)
                                                      (text-properties-at 0 elem))
                                                    (ring-elements eshell-history-ring)))))
                    (when selected 
                      (end-of-line)
                      (eshell-kill-input)
                      (insert selected)))))
    (viper-modify-major-mode 'eshell-mode 'vi-state my/eshell-vi-state-modify-map)
    (viper-modify-major-mode 'eshell-mode 'insert-state my/eshell-insert-state-modify-map))

  (use-package eshell :after consult :config
    (define-key my/eshell-insert-state-modify-map (kbd "C-r") #'consult-history))

  (viper-map! :leader "oe" #'my/eshell-in-bottom-side-window "oE" #'eshell)

#+end_src

** shell mode
#+begin_src elisp
  (defun my/shell-in-bottom-side-window (arg)
    (interactive "P")
    (let ((shell-buffer (save-window-excursion (shell))))
      (select-window (display-buffer-in-side-window shell-buffer '()))))

  (viper-map! :leader "os" #'my/shell-in-bottom-side-window "oS" #'shell)
#+end_src

#+begin_src elisp
  (use-package shell :defer t
    :config
    
    (setq my/shell-insert-state-modify-map (make-sparse-keymap))

    (define-key my/shell-insert-state-modify-map (kbd "<up>") #'comint-previous-input)
    (define-key my/shell-insert-state-modify-map (kbd "<down>") #'comint-next-input)
    (define-key my/shell-insert-state-modify-map (kbd "C-r")
                (lambda ()
                  (interactive)
                  (let ((selected (completing-read "History: "
                                                   (cl-remove-if-not
                                                    (lambda (elem)
                                                      (text-properties-at 0 elem))
                                                    (ring-elements comint-input-ring)))))
                    (when selected
                      (end-of-line)
                      (comint-kill-input)
                      (insert selected)))))
    (viper-modify-major-mode 'shell-mode 'insert-state my/shell-insert-state-modify-map))

  (use-package shell :after consult :config
    (define-key my/shell-insert-state-modify-map (kbd "C-r") #'consult-history))
#+end_src

* Font and theme
:PROPERTIES:
:VISIBILITY: folded
:END:

current system uses iosevka custom nerd font
Note: on linux (popos) need to make sure not to launch Emacs (client) app
#+begin_src elisp
  (when (display-graphic-p) ;; only matter for gui emacs
    (setq current-font-height 160)
    (defun set-fonts ()
      (message "setting fonts")
      (cond ((member "FantasqueSansM Nerd Font Propo" (font-family-list))
             (ignore-errors (set-face-attribute 'default nil :font "FantasqueSansM Nerd Font Propo" :height current-font-height)))
            ((member "IosevkaCustom Nerd Font Propo" (font-family-list))
             (ignore-errors (set-face-attribute 'default nil :font "FantasqueSansM Nerd Font Propo" :height current-font-height)))
            (t (message "None of my preferred mono fonts found, will use defaults")))

      (cond ((member "Comic Neue" (font-family-list))
             (set-face-attribute 'variable-pitch nil :font "Comic Neue" :height current-font-height))
            ((member "Iosevka Etoile" (font-family-list))
             (set-face-attribute 'variable-pitch nil :font "Iosevka Etoile" :height current-font-height))
            (t (message "None of my preferred variable pitch fonts found, will use defaults")))

      (ignore-errors (set-fontset-font t 'emoji "Noto Color Emoji" nil 'append))
      (ignore-errors (set-fontset-font t 'emoji "Apple Color Emoji" nil 'append))
      (ignore-errors (set-fontset-font t 'unicode "Iosevkacustom Nerd Font Propo" nil 'append)))

    (add-hook 'after-make-frame-functions #'set-fonts)
    ;; for some reason this is kinda busted in emacs daemon
    (add-hook 'emacs-startup-hook (lambda () (remove-hook 'after-make-frame-functions #'set-fonts)))
    (set-fonts)

    (defun my/set-font-size ()
      (interactive)
      (let ((new-size (string-to-number
                       (minibuffer-with-setup-hook
                           (lambda () (insert (number-to-string current-font-height)))
                         (read-string "Edit font size: ")))))
        (setq current-font-height new-size)
        (set-face-attribute 'default nil :height new-size)
        (set-face-attribute 'variable-pitch nil :height new-size))))
#+end_src

There is a weird thing where vc-diff won't highlight some stuff since the modus org src block fontification takes over
instead

#+begin_src elisp
  (setq modus-themes-headings
        '((1 . (rainbow overline background variable-pitch 1.25))
          (2 . (rainbow background variable-pitch 1.15))
          (3 . (rainbow bold variable-pitch 1.1))
          (t . (semilight variable-pitch 1.05))))


  (setq modus-themes-bold-constructs t)
  (setq modus-themes-italic-constructs t)
  (setq modus-themes-org-blocks 'gray-background)
  (condition-case nil
      (progn 
        (load-theme 'modus-vivendi-tinted t)
        (set-cursor-color "#f78fe7"))
    (error (progn
             (load-theme 'modus-vivendi t)
             (set-cursor-color "white")))) 

  (use-package diff :defer t
    :config
    ;; for some reason modus gets rid of diff-header
    (set-face-attribute 'diff-header nil :background "gray80"))
#+end_src

** simple auto dark/light mode with midnight mode               :disabled:
:PROPERTIES:
:VISIBILITY: folded
:END:

#+begin_src elisp :tangle no
  (midnight-mode)

  (defun load-light-theme ()
    (condition-case nil
        (progn 
          (load-theme 'modus-operandi-tinted t)
          (set-cursor-color "#a60000"))
      (error (progn
               (load-theme 'modus-operandi t)
               (set-cursor-color "black")))))

  (defun load-dark-theme ()
    (condition-case nil
        (progn
          (load-theme 'modus-vivendi-tinted t)
          (set-cursor-color "#f78fe7"))
      (error
       (progn
         (load-theme 'modus-vivendi t)
         (set-cursor-color "white")))))

  (defun load-dark-theme1 ()
    (load-dark-theme))

  (defun auto-light-dark-midnight-setup ()
    (run-at-time "0:00" t #'load-dark-theme)
    (run-at-time "10:00" t #'load-light-theme)
    (run-at-time "16:00" t #'load-dark-theme1))

  (add-hook 'midnight-hook #'auto-light-dark-midnight-setup)

  (auto-light-dark-midnight-setup)
#+end_src

* Tab bar
basically minimal projectile and persp
#+begin_src elisp
  (defun find-git-dir (dir)
    "Search up the directory tree looking for a .git folder."
    (cond
     ((eq major-mode 'dired-mode) "Dired")
     ((not dir) "process")
     ((string= dir "/") "no-git")
     (t (vc-root-dir))))

  (defun git-tabbar-buffer-groups ()
    "Groups tabs in tabbar-mode by the git repository they are in."
    (list (find-git-dir (buffer-file-name (current-buffer)))))

  (defun get-file-buffers-in-window ()
    (seq-filter #'buffer-file-name
                (delete-dups (mapcar #'window-buffer
                                     (window-list-1 (frame-first-window)
                                                    'nomini)))))

  (defun tab-bar-tab-name-projects ()
    (let ((file-buffers (get-file-buffers-in-window)))
      (if file-buffers
          (mapconcat #'identity
                     (delete-dups
                      (cl-mapcar (lambda (b)
                                   (with-current-buffer b
                                     (if (project-current)
                                         (project-name (project-current))
                                       (buffer-name))))
                                 file-buffers))
                     ", ")
        (tab-bar-tab-name-current))))

  (setq tab-bar-tab-name-function #'tab-bar-tab-name-projects)
  ;; (truncate-string-to-width (tab-bar-tab-name-all) (/ (frame-width) (length (tab-bar-tabs))))

  (defun get-tab-names (&rest _)
    (interactive "P")
    (message "%s"
             (mapconcat
              (lambda (tab)
                (let* ((current-tab-p (eq (car tab) 'current-tab))
                       (idx (number-to-string (1+ (tab-bar--tab-index tab))))
                       (tab-name1 (concat "[" idx "] " (cdr (cl-second tab))))
                       (tab-name (if current-tab-p (propertize tab-name1 'face '(:inherit font-lock-builtin-face :underline t)) tab-name1)))
                  tab-name))
              (tab-bar-tabs)
              "  ")))

  (advice-add 'tab-bar-new-tab :after #'get-tab-names)
  (advice-add 'tab-bar-close-tab :after #'get-tab-names)
  (advice-add 'tab-bar-select-tab :after #'get-tab-names)

  (viper-map! :leader "<tab><tab>" #'get-tab-names
              "<tab>{" (lambda (arg)
                         (interactive "P")
                         (tab-bar-move-tab (if arg (- arg) -1))
                         (get-tab-names))
              "<tab>}" (lambda (arg)
                         (interactive "P")
                         (tab-bar-move-tab (if arg arg 1))
                         (get-tab-names))
              )

  (setq tab-bar-show nil)
  (tab-bar-mode)
#+end_src

** set tab bar name on project switch
#+begin_src elisp
  (defun rename-tab-to-current-project (dir)
    (message (project-name (project-current)))
    (tab-bar-rename-tab (project-name (project-current))))

  (advice-add 'project-switch-project :after #'rename-tab-to-current-project)
#+end_src

* eww
lookup with eww first, then use =eww-browse-with-external-browser= if we need to browse in a normal browser
#+begin_src elisp
  (setq browse-url-browser-function 'eww-browse-url)
  (add-hook 'eww-after-render-hook 'eww-readable)
#+end_src

display eww in side window with a large height
#+begin_src elisp
  (add-to-list 'display-buffer-alist
               '("\\*eww\\*"
                 (display-buffer-in-side-window)
                 (window-height . 0.5)))
#+end_src

* Custom Modeline
#+begin_src elisp
  (defun save-narrowing-info (pos1 pos2)
    (setq narrowed-pos1 (line-number-at-pos pos1))
    (setq narrowed-pos2 (line-number-at-pos pos2)))

  (defun modeline-setup ()

    (defface mode-line-pink
      (if (facep 'modus-themes-fg-magenta-cooler)
          '((t :inherit modus-themes-fg-magenta-cooler))
      '((t :foreground "magenta")))
      "face used for modeline"
      :group 'basic-faces)

    (defface mode-line-cyan
      (if (facep 'modus-themes-fg-cyan-cooler)
          '((t :inherit modus-themes-fg-cyan-cooler))
      '((t :foreground "cyan1")))
      "face used for modeline"
      :group 'basic-faces)

    (advice-add 'narrow-to-region :before #'save-narrowing-info)

    (setq project-mode-line t)
    (setq-default mode-line-buffer-identification
                  `(:eval
                    (let ((s (format-mode-line
                              (propertized-buffer-identification (buffer-name)))))
                      (when (and (boundp 'uniquify-managed) uniquify-managed)
                        (unless (string= (buffer-name) (uniquify-buffer-base-name))
                          (let ((base-len (length (uniquify-buffer-base-name)))
                                (full-len (length (buffer-name)))
                                (pre (eq uniquify-buffer-name-style 'post-forward-angle-brackets)))
                            (let ((start (if pre 0 base-len))
                                  (end (if pre (- full-len base-len) full-len)))
                              (set-text-properties base-len full-len '(face (:inherit mode-line-cyan :weight bold)) s)))))
                      s)))

    (defvar viper-mode-string "") ;; will be loaded later unless we go away from viper mode

    (set-face-attribute 'mode-line-buffer-id nil :inherit 'mode-line-pink :weight 'bold)
    (setq project-mode-line-face 'package-name)
    (setq project-file-history-behavior 'relativize)

    (setq-default mode-line-format '("%e" mode-line-front-space
                                     (:eval (propertize viper-mode-string)) ;; not sure why we need this, but otherwise the props don't show up
                                     ;; kbd macro info
                                     (:eval (when defining-kbd-macro
                                              (concat mode-line-defining-kbd-macro
                                                      (propertize (format "@%s" (char-to-string evil-this-macro)) 'face 'success))))
                                     mode-line-window-dedicated
                                     mode-line-modified mode-line-remote
                                     (project-mode-line project-mode-line-format) " "
                                     mode-line-buffer-identification " "
                                     mode-line-position "<" (:eval (format "%d" (line-number-at-pos (point-max))))
                                     (:eval (when (buffer-narrowed-p) (format " >%d:%d<" narrowed-pos1 narrowed-pos2))) " "
                                     ;; selection position info
                                     (:eval (when (region-active-p)
                                              (propertize (concat
                                                           (number-to-string (1+ (abs (- (line-number-at-pos (point)) (line-number-at-pos (mark)))))) "L"
                                                           (number-to-string (1+ (abs (- (current-column) (save-excursion (goto-char (mark)) (current-column)))))) "C")
                                                          'face 'warning)))
                                     " " (:propertize mode-name face (:weight bold :inherit mode-line-pink)) " " mode-line-misc-info mode-line-end-spaces))

    (column-number-mode)
    (line-number-mode)
    (size-indication-mode)
    )

  (add-hook 'after-make-frame-functions #'modeline-setup)
  (add-hook 'emacs-startup-hook #'modeline-setup)
#+end_src

* Viper
:PROPERTIES:
:header-args: :tangle viper :results silent
:END:

viper is the only built in thing that handles /some/ of the Doom/Vim stuff that I want (since it emulates Vi and not Vim)

** "g" prefix commands
*** beginning of buffer
#+begin_src elisp
  (setq my/g-prefix-map (make-sparse-keymap))
  (define-key viper-vi-basic-map "g" my/g-prefix-map)
  (define-key my/g-prefix-map "g" (lambda () (interactive) (viper-goto-line 1)))
#+end_src

*** movement since we have visual lines
#+begin_src elisp
  (define-key my/g-prefix-map "k" #'viper-previous-line)
  (define-key my/g-prefix-map "j" #'viper-next-line)
#+end_src
*** tab bar movement
#+begin_src elisp
  (define-key my/g-prefix-map "t" #'tab-bar-switch-to-next-tab)
  (define-key my/g-prefix-map "T" #'tab-bar-switch-to-prev-tab)
#+end_src

*** cua mode for multiple cursors
#+begin_src elisp
  (define-key my/g-prefix-map "zz" #'cua-rectangle-mark-mode)
#+end_src


** viper motion keymap
:PROPERTIES:
:VISIBILITY: folded
:END:

There's some weird thing with make-composed-keymap where for some reason the original keymaps might be modified if we use define-key.
Found a solution here: https://emacs.stackexchange.com/questions/3963/use-two-major-mode-maps-in-the-same-buffer
which says to just wrap make-composed-keymap around the original make-composed-keymap

TBD for use in specific major mode keymaps so we at least keep motions
in special modes
#+begin_src elisp
  (defvar viper-leader-map (make-sparse-keymap))
  (define-key viper-vi-basic-map " " viper-leader-map)
  (define-key viper-insert-basic-map (kbd "M-SPC") viper-leader-map)
  (define-key viper-insert-basic-map (kbd "C-w") #'kill-region)


  (setq my/viper-vi-basic-motion-keymap (make-sparse-keymap))
  (define-key my/viper-vi-basic-motion-keymap "h" #'viper-backward-char)
  (define-key my/viper-vi-basic-motion-keymap "l" #'viper-forward-char)
  (define-key my/viper-vi-basic-motion-keymap "j" #'next-line)
  (define-key my/viper-vi-basic-motion-keymap "k" #'previous-line)
  (define-key my/viper-vi-basic-motion-keymap "w" #'viper-forward-word)
  (define-key my/viper-vi-basic-motion-keymap "b" #'viper-backward-word)
  (define-key my/viper-vi-basic-motion-keymap "e" #'viper-end-of-word)
  (define-key my/viper-vi-basic-motion-keymap "v" #'my/set-mark-command)
  (define-key my/viper-vi-basic-motion-keymap "V" #'my/select-lines)
  (define-key my/viper-vi-basic-motion-keymap (kbd "C-v") #'my/visual-block)
  (define-key my/viper-vi-basic-motion-keymap "y" #'viper-copy-region-or-motion-command)
  (define-key my/viper-vi-basic-motion-keymap "^" #'viper-bol-and-skip-white)
  (define-key my/viper-vi-basic-motion-keymap "$" #'viper-goto-eol)
  (define-key my/viper-vi-basic-motion-keymap (kbd "C-d") #'viper-scroll-up)
  (define-key my/viper-vi-basic-motion-keymap "\C-w" my-window-map)
#+end_src

I might be able to live without these ones so they can be overriden
#+begin_src elisp
  (setq my/viper-vi-extra-motion-keymap my/viper-vi-basic-motion-keymap)
  (define-key my/viper-vi-extra-motion-keymap "W" #'viper-forward-Word)
  (define-key my/viper-vi-extra-motion-keymap "B" #'viper-backward-Word)
  (define-key my/viper-vi-extra-motion-keymap "E" #'viper-end-of-Word)

  (define-key my/viper-vi-extra-motion-keymap "f" #'viper-find-char-forward)
  (define-key my/viper-vi-extra-motion-keymap "F" #'viper-find-char-backward)
  (define-key my/viper-vi-extra-motion-keymap "t" #'viper-goto-char-forward)
  (define-key my/viper-vi-extra-motion-keymap "T" #'viper-goto-char-backward)

#+end_src

"g" commands like beginning of buffer and change tab
#+begin_src elisp
  (setq my/viper-vi-motion-g-keymap (make-sparse-keymap))
  (define-key my/viper-vi-motion-g-keymap "g" my/g-prefix-map)
  (define-key my/viper-vi-motion-g-keymap "G" #'viper-goto-line)
#+end_src

leader commands
#+begin_src elisp
  (setq my/viper-vi-motion-leader-keymap (make-sparse-keymap))
  (define-key my/viper-vi-motion-leader-keymap " " viper-leader-map)
#+end_src


** viper keymap macro
#+begin_src elisp
  (defun viper--create-and-set-mode (mode)
    "Create a major-mode modification map in viper for MODE.
    Should not overwrite existing modifications to major mode.
    MODE is a major mode symbol."
    (let ((modified-map-sym (intern (concat "viper-modified-" (symbol-name mode) "-map" )))
          (major-mode-map (symbol-value (intern (concat (symbol-name mode) "-map"))))
          (viper-base-mappings (list my/viper-vi-basic-motion-keymap
                                     my/viper-vi-motion-g-keymap
                                     my/viper-vi-motion-leader-keymap)))
      ;; without the extra make-composed-keymap indirection
      ;; we will either modify the base mappings which is bad because then
      ;; p will do magit-push instead of yank for instance
      ;; in the case where viper-base-mappings is the second argument
      ;; (set modified-map-sym (make-composed-keymap viper-base-mappings major-mode-map))
      
      ;; or in the other case, we won't be able to override the viper base mappings
      ;; i.e. having p only do magit-push in magit buffers

      ;; this indirection way lets us basically make a sparse-keymap
      ;; so that any define-keys just go into the sparse keymap without changing our viper-base-mappings
      ;; with a parent thats a combination of major-mode + viper-base
      ;; where viper-base has precendence over major-mode
      ;; i.e. we want viper movement in magit, not the magit command for j
      (set modified-map-sym (make-composed-keymap nil
                                                  (make-composed-keymap
                                                   viper-base-mappings
                                                   major-mode-map)))
      
      (viper-modify-major-mode mode 'vi-state (symbol-value modified-map-sym))
      modified-map-sym))


  (defun viper--unquote (form)
    (while (memq (car-safe form) '(quote function))
      (setq form (cadr form)))
    form)

  (defun viper--map-process (rest)
    (let ((normal-state-map-sym)
          (insert-state-map-sym)
          (current-map-sym))
      (while rest
        (let ((key (pop rest)))
          (cond ((keywordp key)
                 (pcase key
                   (:leader (setq current-map-sym 'viper-leader-map))
                   (:mode
                    (setq normal-state-map-sym (viper--create-and-set-mode (pop rest)))
                    (message "mode %s" normal-state-map-sym))
                   (:n
                    (if normal-state-map-sym 
                        (setq current-map-sym normal-state-map-sym)
                      (setq current-map-sym 'viper-vi-basic-map))
                    )
                   ))
                (current-map-sym
                 (let ((cmd (pop rest)))
                   (when (commandp cmd)
                     (define-key (symbol-value current-map-sym) (kbd key) cmd))
                   )))
          ))))

  (defun viper-map! (&rest rest)
    (viper--map-process rest))
#+end_src

** mode-line
#+begin_src elisp
  (defface mode-line-green
    (if (facep 'modus-themes-fg-green-warmer)
        '((t :inherit modus-themes-fg-green-warmer))
      '((t :foreground "green")))
    "face used for modeline"
    :group 'basic-faces)

  (defface mode-line-red
    (if (facep 'modus-themes-fg-red-warmer)
        '((t :inherit modus-themes-fg-red-warmer))
      '((t :foreground "red")))
    "face used for modeline"
    :group 'basic-faces)

#+end_src

#+begin_src elisp
  (setq-default global-mode-string (delq 'viper-mode-string global-mode-string))
  (setq-default viper-vi-state-id (propertize viper-vi-state-id 'face '(:inherit mode-line-green :weight bold)))
  (setq-default viper-emacs-state-id (propertize viper-emacs-state-id 'face 'warning))
  (setq-default viper-replace-state-id (propertize viper-replace-state-id 'face '(:inherit mode-line-red :weight bold)))
#+end_src

** viper search settings
#+begin_src elisp
  (setq viper-case-fold-search t)
#+end_src

** vi state stuff
hacky global var to have a "global" viper state
is this better than the default behavior?
Maybe.. maybe not but now this should enable viper mode even on major modes not specified by viper itself
*** global viper state
TODO: add a hook on buffer creation to see if viper is enabled or not, and if not enable it, then switch to the global state?
#+begin_src elisp
  (setq my/global-viper-state 'vi)
  (defun set-global-viper-state ()
    (cond ((eq my/global-viper-state 'vi) (viper-change-state-to-vi))
          ((eq my/global-viper-state 'emacs) (viper-change-state-to-emacs))
          ((eq my/global-viper-state 'insert) (viper-change-state-to-insert))
          (t (viper-change-state-to-vi))
          ))

  (add-hook 'viper-vi-state-hook (lambda ()
                                   (unless (minibuffer-window-active-p (selected-window))
                                     (setq my/global-viper-state 'vi))))
  (add-hook 'viper-emacs-state-hook (lambda ()
                                      (unless (minibuffer-window-active-p (selected-window))
                                        (setq my/global-viper-state 'emacs))))
  (add-hook 'viper-insert-state-hook (lambda ()
                                       (unless (minibuffer-window-active-p (selected-window))
                                         (setq my/global-viper-state 'insert))))
  (add-to-list 'window-state-change-functions
               (lambda (_)
                 (if (minibuffer-window-active-p (selected-window))
                     (viper-change-state-to-insert)
                   (set-global-viper-state))))
#+end_src

**** want better normal state bindings in the "emacs state" buffers
we just set all of these to nil since we have this pseudo global state
plus our workaround of just unbinding q for quit window commands

#+begin_src elisp
  (setq viper-emacs-state-mode-list nil)
  (setq viper-insert-state-mode-list nil)
#+end_src

*** hl line for diff modes, viper viper insert delets to prev line
:PROPERTIES:
:VISIBILITY: folded
:END:
stole the terminal code for cursor from here https://github.com/syl20bnr/spacemacs/issues/7112#issuecomment-389855491
works on iterm2 at least, 0 for box, 6 for bar cursor
#+begin_src elisp
  (setq viper-inhibit-startup-message 't)
  (setq viper-expert-level '5)

  (add-hook 'viper-insert-state-hook (lambda ()
                                       (when (not (display-graphic-p)) (send-string-to-terminal "\033[6 q"))
                                       (setq viper-ex-style-editing nil)))

  (add-hook 'viper-minibuffer-exit-hook (lambda () (global-hl-line-mode) (when (not (display-graphic-p)) (send-string-to-terminal "\033[0 q"))))

  (add-hook 'viper-vi-state-hook (lambda ()
                                   (global-hl-line-mode)
                                   (set-face-attribute 'hl-line nil :underline nil)
                                   (set-face-attribute 'hl-line nil :box nil)
                                   (when (not (display-graphic-p)) (send-string-to-terminal "\033[0 q"))))
  (add-hook 'viper-emacs-state-hook (lambda ()
                                      (global-hl-line-mode)
                                      (if (display-graphic-p)
                                          (set-face-attribute 'hl-line nil :box t)
                                        (set-face-attribute 'hl-line nil :underline t))
                                      (when (not (display-graphic-p)) (send-string-to-terminal "\033[0 q"))))

  (setq viper-insert-state-cursor-color nil)
#+end_src

** minibuffer mappings
#+begin_src elisp
  ;; This is so backspace/delete goes backward directories instead of just deleting characters
  (setq my/minibuffer-modify-map (make-sparse-keymap))
  (define-key my/minibuffer-modify-map (kbd "<backspace>") #'icomplete-fido-backward-updir)
  (define-key my/minibuffer-modify-map (kbd "<DEL>") #'icomplete-fido-backward-updir)
  (viper-modify-major-mode 'minibuffer-mode 'insert-state my/minibuffer-modify-map)
  (viper-modify-major-mode 'minibuffer-mode 'emacs-state my/minibuffer-modify-map)

  ;; (define-key viper-insert-basic-map (kbd "M-<tab>") #'completion-at-point)
#+end_src

** help commands
qol to use c-h for help commands, and something for us to type faster
#+begin_src elisp
  (setq viper-want-ctl-h-help 't)
  (setq viper-fast-keyseq-timeout 100)
#+end_src

** better escape handling

this is useful for if we're on a terminal with no escape key
maybe add it as a dir local :eval thing
#+begin_src elisp :tangle no
  (setq viper-no-multiple-ESC 'twice)
  (advice-add 'viper-intercept-ESC-key :before (lambda () (setq viper-ESC-key "\e")))
  (advice-add 'viper-intercept-ESC-key :after (lambda () (setq viper-ESC-key [escape])))
#+end_src

better ESC key handling to exit visual mode and close mini buffer
#+begin_src elisp
  ;; (advice-mapc `(lambda (fun props) (advice-remove 'viper-intercept-ESC-key fun)) 'viper-intercept-ESC-key)
  (advice-add 'viper-intercept-ESC-key :after #'deactivate-mark)
  (advice-add 'viper-intercept-ESC-key :after (lambda () (ignore-errors (abort-minibuffers))))
  (advice-add 'viper-intercept-ESC-key :after (lambda () (ignore-errors (cua-clear-rectangle-mark))))
  (advice-add 'viper-intercept-ESC-key :after (lambda () (lazy-highlight-cleanup t)))
  (advice-add 'viper-intercept-ESC-key :after (lambda ()
                                                (dolist (hist viper-search-history)
                                                  (hi-lock-unface-buffer hist))))
#+end_src

Delete side windows if any
#+begin_src elisp
  (defun delete-bottom-side-window ()
    (interactive)
    (when (eq viper-current-state 'vi-state) 
      (when-let ((side-window (window-with-parameter 'window-side 'bottom))
                 (buffer-major-mode (with-current-buffer (window-buffer side-window) major-mode)))
        (unless (or (eq 'eshell-mode buffer-major-mode) (eq 'shell-mode buffer-major-mode))
          (delete-window side-window)))))
  (advice-add 'viper-intercept-ESC-key :before #'delete-bottom-side-window)
#+end_src

** pop mark navigation
#+begin_src elisp
  (setq my/mark-ring '())
  (setq my/mark-ring-max-size 16)
  (setq my/mark-ring-current-pos 0)
  (setq my/moving-in-progress nil)

  ;; only for file visiting marks
  (defun my/push-mark-advice (&optional _ _ _)
    (unless my/moving-in-progress
      (let* ((new-mark (copy-marker (mark-marker)))
             (buf (marker-buffer new-mark)))
        (when (buffer-file-name buf)
          ;; transpose on mark ring pos
          (setq my/mark-ring (append (cl-subseq my/mark-ring my/mark-ring-current-pos)
                                     (cl-subseq my/mark-ring 0 my/mark-ring-current-pos)))
          ;; existing mark will be added after
          (setq my/mark-ring
                (seq-filter (lambda (m)
                              (and m (marker-buffer m) (marker-position m)
                                   (not (and (= (marker-position m) (marker-position new-mark))
                                             (eq (marker-buffer m) buf)))))
                            my/mark-ring))

          (when (gt= (length my/mark-ring) my/mark-ring-max-size)
            (setq my/mark-ring (butlast my/mark-ring)))

          (cl-pushnew new-mark my/mark-ring)
          (setq my/mark-ring-current-pos 0)))))
  (advice-add 'push-mark :after #'my/push-mark-advice)

  (defun my/move-to-mark (m)
    (when m
      (let* ((buf (marker-buffer m))
             (position (marker-position m))
             (my/moving-in-progress t))
        (if buf
            (progn
              (set-buffer buf)
              ;; same as pop-global-mark
              (or (and (gt= position (point-min))
                       (lt= position (point-max)))
                  (if widen-automatically
                      (widen)
                    (error "mark position is outside accessible part of buffer %s"
                           (buffer-name buffer))))
              (goto-char position)
              (switch-to-buffer buf))
          (message "No buf for marker %s." m)))))

  (defun my/mark-ring-forward ()
    (interactive)
    ;; when we try to go "back" we want to basically drop a marker where we were
    ;; so we can go "forward" to it later
    (when (and (eql my/mark-ring-current-pos 0)
               (not (and
                     (eql (marker-buffer (elt my/mark-ring 0)) (current-buffer))
                     (eql (marker-position (elt my/mark-ring 0)) (point)))))
      (push-mark))

    (when (and (eql
                (marker-buffer (elt my/mark-ring my/mark-ring-current-pos))
                (current-buffer))
               (eql
                (marker-position (elt my/mark-ring my/mark-ring-current-pos))
                (point)))
      (unless (eql my/mark-ring-current-pos (length my/mark-ring))
        (cl-incf my/mark-ring-current-pos)))
    (my/move-to-mark (elt my/mark-ring my/mark-ring-current-pos)))

  (defun my/mark-ring-backward ()
    (interactive)
    (when (gt my/mark-ring-current-pos 0)
      (cl-decf my/mark-ring-current-pos)
      (my/move-to-mark (elt my/mark-ring my/mark-ring-current-pos))))

  ;; some weird hack to distinguish tab and C-i in gui, broken in terminal
  ;; we only want to do this in vi state so we get tab completion and stuff in insert/emacs state for tty
  (add-hook 'viper-vi-state-hook (lambda () (define-key input-decode-map "\C-i" [C-i])))
  (add-hook 'viper-emacs-state-hook (lambda () (define-key input-decode-map "\C-i" nil)))
  (add-hook 'viper-insert-state-hook (lambda () (define-key input-decode-map "\C-i" nil)))
  ;; this is basically visual state hook
  (add-hook 'activate-mark-hook (lambda () (define-key input-decode-map "\C-i" nil)))
  (add-hook 'deactivate-mark-hook (lambda () (define-key input-decode-map "\C-i" [C-i])))

  (if (display-graphic-p)
      (progn
        (keyboard-translate ?\C-i ?\H-i)
        (define-key viper-vi-basic-map (kbd "H-i") #'my/mark-ring-backward)
        (define-key viper-vi-basic-map "\t" nil)
        (define-key viper-vi-basic-map "\C-o" #'my/mark-ring-forward)
        )
    (progn
      (define-key viper-vi-basic-map [C-i] #'my/mark-ring-backward)
      (define-key viper-vi-basic-map "\C-o" #'my/mark-ring-forward)
      )
    )

#+end_src

** respect visual lines cursor movement
:PROPERTIES:
:VISIBILITY: folded
:END:

basically redefining the viper commands to respect visual line mode
#+begin_src elisp
  (defun viper-previous-line (arg)
    "Go to previous line."
    (interactive "P")
    (let ((val (viper-p-val arg))
          (com (viper-getCom arg)))
      (if com (viper-move-marker-locally 'viper-com-point (point)))
      ;; do not use forward-line! need to keep column
      ;; REDEFINE: remove setting line-move-visual to nil
      (with-no-warnings (previous-line val))
      ;; END OF REDEFINE
      (if viper-ex-style-motion
          (if (and (eolp) (not (bolp))) (backward-char 1)))
      (setq this-command 'previous-line)
      (if com (viper-execute-com 'viper-previous-line val com))))

  (defun viper-next-line (arg)
    "Go to next line."
    (interactive "P")
    (let ((val (viper-p-val arg))
          (com (viper-getCom arg)))
      (if com (viper-move-marker-locally 'viper-com-point (point)))
      ;; do not use forward-line! need to keep column
      ;; REDEFINE: remove setting line-move-visual to nil
      (with-no-warnings (next-line val))
      ;; END OF REDEFINE
      (if viper-ex-style-motion
          (if (and (eolp) (not (bolp))) (backward-char 1)))
      (setq this-command 'next-line)
      (if com (viper-execute-com 'viper-next-line val com))))


  (advice-mapc `(lambda (fun props) (advice-remove 'viper-goto-eol fun)) 'viper-goto-eol)
  (advice-add 'viper-goto-eol :around
              (lambda (orig-fun &rest args)
                (if visual-line-mode
                    (cl-letf (((symbol-function 'end-of-line) 'end-of-visual-line))
                      (apply orig-fun args))
                  (apply orig-fun args))))

  (defun check-if-on-visually-split-line ()
    (let ((first-logical-end
           (save-excursion (beginning-of-line) (end-of-visual-line) (point)))
          (current-end (save-excursion (end-of-visual-line) (point))))
      (> current-end first-logical-end)))

  (defun viper-bol-and-skip-white (arg)
    "Beginning of line at first non-white character."
    (interactive "P")
    (let ((val (viper-p-val arg))
          (com (viper-getcom arg)))
      (if com (viper-move-marker-locally 'viper-com-point (point)))
      (if visual-line-mode
          (progn 
            (if (and (check-if-on-visually-split-line))
                (if (= val 1)
                    (beginning-of-visual-line val)
                  (beginning-of-visual-line (1+ val)))
              (if (= val 1)
                  (backward-to-indentation (1- val))
                (beginning-of-visual-line (1+ val)))))
        (progn
          (forward-to-indentation (1- val))
          (if com (viper-execute-com 'viper-bol-and-skip-white val com))))))
#+end_src

** forward "enter" and "q" in vi state
good enough solution without getting too complicated
we never really type these in normal mode anyways
and these are pretty useful in some buffers

default behavior of the enter key is pretty meh anyways
q is just bound to viper-nil as well

actually could have enter browse url if point is on a url
otherwise do the normal enter action

for forwarding, layering, or context-aware keybindings see this
https://stackoverflow.com/questions/16090517/elisp-conditionally-change-keybinding/22863701#22863701
https://endlessparentheses.com/define-context-aware-keys-in-emacs.html

#+begin_src elisp
  (defun viper-call-underlying-keymap-cmd (&optional alt-cmd)
    "Temporarily change to emacs state, and see what the underlying keybinding is for `show-invoking-keys'.
     If the underlying command is like an \"insert-command\" then we either do nothing or execute ALT-CMD."
    (interactive)
    (let ((curr-state my/global-viper-state))
      (viper-change-state-to-emacs)
      (setq my/global-viper-state curr-state)
      (when-let ((local-cmd (key-binding (this-command-keys))))
        ;; need to call this BEFORE the local-cmd
        ;; in the case where local-cmd is debugger-quit
        ;; which will exit out of this function so we stay in emacs state
        (set-global-viper-state)
        (if (string-match-p "\\(.*insert-command\\|newline\\)" (symbol-name local-cmd))
            (when (commandp alt-cmd) (call-interactively alt-cmd))
          
          (call-interactively local-cmd))
        )
      ))

  (defun maybe-open-url-at-pt ()
    (interactive)
    (let ((maybe-url (help-at-pt-kbd-string)))
      (if (and maybe-url (string-match "https?://.*" maybe-url))
          (eww-browse-url maybe-url)
        (viper-call-underlying-keymap-cmd nil)
        ))
    )

  (define-key viper-vi-basic-map (kbd "RET")
              (lambda ()
                (interactive)
                (viper-call-underlying-keymap-cmd #'maybe-open-url-at-pt)
                )
              )

  (defun my/macro ()
    "Don't like the default `viper-register-macro'.
  Prefer it to behave more like vim/evil mode's version."
    (interactive)
    (if defining-kbd-macro
        (progn 
          (end-kbd-macro)
          (viper-set-register-macro my/macro-register))
      (setq my/macro-register (downcase (read-char)))
      (call-interactively #'start-kbd-macro)
      )
    )

  (define-key viper-vi-basic-map "q"
              (lambda ()
                (interactive)
                (viper-call-underlying-keymap-cmd #'my/macro)
                ))
#+end_src

** pseudo visual mode
:PROPERTIES:
:VISIBILITY: folded
:END:

*** hacky advice for next/previous line to emulate visual mode
basically a bunch of mark manipualtion essentially.

a lot of the problem is just around making sure that starting line is always marked, similar to vim
#+begin_src elisp
  (setq selected-start-line -1)
  (add-hook 'activate-mark-hook (lambda () (setq selected-start-line (line-number-at-pos))))
  ;; (advice-mapc `(lambda (fun props) (advice-remove 'next-line fun)) 'next-line)
  (advice-add 'next-line :around
              (lambda (orig-fun &rest args)
                (interactive)
                ;; because now we're not getting the last newline
                (if (< (line-number-at-pos) selected-start-line)
                    (setq extra-line-after-yank t)
                  (setq extra-line-after-yank nil))

                (if my/line-selection-p
                    (cond
                     ((= (line-number-at-pos) selected-start-line)
                      (progn
                        (beginning-of-line)
                        (set-mark-command nil)
                        (end-of-line)
                        (apply orig-fun args)
                        (end-of-line)
                        ))
                     ((= (+ (line-number-at-pos) 1) selected-start-line)
                      (progn
                        (apply orig-fun args)
                        (beginning-of-line)
                        (set-mark-command nil)
                        (end-of-line)))
                     ((< (line-number-at-pos) selected-start-line)
                      (apply orig-fun args))
                     (t 
                      (progn
                        (apply orig-fun args)
                        (end-of-line)))
                     )
                  (apply orig-fun args))))

  (advice-add 'previous-line :around
              (lambda (orig-fun &rest args)
                (interactive)
                (if (< (line-number-at-pos) selected-start-line)
                    (setq extra-line-after-yank t)
                  (setq extra-line-after-yank nil))
                (if my/line-selection-p
                    (cond 
                     ((= (line-number-at-pos) selected-start-line)
                      (progn
                        (end-of-line)
                        (set-mark-command nil)
                        (beginning-of-line)
                        (apply orig-fun args)
                        (beginning-of-line)))
                     ((> (line-number-at-pos) selected-start-line)
                      (apply orig-fun args)
                      (end-of-line))		   
                     ((= (- (line-number-at-pos) 1) selected-start-line)
                      (progn 
                        (apply orig-fun args)
                        (end-of-line)
                        (set-mark-command nil)
                        (beginning-of-line)))
                     (t
                      (progn
                        (apply orig-fun args)
                        (beginning-of-line))))
                  (apply orig-fun args))))
  ;; (advice-mapc `(lambda (fun props) (advice-remove 'previous-line fun)) 'previous-line)
#+end_src

*** pseudo visual line
have a variable for us to know if we're in the a pseudo line selection or normal selection
#+begin_src elisp  
  (setq my/line-selection-p nil)
  (setq my/lines-selected 0)

  (add-hook 'deactivate-mark-hook (lambda () (setq my/line-selection-p nil)))

  (defun my/select-lines (arg)
    "go to beginning of line and select rectangle mark and also set line selection flag"
    (interactive "p")
    (setq my/line-selection-p t)
    (beginning-of-line)
    (set-mark-command nil)
    (end-of-line))

  (defun my/set-mark-command (arg)
    "set mark, and also unset line selection flag"
    (interactive "P")
    (setq my/line-selection-p nil)
    (set-mark-command arg))

  (defun my/visual-block (arg)
    "set rectangle mark, and also unset line selection flag"
    (interactive "P")
    (setq my/line-selection-p nil)
    (rectangle-mark-mode arg))
#+end_src

v or V will set that line selection var accordingly
deactivate mark on esc
#+begin_src elisp
  (define-key viper-vi-basic-map "v" nil)
  (define-key viper-vi-basic-map "v" #'my/set-mark-command)
  (define-key viper-vi-basic-map "V" nil)
  (define-key viper-vi-basic-map "V" #'my/select-lines)
  (define-key viper-vi-basic-map (kbd "C-v") #'my/visual-block)
#+end_src

*** viper-ex to automatically use region if active
#+begin_src elisp
  ;;(advice-mapc `(lambda (fun props) (advice-remove 'viper-ex fun)) 'viper-ex)
  (advice-add 'viper-ex :around
              (lambda (orig-fun &rest args)
                (let ((current-prefix-arg t))
                  (if (use-region-p) (apply orig-fun current-prefix-arg args)
                    (apply orig-fun args)))))
#+end_src

*** join lines 
if the region exists then we jump to the beginning of the region and merge the number of lines selected
#+begin_src elisp
  ;; (advice-mapc `(lambda (fun props) (advice-remove 'viper-join-lines fun)) 'viper-join-lines)
  (defun viper-join-lines-region-advice (orig-fun arg &rest args)
    (interactive "P")
    (if (use-region-p)
        (let* ((start (region-beginning))
               (end (region-end))
               (numlines (count-lines start end)))
          (goto-char start)
          (apply orig-fun `(,numlines)))
      (apply orig-fun `(,arg))))
  (advice-add 'viper-join-lines :around #'viper-join-lines-region-advice)
#+end_src

I hate how joining lines adds spaces between the lines joined
still kinda WIP need to think about this one
#+begin_src elisp :tangle no
  (defun viper-join-lines-advice (orig-fun &rest args)
    (interactive "*P")
    (cl-letf (((symbol-function 'looking-at)
               (lambda (regexp &optional _)
                 (looking-at (rx-to-string
                              `(: (or "[" "]" "(" ")" "," "{" "}")))))))
      (apply orig-fun args)))

  (advice-remove 'viper-join-lines #'viper-join-lines-advice)
  (advice-add 'viper-join-lines :around #'viper-join-lines-advice)
#+end_src


*** hacky stuff to make yanking/killing work for our line visual selection
#+begin_src elisp
  (setq my/line-yank-p nil)
  (defun viper-delete-region-or-motion-command (arg)
    "convenience function for deleting a region, including rectangles"
    (interactive "P")
    (if (use-region-p)
        (let ((start (region-beginning)) (end (region-end)))
          (if rectangle-mark-mode
              (progn 
                (setq my/line-yank-p nil)
                (kill-rectangle start end arg))
            (progn
              ;; this hacky bit is because when we move backwards from point, we want to include the position we started the mark on like in vim
              ;; even though visually we won't see it, functionally it'll behave the same
              (if (> (point) (mark-marker))
                  (forward-char)
                (let ((m (mark-marker)))
                  (set-marker m (1+ m))))
              (if my/line-selection-p
                  (setq my/line-yank-p t)
                (setq my/line-yank-p nil))
              (kill-region start end t))))
      (viper-command-argument arg)))

  (defun viper-copy-region-or-motion-command (arg)
    "convenience function for yanking a region, including rectangles"
    (interactive "P")
    (if (use-region-p)
        (let ((start (region-beginning)) (end (region-end)))
          (if rectangle-mark-mode
              (progn 
                (setq my/line-yank-p nil)
                (copy-rectangle-as-kill start end))
            (progn
              (if (> (point) (mark-marker))
                  (forward-char)
                (let ((m (mark-marker)))
                  (set-marker m (1+ m))))
              (if my/line-selection-p
                  (setq my/line-yank-p t)
                (setq my/line-yank-p nil))
              (copy-region-as-kill start end t)
              (when (> (point) (mark-marker)) (backward-char)))
            ))
      (viper-command-argument arg)))

  (defun viper-paste-into-region (arg)
    "if region is active, delete region before pasting
  respects rectangle mode in a similar way to vim/doom"
    (interactive "P")
    (cond (my/line-yank-p
           (progn
             (if (use-region-p)
                 (delete-active-region)
               (viper-open-line nil))
             (viper-change-state-to-vi) ; cause viper-open-line takes us to insert
             (yank)

             ;; we want the newline at the end when the yanked text is multiline
             ;; but we want to remove the additional newline if the yanked text is
             ;; just a single line
             (when (not (string-match ".*\n.+" (cl-first kill-ring)))
               (forward-line)
               (delete-char -1)
               (forward-line -1)
               (end-of-line))
             ))
          ((and (not killed-rectangle) (use-region-p))
           (progn
             (let ((start (region-beginning)))
               ;; vim pastes "after" the cursor, at least that's what I'm used to
               (forward-char)
               (delete-active-region)
               (yank))))
          (killed-rectangle
           (progn
             (forward-char)
             (yank-rectangle)
             (setq killed-rectangle nil)))
          ;; if we're on an empty line, we want to just yank without moving forward
          (t (unless (eq (point) (line-end-position)) (forward-char)) (yank arg))))

  (define-key viper-vi-basic-map "d" #'viper-delete-region-or-motion-command)
  (define-key viper-vi-basic-map "y" #'viper-copy-region-or-motion-command)
  (define-key viper-vi-basic-map "p" #'viper-paste-into-region)
  (define-key viper-vi-basic-map (kbd "s-v") #'viper-paste-into-region)
  (define-key viper-insert-basic-map (kbd "s-v") #'viper-paste-into-region)
  (define-key global-map (kbd "s-v") #'viper-paste-into-region)
#+end_src

** dumb evil surround
#+begin_src elisp
  (defun dumb-change-surrounding ()
    "Basic surrounding change function.
          The first char read, is the surrounding to find.
          The second char read, is the new surrounding character.
          Some DWIM here regarding parentheses and brackets."
    (interactive)
    (let* ((delim (char-to-string (read-char "find")))
           (replace-start-1 (char-to-string (read-char "replace")))
           (replace-start (cond ((string= replace-start-1 "]") "[") ;; replacing closing with opening
                                ((string= replace-start-1 ")") "(")
                                (t replace-start-1)))

           (replace-end (cond ((string= replace-start "[") "]") ;; replacing opening with closing
                              ((string= replace-start "(") ")")
                              (t replace-start))))

      (cond ((or (string= delim "(") (string= delim "["))
             (search-backward delim (save-excursion (backward-paragraph) (point)))
             (save-excursion (forward-sexp) (delete-char -1)
                             (insert replace-end))
             (delete-char 1)
             (insert replace-start))
            (t
             (save-excursion
               (search-backward delim (save-excursion (backward-paragraph) (point)))
               (delete-char 1)
               (insert replace-start)
               (search-forward delim (save-excursion (forward-paragraph) (point)))
               (delete-char -1)
               (insert replace-end)
               )
             )
            )))

  (defun viper-command-advice (orig-fun &rest args)
    "Frontload one of the read-char calls so we can attach our own functions.
      Subsequent calls to read-char use the original implementation.
    See: https://stackoverflow.com/questions/67850020/how-to-call-the-original-function-in-a-cl-letf-overridden-function"
    (let ((char (read-char))
          (num-read-char-calls 0))
      (cond ((and (eq last-command-event ?c) (viper= ?s char)) (dumb-change-surrounding))
            ((and (eq last-command-event ?<) (viper= ?< char))
             (indent-rigidly (line-beginning-position) (line-end-position) (- tab-width)))
            ((and (eq last-command-event ?>) (viper= ?> char))
             (indent-rigidly (line-beginning-position) (line-end-position) tab-width))
            (t
             (cl-letf ((old-read-char (symbol-function 'read-char))
                       ((symbol-function 'read-char)
                        (lambda (&rest _)
                          (if (gt num-read-char-calls 0)
                              (progn 
                                (funcall old-read-char))
                            (progn
                              (setq num-read-char-calls (1+ num-read-char-calls))
                              char)))))
               (apply orig-fun args))
             ))))

  (define-key viper-vi-basic-map (kbd ">") (lambda ()
                                             (interactive)
                                             (if (region-active-p)
                                                 (let ((beg (region-beginning))
                                                       (end (region-end))
                                                       (deactivate-mark nil))
                                                   (indent-rigidly (region-beginning)
                                                                   (region-end) 
                                                                   tab-width))
                                               (call-interactively #'viper-command-argument))))

  (define-key viper-vi-basic-map (kbd "<") (lambda ()
                                             (interactive)
                                             (if (region-active-p)
                                                 (let ((beg (region-beginning))
                                                       (end (region-end))
                                                       (deactivate-mark nil))
                                                   (indent-rigidly (region-beginning)
                                                                   (region-end) 
                                                                   (- tab-width)))
                                               (call-interactively #'viper-command-argument))))


  (advice-add 'viper-command-argument :around #'viper-command-advice)
#+end_src

** undo redo isearch backwards
thank god for undo-only but emacs > 28 only
need to remap isearch-backward since i wanna use C-r for redo
#+begin_src elisp
  (define-key viper-vi-basic-map "u" #'undo-only)
  (define-key viper-vi-basic-map (kbd "C-r") #'undo-redo)
  (define-key viper-vi-basic-map (kbd "C-S-r")  #'isearch-backward)
  ;; replaces move-to-window-line-top-bottom but we use H M L in vi anyways
  (define-key viper-vi-basic-map (kbd "M-r")  #'isearch-backward) 
  (define-key viper-vi-basic-map (kbd "C-M-r") #'isearch-backward-regexp)
#+end_src

** pseudo "leader" prefix
:PROPERTIES:
:VISIBILITY: children
:END:
#+begin_src elisp
  (viper-map! :leader ","
              (lambda () (interactive)
                (project-switch-to-buffer (project--read-project-buffer)))
              "<" #'switch-to-buffer
              "u" #'universal-argument
              "F" #'project-find-file "G" #'project-find-regexp
              "X" #'org-capture
              "x" (lambda () (interactive)
                    (split-window-vertically)
                    (windmove-down)
                    (scratch-buffer)))
#+end_src

*** "project" prefix
#+begin_src elisp
  (viper-map! :leader
              "pp" #'project-switch-project "pd" #'project-forget-project
              "pe" #'project-eshell "ps" #'project-shell 
              "px" #'flymake-show-project-diagnostics)

#+end_src

**** command to use previous search
#+begin_src elisp
  (viper-map! :leader "'"
              (lambda () (interactive)
                (minibuffer-with-setup-hook
                    (lambda () (previous-history-element 1))
                  (call-interactively 'project-find-regexp))))
#+end_src

*** "help" prefix
#+begin_src elisp
  (viper-map! :leader
              "hk" #'describe-key
              "hK" #'describe-keymap
              "hf" #'describe-function
              "hv" #'describe-variable
              "hm" #'describe-mode
              "ho" #'describe-symbol)
#+end_src

*** "buffer" prefix
#+begin_src elisp
  (viper-map! :leader
              "br" #'revert-buffer
              "bp" #'previous-buffer
              "bn" #'next-buffer
              "bi" #'ibuffer)
#+end_src
                
*** "tab" bar prefix
#+begin_src elisp
  (viper-map! :leader
              "<tab>n" #'tab-bar-new-tab
              "<tab>d" #'tab-bar-close-tab
              "<tab>r" #'tab-bar-rename-tab
              "<tab>." #'tab-bar-switch-to-tab
              "<tab>[" #'tab-bar-switch-to-next-tab
              "<tab>]" #'tab-bar-switch-to-prev-tab)
#+end_src 

*** "notes" prefix (bookmarks)
in lieu of org-roam, use bookmarks
pretty handy tbh
#+begin_src elisp
  (viper-map! :leader 
              "nrl" #'list-bookmarks
              "nri" #'bookmark-set
              "nrn" #'bookmark-set
              "nrd" #'bookmark-delete)
#+end_src
*** notes/denote-lite
just basically do a completing read on a folder we specify
#+begin_srC elisp
  (setq notes-directory "~/notes/")

  (defun my/open-simple-notes ()
    (interactive)
    (let* ((files (directory-files notes-directory t directory-files-no-dot-files-regexp))
           (open-or-create (completing-read "open/create note:" files)))
      (if (memq open-or-create files)
          (find-file open-or-create)
        (find-file (concat notes-directory open-or-create))
        )
      )
    )
  (viper-map! :leader "do" #'my/open-simple-notes)
#+end_src

*** news prefix
#+begin_src elisp
  (viper-map! :leader "Nt" #'newsticker-treeview)
#+end_src

*** pseudo "files" "f" prefix
#+begin_src elisp
  (viper-map! :leader "ff" #'find-file)
#+end_src

*** git prefix
magit has a :defer in the use-package declaration so that should override this binding if we choose to install magit

usually want to call it from the vc root directory, unless we want something specific we can do that ourselves
#+begin_src elisp
  (viper-map! :leader "gg" (lambda (arg) (interactive "P")
                                          (vc-dir
                                           (if arg
                                               (file-truename
                                                (read-directory-name "VC status for directory: "
                                                                     default-directory nil t nil))
                                             (or (vc-root-dir) default-directory))
                                           (when (equal arg '(16))
                                             (intern
                                              (completing-read
                                               "Use VC backend: "
                                               (mapcar (lambda (b) (list (symbol-name b)))
                                                       vc-handled-backends)
                                               nil t nil nil))
                                             )
                                           )))
#+end_src

** eglot/xref
#+begin_src elisp
  (use-package xref :defer t
    :config
    (viper-map! :leader "cd" #'xref-find-definitions
                "cD" #'xref-find-references
                "cj" #'xref-find-apropos

                :n "gd" (lambda ()
                          (interactive)
                          (condition-case err
                              (xref-find-definitions
                               (let ((thing (thing-at-point 'symbol)))
                                 (and thing (substring-no-properties thing))))
                            (error
                             ;; fallback to dumb jump
                             (message "%s fallback" err)
                             (unless (member 'dumb-jump-xref-activate xref-backend-functions)
                               (let ((xref-backend-functions '(dumb-jump-xref-activate)))
                                 (xref-find-definitions
                                  (xref-backend-identifier-at-point 'dumb-jump-xref-activate)))
                               ))
                            ))
                "gD" #'xref-find-references
                )
    )
  (use-package eglot :defer t
    :config
    (viper-map! :leader "cr" #'eglot-rename
                "cf" #'eglot-format-buffer
                "ca" #'eglot-code-actions
                :n "gI" #'eglot-find-implementation
                ))
#+end_src


** development
#+begin_src elisp
  (viper-map! :n "K" #'eldoc)
  (define-key prog-mode-map (kbd "C-<return>") #'default-indent-new-line)
#+end_src

** show-paren
#+begin_src elisp
  (setq show-paren-highlight-openparen t)
  (setq show-paren-when-point-inside-paren t)
  (defun show-paren--locate-near-paren-ad (orig-fun &rest args)
    "Locate an unescaped paren \"near\" point to show.
  If one is found, return the cons (DIR . OUTSIDE), where DIR is 1
  for an open paren, -1 for a close paren, and OUTSIDE is the buffer
  position of the outside of the paren.  Otherwise return nil."
    (if (eq my/global-viper-state 'vi)
        (let* ((before (show-paren--categorize-paren (point))))
          (when (or
                 (eq (car before) 1)
                 (eq (car before) -1))
            before))
      (funcall orig-fun)))

  (advice-add 'show-paren--locate-near-paren :around #'show-paren--locate-near-paren-ad)
#+end_src

** window positioning commands
*** respect scroll margin
#+begin_src elisp
  (viper-map! :n "H"
              (lambda (arg) (interactive "P")
                (if arg (viper-window-top arg)
                  (viper-window-top (+ scroll-margin 1))))
              "L"
              (lambda (arg) (interactive "P")
                (if arg (viper-window-bottom arg)
                  (viper-window-bottom (+ scroll-margin 1))))
              "zz" #'recenter-top-bottom)
#+end_src

*** goto line not deactivating mark
#+begin_src elisp
  (advice-mapc `(lambda (fun props) (advice-remove 'viper-goto-line fun)) 'viper-goto-line)

  ;; if the region is active already, we don't want to move mark or else it behaves strangely with out selection
  (defun my/advise-viper-goto-line (orig-fun &rest args)
    (if (region-active-p)
        (cl-letf (((symbol-function 'deactivate-mark)
                   (lambda (&optional _) nil))
                  ((symbol-function 'viper-move-marker-locally)
                   (lambda (_ _ &optional _) nil))
                  ((symbol-function 'push-mark)
                   (lambda (&optional _ _ _) nil)))
          (let ((prev-line-number (line-number-at-pos)))
            (apply orig-fun args)

            (when my/line-selection-p
              ;; this means we're moving up so need to go to beg of line at the end
              (if (and (car args) (< (car args) prev-line-number))
                  (beginning-of-line)
                (end-of-line)))))
      (apply orig-fun args)))

  (advice-add 'viper-goto-line :around #'my/advise-viper-goto-line)
#+end_src

** code folding
#+begin_src elisp
  (use-package hideshow
    :config
    (viper-map! :n "zC" #'hs-hide-all "zO" #'hs-show-all
                "zo" #'hs-show-block "zc" #'hs-hide-block
                "za" #'hs-toggle-hiding))
#+end_src

** advise viper-brac/ket-function
holy shit lol..
viper-cmd.el:viper-brac-function or viper-ket-function

basically dynamically binding the read-char to return the initial read-char in the viper call so that we don't double prompt user for read-char

TODO: maybe make an easier way to add new bindings
otherwise this works lol
#+begin_src elisp
  ;; local alist that can be used as part of a major mode hook to
  ;; add pseudo keybinds to brac and ket
  (setq brac-char-cmd-alist '())
  ;; [ - backwards
  (defun viper-brac-advice (orig-fun &rest args)
    (let ((char (read-char)))
      (cond ((viper= ?b char) (previous-buffer))
            ((viper= ?t char) (tab-bar-switch-to-prev-tab))
            ((viper= ?e char) (call-interactively 'flymake-goto-prev-error))
            (t
             (let ((other-cmd
                    (cdr (cl-find-if (lambda (e)
                                       (viper= (car e) char))
                                     brac-char-cmd-alist))))
               (if other-cmd
                   (call-interactively other-cmd)
                 ;; hack so that we can override read-char and only need input once
                 (cl-letf (((symbol-function 'read-char) (lambda (_ _ _) char)))
                   (apply orig-fun args))))))))
  (advice-add 'viper-brac-function :around #'viper-brac-advice)

  (setq ket-char-cmd-alist '())
  ;; ] - forwards
  (defun viper-ket-advice (orig-fun &rest args)
    (let ((char (read-char)))
      (cond ((viper= ?b char) (next-buffer))
            ((viper= ?t char) (tab-bar-switch-to-next-tab))
            ((viper= ?e char) (call-interactively 'flymake-goto-next-error))
            (t
             (let ((other-cmd
                    (cdr (cl-find-if (lambda (e)
                                       (viper= (car e) char))
                                     ket-char-cmd-alist))))
               (if other-cmd
                   (call-interactively other-cmd)
                 ;; hack so that we can override read-char and only need input once
                 (cl-letf (((symbol-function 'read-char) (lambda (_ _ _) char)))
                   (apply orig-fun args))))))))
  (advice-add 'viper-ket-function :around #'viper-ket-advice)
#+end_src

** redefine viper-maybe-checkout to use ediff-file-checked-in-p
This is why when we save a file it asks us to check it out cause ex-write uses its own viper-file-checked-in-p
instead of ediff's version
Need to just redefine the maybe checkout function

See these:
[[file:/opt/homebrew/Cellar/emacs-plus@29/29.2/share/emacs/29.2/lisp/emulation/viper-ex.el::viper-maybe-checkout (current-buffer)]]
[[file:/opt/homebrew/Cellar/emacs-plus@29/29.2/share/emacs/29.2/lisp/emulation/viper-util.el::defun viper-maybe-checkout (buf]]
[[file:/opt/homebrew/Cellar/emacs-plus@29/29.2/share/emacs/29.2/lisp/vc/ediff-util.el::defun ediff-file-checked-in-p (file]]

#+begin_src elisp
  (use-package ediff :autoload (ediff-file-checked-in-p))

  (defun viper-maybe-checkout (buf)
    (let ((file (expand-file-name (buffer-file-name buf)))
          (checkout-function (key-binding "\C-x\C-q")))
      (if (and (ediff-file-checked-in-p file)
               (or (beep 1) t)
               (y-or-n-p
                (format
                 "File %s is checked in.  Check it out? "
                 (abbreviate-file-name file))))
          (with-current-buffer buf
            (command-execute checkout-function)))))
#+end_src

** extra VC keybindings
note after doing =vc-next-action=, running =vc-git-log-edit-toggle-amend= toggles the current commit to be an amend commit

#+begin_src elisp
  (define-key global-map "\C-xvf" #'vc-pull)
  (define-key global-map "\C-xvF" #'my/vc-git-fetch)

  (define-key global-map "\C-xve" #'my/vc-git-editor-command)
  (define-key global-map "\C-xvRi" #'my/vc-git-rebase-i)
  (define-key global-map "\C-xvRa" #'my/vc-git-rebase-abort)
  (define-key global-map "\C-xvRc" #'my/vc-git-rebase-continue)

  (define-key global-map "\C-xvSs" #'vc-git-stash)
  (define-key global-map "\C-xvSS" #'vc-git-stash-show)
  (define-key global-map "\C-xvSp" #'vc-git-stash-pop)
  (define-key global-map "\C-xvSa" #'vc-git-stash-apply)
  (define-key global-map "\C-xvSd" #'vc-git-stash-delete)
  (use-package vc-git :defer t
    :config
    (setq my/vc-log-vi-state-modify-map
          (make-composed-keymap
           nil
           (make-composed-keymap
            (list my/viper-vi-basic-motion-keymap
                  my/viper-vi-motion-g-keymap
                  my/viper-vi-motion-leader-keymap)
            vc-git-log-view-mode-map)))
    (define-key my/vc-log-vi-state-modify-map (kbd "C-j") #'log-view-msg-next)
    (define-key my/vc-log-vi-state-modify-map (kbd "C-k") #'log-view-msg-prev)
    (viper-modify-major-mode 'vc-git-log-view-mode 'vi-state my/vc-log-vi-state-modify-map))
#+end_src

*** VC Dir mode
#+begin_src elisp
  (use-package vc-dir :defer t
    :config
    (viper-map! :mode 'vc-dir-mode
                :n "x" #'vc-dir-hide-state)
    )
#+end_src

*** diff mode
#+begin_src elisp
  (use-package diff-mode :defer t
    :config
    (add-hook 'diff-mode-hook #'outline-minor-mode)
    (set-face-foreground 'diff-refine-added "green1")
    (set-face-background 'diff-refine-added "green4")

    (set-face-foreground 'diff-refine-removed "red1")
    (set-face-background 'diff-refine-removed "red4"))

  (use-package diff-mode :after outline
    :config
    (viper-map! :mode 'diff-mode
                :n "<tab>" #'outline-cycle
                "<backtab>" #'outline-cycle-buffer
                "<return>" #'diff-goto-source
                "C-j" #'diff-hunk-next
                "C-k" #'diff-hunk-prev
                "C-S-j" #'diff-file-next
                "C-S-k" #'diff-file-prev))
#+end_src

*** annotate
#+begin_src elisp
  (use-package vc-annotate :defer t
    :config
    (viper-map! :mode 'vc-annotate-mode
                :n "C-j" #'vc-annotate-next-revision
                "C-k" #'vc-annotate-prev-revision
                "L" #'vc-annotate-show-log-revision-at-line))
  (add-hook 'vc-annotate-mode-hook #'viper-mode)
#+end_src

** dired
#+begin_src elisp
  (use-package dired :defer t
    :config
    (add-hook 'dired-mode-hook #'auto-revert-mode)
    (viper-map! :mode 'dired-mode
                :n "-" #'dired-up-directory
                "C" #'dired-do-copy
                "K" #'dired-kill-subdir))
#+end_src

** ibuffer
#+begin_src elisp
  (use-package ibuffer :defer t
    :config
    (viper-map! :mode 'ibuffer-mode :n "sp" #'ibuffer-pop-filter "sn" #'ibuffer-filter-by-name))
#+end_src

** elisp eval buffer
#+begin_src elisp
  (viper-map! :mode 'emacs-lisp-mode :n "SPC meb" #'eval-buffer)
#+end_src

** comint mode
#+begin_src elisp
  (use-package comint :defer t
    :config
    (define-key viper-comint-mode-modifier-map (kbd "C-d") #'viper-scroll-up))
#+end_src

* yaml
#+begin_src elisp
  (add-to-list 'auto-mode-alist '("\\.yaml\\'" . yaml-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-ts-mode))
#+end_src

* Org

grabbed the src block fontification from here
https://orgmode.org/worg/org-contrib/babel/examples/fontify-src-code-blocks.html

Just a bunch of convenience keymaps, some faces, and some basic settings
#+begin_src elisp
  (setq org-directory "~/orgmode/")
  (setq org-attach-id-dir (concat (file-name-as-directory org-directory) (file-name-as-directory ".attach")))
  (setq org-todo-keywords '((sequence "TODO(t)" "WIP(w)" "|" "DONE" "CANCELLED")))
  (setq org-attach-use-interitance t)

  (setq org-startup-indented t)
  (setq org-indent-indentation-per-level 4)
  (setq org-startup-folded nil) ;; to respect VISIBILITY property just can't be 'showeverything, see: org-cycle-set-startup-visibility

  (setq org-agenda-files (list "~/orgmode/notes/20240118T135401--work-tracking__agenda.org"))
  ;; steal doom's todo keywords
  (setq org-todo-keywords
        '((sequence
           "TODO(t)"  ; A task that needs doing & is ready to do
           "PROJ(p)"  ; A project, which usually contains other tasks
           "LOOP(r)"  ; A recurring task
           "STRT(s)"  ; A task that is in progress
           "WAIT(w)"  ; Something external is holding up this task
           "HOLD(h)"  ; This task is paused/on hold because of me
           "IDEA(i)"  ; An unconfirmed and unapproved task or notion
           "|"
           "DONE(d)"  ; Task successfully completed
           "KILL(k)") ; Task was cancelled, aborted, or is no longer applicable
          (sequence
           "[ ](T)"   ; A task that needs doing
           "[-](S)"   ; Task is in progress
           "[?](W)"   ; Task is being held up or paused
           "|"
           "[X](D)")  ; Task was completed
          (sequence
           "|"
           "OKAY(o)"
           "YES(y)"
           "NO(n)"))
        org-todo-keyword-faces
        '(("[-]"  . +org-todo-active)
          ("STRT" . +org-todo-active)
          ("[?]"  . +org-todo-onhold)
          ("WAIT" . +org-todo-onhold)
          ("HOLD" . +org-todo-onhold)
          ("PROJ" . +org-todo-project)
          ("NO"   . +org-todo-cancel)
          ("KILL" . +org-todo-cancel)))
  (setq org-agenda-window-setup 'current-window)
  (setq org-agenda-restore-windows-after-quit t)

  ;; allow dabbrev expand on tab when in insert mode
  (defun line-before-point-empty-p ()
    (string-blank-p (buffer-substring-no-properties (point-at-bol) (point))))

  (use-package org :defer t
    :config
    (progn
      (setq org-image-actual-width '(300))
      (setq org-goto-interface 'outline-path-completionp)
      (setq org-outline-path-complete-in-steps nil)
      (setq org-return-follows-link t)
      (advice-add 'org-agenda-get-restriction-and-command :around
                  (lambda (orig-fun &rest args)
                    (cl-letf (((symbol-function 'delete-other-windows) (lambda () nil)))
                      (apply orig-fun args))))
      (add-to-list 'display-buffer-alist
                   '("\\*Agenda Commands\\*"
                     (display-buffer-in-side-window)))
      (add-to-list 'display-buffer-alist
                   '("\\*Calendar\\*"
                     (display-buffer-in-side-window)))
      (add-to-list 'display-buffer-alist
                   '("\\*Org Src.*\\*"
                     (display-buffer-in-side-window)
                     (window-height . 0.4)))

      ;; fix newline and indent in src blocks, took this from doom
      (defun org-fix-newline-and-indent-in-src-blocks-ad (&rest _args)
        (when (and org-src-tab-acts-natively
                   (org-in-src-block-p t))
          (save-window-excursion
            (save-excursion
              (org-babel-do-in-edit-buffer
               (set-mark (point-min))
               (goto-char (point-max))
               (let ((inhibit-message t))
                 (call-interactively #'indent-region))))))
        )
      (advice-add #'org-return :after #'org-fix-newline-and-indent-in-src-blocks-ad)
      
      (viper-map! :mode 'org-mode
                  :n "zi" #'org-toggle-inline-images
                  "SPC si" #'org-goto "SPC oaa" #'org-agenda
                  "SPC msl" #'org-demote-subtree "SPC msh" #'org-promote-subtree
                  "SPC msk" #'org-move-subtree-up "SPC msj" #'org-move-subtree-down
                  "SPC maa" #'org-attach "SPC mA" #'org-archive-subtree
                  "SPC mds" #'org-schedule "SPC mdd" #'org-deadline
                  "SPC msr" #'org-refile "SPC mll" #'org-insert-link
                  "SPC nl" #'org-store-link
                  "<tab>" (lambda ()
                            (interactive)
                            ;; want org cycle if region active for indenting, or heading for collapsing
                            (if (or (org-at-heading-p) (region-active-p) (org-at-property-block-p) (org-at-property-drawer-p) (org-at-block-p) (org-at-drawer-p))
                                (call-interactively (lookup-key org-mode-map "\t"))
                              (call-interactively (lookup-key viper-vi-basic-map [C-i]))))
                  )
      ))
#+end_src

* "vendored" packages
#+begin_src elisp
  (require 'dash "~/.emacs.d/vendor/dash.el")
  (require 's "~/.emacs.d/vendor/s.el")
  (require 'dumb-jump "~/.emacs.d/vendor/dumb-jump.el")
  (require 'coterm "~/.emacs.d/vendor/coterm.el")
  (require 'wgrep "~/.emacs.d/vendor/wgrep.el")
  (require 'vundo "~/.emacs.d/vendor/vundo.el")
  (require 'avy "~/.emacs.d/vendor/avy.el")
#+end_src

** coterm
#+begin_src elisp
(coterm-mode)
#+end_src

** avy
avy jumping is so nice
https://github.com/abo-abo/avy

Otherwise we just use isearch and standard vi f/F motions
#+begin_src elisp
  (use-package avy
    :config
    (define-key viper-vi-basic-map "gss" #'avy-goto-char-2)
    (define-key viper-vi-basic-map "gs/" #'avy-goto-char-timer)
    (define-key viper-vi-basic-map "gs " #'avy-goto-char-timer))
#+end_src

** vundo
#+begin_src elisp
  (use-package vundo
    :config
    (setq vundo-vi-modify-map vundo-mode-map)
    (define-key vundo-vi-modify-map "h" #'vundo-backward)
    (define-key vundo-vi-modify-map "l" #'vundo-forward)
    (define-key vundo-vi-modify-map "k" #'vundo-previous)
    (define-key vundo-vi-modify-map "j" #'vundo-next)
    (define-key vundo-vi-modify-map "d" #'vundo-diff)
    (viper-modify-major-mode 'vundo-mode 'vi-state vundo-vi-modify-map))
#+end_src

* (blasphemy) external packages                                    :external:
:PROPERTIES:
:HEADER-ARGS: :tangle no
:END:
Need to install these seperately, but some configuration here
These packages are all good enough to be built in to be honest

Lets at least stick with gnu/nongnu elpa

disable native comp warnings buffer from popping up
#+begin_src elisp
  (setq native-comp-async-report-warnings-errors 'silent)
#+end_src

** modus
#+begin_src elisp
  (use-package modus-themes :ensure t :pin gnu)
#+end_src

** minibuffer
The classic minibuffer trifecta, should we not want to use the built in facilities
*** vertico
#+begin_src elisp
  (use-package vertico :ensure t :pin gnu :after (icomplete)
    :config
    (add-hook 'minibuffer-setup-hook #'vertico-repeat-save)
    (setq vertico-cycle t)
    (setq vertico-count 12)
    (setq vertico-resize nil)
    (fido-vertical-mode -1)
    (icomplete-mode -1)
    (define-key vertico-map (kbd "RET") #'vertico-exit)
    (viper-map! :leader "'" #'vertico-repeat)
    (vertico-mode))
#+end_src

*** orderless
https://github.com/oantolin/orderless
The default custom partial-completion stuff we have works well enough that we might not need orderless anymore but meh
#+begin_src elisp
  (use-package orderless :ensure t :pin gnu :after (icomplete)
    :config
    ;; stolen from doom
    (defun +vertico-orderless-dispatch (pattern _index _total)
      (cond
       ;; Ensure $ works with Consult commands, which add disambiguation suffixess
       ((string-suffix-p "$" pattern)
        `(orderless-regexp . ,(concat (substring pattern 0 -1) "[\x200000-\x300000]*$")))
       ;; Ignore single !
       ((string= "!" pattern) `(orderless-literal . ""))
       ;; Without literal
       ((string-prefix-p "!" pattern) `(orderless-without-literal . ,(substring pattern 1)))
       ;; Character folding
       ((string-prefix-p "%" pattern) `(char-fold-to-regexp . ,(substring pattern 1)))
       ((string-suffix-p "%" pattern) `(char-fold-to-regexp . ,(substring pattern 0 -1)))
       ;; Initialism matching
       ((string-prefix-p "`" pattern) `(orderless-initialism . ,(substring pattern 1)))
       ((string-suffix-p "`" pattern) `(orderless-initialism . ,(substring pattern 0 -1)))
       ;; Literal matching
       ((string-prefix-p "=" pattern) `(orderless-literal . ,(substring pattern 1)))
       ((string-suffix-p "=" pattern) `(orderless-literal . ,(substring pattern 0 -1)))
       ;; Flex matching
       ((string-prefix-p "~" pattern) `(orderless-flex . ,(substring pattern 1)))
       ((string-suffix-p "~" pattern) `(orderless-flex . ,(substring pattern 0 -1)))))

    (setq completion-styles '(orderless basic) completion-category-overrides nil completion-category-defaults nil)
    (setq orderless-style-dispatchers '(+vertico-orderless-dispatch))
    (setq orderless-component-separator "[ &]")
    (define-key icomplete-minibuffer-map " " #'self-insert-command)
    (remove-hook 'icomplete-minibuffer-setup-hook #'icomplete-partial-completion-setup)
    (remove-hook 'icomplete-minibuffer-setup-hook 'my-icomplete-styles)
    (defun my-icomplete-styles () (setq-local completion-styles '(orderless basic)))
    (remove-hook 'icomplete-minibuffer-setup-hook #'icomplete-partial-completion-setup)
    (add-hook 'icomplete-minibuffer-setup-hook 'my-icomplete-styles))
#+end_src


*** marginalia
#+begin_src elisp
  (use-package marginalia :ensure t :pin gnu
    :config (marginalia-mode))
#+end_src

*** consult
#+begin_src elisp
  (use-package consult :ensure t :pin gnu
    :config
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref
          completion-in-region-function #'consult-completion-in-region)
    (viper-map! :leader "," #'consult-project-buffer
                "G"
                (lambda () (interactive)
                  (call-interactively (if (executable-find "rg") #'consult-ripgrep #'consult-grep)))
                "cx" #'consult-flymake
                "ss" #'consult-line
                "si" #'consult-imenu))
#+end_src

*** embark
#+begin_src elisp
  (use-package embark :ensure t :pin gnu
    :bind
    (("C-." . embark-act)
     ("C-;" . embark-dwim)
     ("C-c C-;" . embark-export)
     ("C-h B" . embark-bindings))
    :init
    (setq prefix-help-command #'embark-prefix-help-command))

  (use-package embark-consult
    :ensure t ; only need to install it, embark loads it after consult if found
    :after embark
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

*** wgrep
#+begin_src elisp
  (use-package wgrep :ensure t)
#+end_src

** corfu completion
#+begin_src elisp
  (use-package cape :ensure t :pin gnu)

  (use-package corfu :ensure t
    :init (global-corfu-mode)
    :config
    (advice-add 'eglot-completion-at-point :around #'cape-wrap-buster)
    (advice-add 'eglot-completion-at-point :around #'cape-wrap-noninterruptible)

    (setq corfu-auto t)
    (setq corfu-cycle t)
    (setq corfu-quit-no-match t)
    (setq corfu-quit-at-boundary t)
    (defun corfu-move-to-minibuffer ()
      (interactive)
      (pcase completion-in-region--data
        (`(,beg ,end ,table ,pred ,extras)
         (let ((completion-extra-properties extras)
               completion-cycle-threshold completion-cycling)
           (consult-completion-in-region beg end table pred)))))
    (define-key corfu-map (kbd "M-m") #'corfu-move-to-minibuffer)
    (define-key corfu-map (kbd "C-M-i") #'corfu-move-to-minibuffer)
    (define-key corfu-map (kbd "M-<tab>") #'corfu-move-to-minibuffer)
    (add-to-list 'corfu-continue-commands #'corfu-move-to-minibuffer))
#+end_src

#+begin_src elisp
  (use-package corfu-terminal :ensure t
    :config
    (unless (display-graphic-p) (corfu-terminal-mode)))
#+end_src

** bash completion
#+begin_src elisp
  (use-package bash-completion :ensure t
    :config
    (bash-completion-setup)
    
    (defun eshell-bash-capf ()
      (bash-completion-dynamic-complete-nocomint
       eshell-last-output-end))

    (add-hook 'eshell-mode-hook
              (lambda ()
                (add-hook 'completion-at-point-functions 'eshell-bash-capf nil t))))
#+end_src

** avy
avy jumping is so nice
https://github.com/abo-abo/avy

Otherwise we just use isearch and standard vi f/F motions
#+begin_src elisp
  (use-package avy :ensure t :pin gnu :defer 2
    :config
    (define-key viper-vi-basic-map "gss" #'avy-goto-char-2)
    (define-key viper-vi-basic-map "gs/" #'avy-goto-char-timer)
    (define-key viper-vi-basic-map "gs " #'avy-goto-char-timer))
#+end_src

** vundo

#+begin_src elisp
  (use-package vundo :ensure t :pin gnu
    :config
    (setq vundo-vi-modify-map vundo-mode-map)
    (define-key vundo-vi-modify-map "h" #'vundo-backward)
    (define-key vundo-vi-modify-map "l" #'vundo-forward)
    (define-key vundo-vi-modify-map "k" #'vundo-previous)
    (define-key vundo-vi-modify-map "j" #'vundo-next)
    (define-key vundo-vi-modify-map "d" #'vundo-diff)
    (viper-modify-major-mode 'vundo-mode 'vi-state vundo-vi-modify-map))
#+end_src

** my own hurl mode :)
well this oen is self explanatory
#+begin_src elisp
  (use-package json-mode :ensure t :pin gnu)

  (when (fboundp 'package-vc-install)
    (unless (require 'hurl-mode nil 'noerrror) (package-vc-install "https://github.com/JasZhe/hurl-mode"))
    (use-package hurl-mode :mode "\\.hurl\\'"
      :config
      (add-to-list 'display-buffer-alist
                   '("\\*hurl-response*\\*"
                     (display-buffer-in-side-window)
                     (window-height . 0.4)))))
#+end_src

** my own window stool mode :)
#+begin_src elisp
  (when (fboundp 'package-vc-install)
    (unless (require 'window-stool nil 'noerrror) (package-vc-install "https://github.com/JasZhe/window-stool"))
    (use-package window-stool :defer 2
      :config
      ;; only overlays in gui otherwises messes up with corfu overlay completions in terminal
      (setq window-stool-use-overlays nil)
      (add-hook 'org-mode-hook #'window-stool-mode)
      (add-hook 'prog-mode-hook #'window-stool-mode)))
#+end_src

** magit
I want to actually learn how to use the built in vc mode a lot more, but there are some cases where having magit is really nice i.e. rebasing or staging specific lines rather than the whole file.
#+begin_src elisp
  (use-package magit :after (vc-dir) :ensure t :pin nongnu
    :config
    (add-to-list 'auto-mode-alist '("/git-rebase-todo\\'" . git-rebase-mode))

    (viper-map! :leader "gg" #'magit

                :mode 'magit-status-mode
                :n "C-w" my-window-map
                "x" #'magit-discard
                "`" #'magit-process-buffer
                "E" #'magit-ediff
                "C-l" #'magit-log
                "C-b" #'magit-branch
                "p" #'magit-push
                "F" #'magit-pull
                "SPC gF" #'magit-fetch
                ;; for terminal issues with C-i
                "<tab>" (lambda () (interactive) (call-interactively (lookup-key magit-mode-map "\t")))

                :mode 'magit-diff-mode
                :n
                "C-w" #'my-window-map
                )

    (add-to-list 'display-buffer-alist
                 '("magit:.*"
                   (display-buffer-same-window))))
#+end_src

#+begin_src elisp
  (rassq-delete-all 'git-rebase-mode auto-mode-alist)
#+end_src

** diff-hl
#+begin_src elisp
  (use-package diff-hl :ensure t :pin gnu :after viper
    :config
    (global-diff-hl-mode)
    (unless (display-graphic-p) (diff-hl-margin-mode))

    (add-to-list 'display-buffer-alist
                 '("\\*diff-hl\\*" (display-buffer-in-side-window)))

    (viper-map! :leader "gr" #'diff-hl-revert-hunk
                "gs" #'diff-hl-show-hunk)

    (add-to-list 'brac-char-cmd-alist '(?d . (lambda () (interactive) (diff-hl-previous-hunk))))
    (add-to-list 'brac-char-cmd-alist '(?D . (lambda () (interactive) (diff-hl-show-hunk-previous))))

    (add-to-list 'ket-char-cmd-alist '(?d . (lambda () (interactive) (diff-hl-next-hunk))))
    (add-to-list 'ket-char-cmd-alist '(?D . (lambda () (interactive) (diff-hl-show-hunk-next))))
    (use-package magit :config
      (add-hook 'magit-pre-refresh-hook 'diff-hl-magit-pre-refresh)
      (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)))
#+end_src

** denote
#+begin_src elisp
  (use-package denote :ensure t :pin gnu :defer 2
    :config
    (setq denote-directory "~/orgmode/notes")
    (viper-map! :leader "do" #'denote-open-or-create
                "dd" #'denote-open-or-create
                "dt" #'denote-type
                "dn" #'denote))
#+end_src


** Dired subtree
https://github.com/Fuco1/dired-hacks
#+begin_src elisp
  (when (fboundp 'package-vc-install)
    (unless (require 'dired-subtree nil 'noerror)
      (package-vc-install '(dired-subtree :url "https://github.com/JasZhe/dired-hacks")))
    (viper-map! :mode 'dired-mode "<tab>" #'dired-subtree-toggle))
#+end_src

** coterm
#+begin_src elisp
  (use-package coterm :ensure t
    :config 
    (coterm-mode))
#+end_src

** eat
#+begin_src elisp
  (use-package eat :ensure t
    :hook
    (eat-exec . (lambda (&rest _) (eat-line-mode)))
    :config
    (setq eat-enable-auto-line-mode t)
    (viper-map! :leader "ot" #'eat))
#+end_src


* external language packages
:PROPERTIES:
:HEADER-ARGS: :tangle no
:END:
** web mode
no good replacement, just have to turn on js-mode or js-jsx-mode and html-mode
#+begin_src elisp
    (unless (require 'web-mode nil 'noerrror)
      (package-vc-install '(web-mode :url "https://github.com/fxbois/web-mode"
                                     :rev "82847071ce93293bdb7945db08d970f13fd883cf")))
    (use-package web-mode :ensure nil :pin gnu
      :mode "\\.gohtml\\'"
      :config
      (setq web-mode-engines-alist '(("go" . "\\.gohtml\\'") ("svelte" . "\\.svelte\\'"))))
#+end_src

** markdown
#+begin_src elisp :tangle no
  (use-package markdown-mode :ensure t)
#+end_src

** pdf tools
just browse pdfs with external tools
#+begin_src elisp
  (use-package pdf-tools :ensure nil :pin gnu
    :mode "\\.pdf\\'"
    :config
      (setq my/pdf-vi-state-modify-map (make-sparse-keymap))
      (define-key my/pdf-vi-state-modify-map "o" #'pdf-outline)
      (define-key my/pdf-vi-state-modify-map "H" #'pdf-view-fit-height-to-window)
      (define-key my/pdf-vi-state-modify-map "W" #'pdf-view-fit-width-to-window)
      (define-key my/pdf-vi-state-modify-map "j" #'pdf-view-next-line-or-next-page)
      (define-key my/pdf-vi-state-modify-map "k" #'pdf-view-previous-line-or-previous-page)
     (setq pdf-view-resize-factor 1.10)
      (define-key my/pdf-vi-state-modify-map "+" #'pdf-view-enlarge)
      (define-key my/pdf-vi-state-modify-map "-" #'pdf-view-shrink)

      (viper-modify-major-mode 'pdf-view-mode 'vi-state my/pdf-vi-state-modify-map)
    )
#+end_src

* attempt at evil mode setup
:PROPERTIES:
:HEADER-ARGS: :tangle no
:END:

#+begin_src elisp
  (use-package evil :ensure t
    :config
    (setq evil-want-C-u-scroll t))

  (unless (require 'evil-collection nil 'noerror)
    (package-vc-install '(evil-collection :url "https://github.com/emacs-evil/evil-collection")))
  (use-package evil-collection :after evil
    :config
    (evil-collection-init))
#+end_src

* custom
#+begin_src elisp
  (custom-set-variables
   ;; custom-set-variables was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   '(package-selected-packages '(window-stool))
   '(package-vc-selected-packages
     '((window-stool :vc-backend Git :url "https://github.com/JasZhe/window-stool")))
   '(safe-local-variable-values
     '((eval add-hook 'after-save-hook
             (lambda nil
               (org-babel-tangle))
             nil t))))
#+end_src

* Local variables                                                        
;; Local Variables:                                                      
;; eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle)) nil t)
;; End:                                                                  
